<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2208-在 Intel GPU 上的一次优化</title>
    <link href="/2022/08/12/2022/2208-%E5%9C%A8-Intel-GPU-%E4%B8%8A%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96/"/>
    <url>/2022/08/12/2022/2208-%E5%9C%A8-Intel-GPU-%E4%B8%8A%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>PAC 2022 优化组竞赛要求使用 Intel GPU，在这里进行一些测试和学习</p><span id="more"></span><h1 id="卡"><a href="#卡" class="headerlink" title="卡"></a>卡</h1><p>首先我先试图摸清自己用的是什么设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci -k | grep -EA3 <span class="hljs-string">&#x27;VGA|3D|Display&#x27;</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="image1.png" width="80%" height="80%"></p><p>编号 7270，在 Intel 官网上也没找到相应的资料，非常难进行分析。</p><h1 id="代码执行模型"><a href="#代码执行模型" class="headerlink" title="代码执行模型"></a>代码执行模型</h1><h2 id="异构计算模型"><a href="#异构计算模型" class="headerlink" title="异构计算模型"></a>异构计算模型</h2><p>由于异构设备的存在，我们不必将所有的计算部分代码放在 CPU 上执行。但是 DPCPP 提供的思路是，我们不需要将代码分开编写，可以使用 regular code + device kernel API 的方法进行编程，从而减轻项目管理的负担。例如在 Cuda + Cpp 编程的时候复杂的编译器更换和环境处理需要很多经验，OneAPI 从设计上避免了这一问题。</p><p><img src="image2.png" width="80%" height="80%"></p><p>官方的一个例子：</p><p><img src="image3.png" width="80%" height="80%"></p><p>其中 Host code 是 CPU 执行的代码，Device code 是异构设备执行的代码。sycl::Queue 作为一种执行机制，计算任务或者说不同的核函数是提交给执行队列调度的。</p><p>执行逻辑和一遍编程不同的地方在于：</p><ol><li>调度逻辑是异步的。host 和 device 分别按照各自的逻辑执行。对 host 来说，遇到 device code，将任务提交给对应设备队列，之后直接执行之后的任务，除非我们提出需要等待或者需要使用 device 返回的数据（和 async + future 的逻辑类似）；对 device 来说，获取任务之后等待 runtime 调度。device 的 runtime 会根据当前任务的依赖关系分析，是否可以执行。</li><li>虽然 host 和 device 的代码都写在同一个 C++ 代码文件中，但是 device 代码进行了一些功能上的限制以保证性能。例如动态内存申请(dynamic allocation)和运行时类型信息(RTTI)是不支持的。</li><li>由于功能限制，sycl 上定义的一些函数只能在特定类型设备上执行。</li></ol><p>简而言之，DPCPP 在 CPP 的基础上，为了适应异构计算，提供了<strong>异步编程环境 + 异步设备编程限制</strong>。</p><p>个人评价：这种执行方案和编程思想固然是好的，但是编译器会承担过多的责任。对于不同的设备和平台，大家使用的内存模型、计算模型往往不一样，为此，需要进行的优化是迥然不同的。使用通用的 DPCPP 的编译器是任重道远的任务。皮衣老黄的一些锐评也指出了 OneAPI 在商业上的激进。但是我个人认为这未必是坏事，改项目很有可能作为未来 C 语系的重要编译器发展方向，异构编译的思路应该结合图计算进行。将计算更充分的进行调度。</p><h2 id="调度设备方法"><a href="#调度设备方法" class="headerlink" title="调度设备方法"></a>调度设备方法</h2><p>如上图所示，我们的计算设备的调度都是通过 queue 进行的，将任务放入其中，<strong>理论上，如果队列中的任务是没有依赖的，那么会自动调度</strong>。</p><p>为了充分调度每一个设备，调度方法是：<strong>为每一个计算设备单独开设对应的调度队列</strong>。</p><p><img src="image4.png" width="80%" height="80%"></p><p><img src="image5.png" width="80%" height="80%"></p><p>queue 调度的优势是可以处理计算任务的依赖，如果有依赖可以自动处理（机理应该是和 TBB 中的一致，待学习）。</p><h1 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h1><p>本次项目是在一次比赛中接触的，比赛时要求对一个矩阵乘法进行优化，原始核心代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp">reduction(+:ach_re0, ach_re1, ach_re2, ach_im0, ach_im1, ach_im2)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0</span>; n1 &lt; number_bands; ++n1) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ig = <span class="hljs-number">0</span>; ig &lt; ncouls; ++ig) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> my_igp = <span class="hljs-number">0</span>; my_igp &lt; ngpown; ++my_igp) &#123;<br>      <span class="hljs-keyword">int</span> indigp = inv_igp_index(my_igp);<br>      <span class="hljs-keyword">int</span> igp = indinv(indigp);<br>      DataType achtemp_re_loc[nend - nstart], achtemp_im_loc[nend - nstart];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> iw = nstart; iw &lt; nend; ++iw) &#123;<br>        achtemp_re_loc[iw] = <span class="hljs-number">0.00</span>;<br>        achtemp_im_loc[iw] = <span class="hljs-number">0.00</span>;<br>      &#125;<br>      ComplexType sch_store1 =<br>          ComplexType_conj(aqsmtemp(n1, igp)) * aqsntemp(n1, igp) * <span class="hljs-number">0.5</span> *<br>          vcoul(igp) * wtilde_array(my_igp, igp);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> iw = nstart; iw &lt; nend; ++iw) &#123;<br>        ComplexType wdiff =<br>            wx_array(iw) - wtilde_array(my_igp, ig);<br>        ComplexType delw =<br>            ComplexType_conj(wdiff) *<br>            (<span class="hljs-number">1</span> / (wdiff * ComplexType_conj(wdiff)).real());<br>        ComplexType sch_array =<br>            delw * I_eps_array(my_igp, ig) * sch_store1;<br><br>        achtemp_re_loc[iw] += (sch_array).real();<br>        achtemp_im_loc[iw] += (sch_array).imag();<br>      &#125;<br>      ach_re0 += achtemp_re_loc[<span class="hljs-number">0</span>];<br>      ach_re1 += achtemp_re_loc[<span class="hljs-number">1</span>];<br>      ach_re2 += achtemp_re_loc[<span class="hljs-number">2</span>];<br>      ach_im0 += achtemp_im_loc[<span class="hljs-number">0</span>];<br>      ach_im1 += achtemp_im_loc[<span class="hljs-number">1</span>];<br>      ach_im2 += achtemp_im_loc[<span class="hljs-number">2</span>];<br>    &#125;<br>  &#125; <br>&#125;   <br><br><br>achtemp(<span class="hljs-number">0</span>) = ComplexType(ach_re0, ach_im0);<br>achtemp(<span class="hljs-number">1</span>) = ComplexType(ach_re1, ach_im1);<br>achtemp(<span class="hljs-number">2</span>) = ComplexType(ach_re2, ach_im2);<br></code></pre></td></tr></table></figure><h2 id="基础分析"><a href="#基础分析" class="headerlink" title="基础分析"></a>基础分析</h2><p>首先使用 Vtune 进行了初步分析，得到以下结果：</p><p><img src="image6.png" width="80%" height="80%"></p><p><img src="image7.png" width="80%" height="80%"></p><p><img src="image8.png" width="80%" height="80%"></p><p><img src="image9.png" width="80%" height="80%"></p><p><img src="image10.png" width="80%" height="80%"></p><p>简单来说，访存成为了瓶颈，此外计算核心全部位于多重矩阵乘法，因此优化思路大致如下：</p><ol><li>优化访存次序</li><li>抑制 GPU</li><li>调整 GPU 访存</li></ol><h2 id="访存次序"><a href="#访存次序" class="headerlink" title="访存次序"></a>访存次序</h2><p>首先将访存中行列顺序反常的项更改，减少访存消耗。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">reduction(+:ach_re0, ach_re1, ach_re2, ach_im0, ach_im1, ach_im2)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number_bands; ++i) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ncouls; ++j) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; ngpown; ++k) &#123;<br>      <span class="hljs-keyword">int</span> indigp = inv_igp_index(k);<br>      <span class="hljs-keyword">int</span> igp = indinv(indigp);<br>      DataType achtemp_re_loc[nend - nstart], achtemp_im_loc[nend - nstart];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> iw = nstart; iw &lt; nend; ++iw) &#123;<br>        achtemp_re_loc[iw] = <span class="hljs-number">0.00</span>;<br>        achtemp_im_loc[iw] = <span class="hljs-number">0.00</span>;<br>      &#125;<br>      ComplexType sch_store1 =<br>          ComplexType_conj(aqsmtemp(i, igp)) * aqsntemp(i, igp) * <span class="hljs-number">0.5</span> *<br>          vcoul(igp) * wtilde_array(igp, k);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> iw = nstart; iw &lt; nend; ++iw) &#123;<br>        ComplexType wdiff =<br>            wx_array(iw) - wtilde_array(j, k);<br>        ComplexType delw =<br>            ComplexType_conj(wdiff) *<br>            (<span class="hljs-number">1</span> / (wdiff * ComplexType_conj(wdiff)).real());<br>        ComplexType sch_array =<br>            delw * I_eps_array(k, j) * sch_store1;<br><br>        achtemp_re_loc[iw] += (sch_array).real();<br>        achtemp_im_loc[iw] += (sch_array).imag();<br>      &#125;<br>      ach_re0 += achtemp_re_loc[<span class="hljs-number">0</span>];<br>      ach_re1 += achtemp_re_loc[<span class="hljs-number">1</span>];<br>      ach_re2 += achtemp_re_loc[<span class="hljs-number">2</span>];<br>      ach_im0 += achtemp_im_loc[<span class="hljs-number">0</span>];<br>      ach_im1 += achtemp_im_loc[<span class="hljs-number">1</span>];<br>      ach_im2 += achtemp_im_loc[<span class="hljs-number">2</span>];<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="GPU-移植"><a href="#GPU-移植" class="headerlink" title="GPU 移植"></a>GPU 移植</h1><p>在 GPU 上进行代码移植不是很难，需要解决如下问题：</p><ol><li>CPU 和 GPU 上的数据一致性，如何将数据拷贝过去使用，并如何拷贝回来计算结果</li><li>GPU 的计算模式，是否是基于循环的，如果是，如何编写核函数</li></ol><h3 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h3><p>在 oneAPI 中编程是，和 cuda 中有一个类似的机制，是可以将各个设备是和的内存协同管理，和 PGAS 的设计思想有一定的相似，但是这里的 shared memory 是 global &amp; heterogeneous。</p><p>举个例子，一个数组在 CPU 上开辟，初始化，在异构设备上同步的方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">T a[arr_size];<br><span class="hljs-comment">// ...</span><br><span class="hljs-function">range&lt;1&gt; <span class="hljs-title">arr_range</span><span class="hljs-params">(arr_size)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">arr_buffer</span><span class="hljs-params">(a, arr_range)</span></span>;<br><span class="hljs-comment">// ...</span><br>q.submit([&amp;](handler &amp;h) &#123;<br><span class="hljs-keyword">auto</span> arr_acc = arr_buffer.get_access&lt;access::mode::read&gt;(h);<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">// use arr_acc directly</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的使用方法比较微妙，我们在队列中所有的操作都可以直接被认为是对 a 数组的操作，并且会在队列执行结束之后自动同步。</p><p>之前的内容也提到了，这里的执行是异步的，submit 仅仅是提交了任务，而不是等待任务执行完成。如果在 submit 之后需要进行其他更多的操作，我们需要加上 q.wait() 操作。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>对于并行的循环，我们通常会使用 sycl 中的 parallel_for 进行编程。接口需要的参数是：</p><ol><li>nd_range(range1, range2)</li><li>(optional) functional module</li><li>lambda function</li></ol><p>第一个参数用来指定计算任务的总范围和每一个 kernel 的分块范围<br>第二个参数用来补充额外的 module，例如有一些操作是原子的，或者是需要使用 reduction 功能，则会使用指定的函数<br>第三个参数用于说明循环中执行的具体任务内容</p><h3 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h3><p>对于上面的函数我们实现代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// array range</span><br><span class="hljs-comment">// range for achtemp, wx_array</span><br><span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range1</span><span class="hljs-params">(nend - nstart)</span></span>;<br><span class="hljs-comment">// range for aqsmtemp, aqsntemp</span><br><span class="hljs-function">range&lt;2&gt; <span class="hljs-title">array_range2</span><span class="hljs-params">(number_bands, ncouls)</span></span>;<br><span class="hljs-comment">// range for I_eps_array</span><br><span class="hljs-function">range&lt;2&gt; <span class="hljs-title">array_range3</span><span class="hljs-params">(ncouls, ngpown)</span></span>;<br><span class="hljs-comment">// range for wtilde_array</span><br><span class="hljs-function">range&lt;2&gt; <span class="hljs-title">array_range4</span><span class="hljs-params">(ncouls, ngpown)</span></span>;<br><span class="hljs-comment">// range for vcoul</span><br><span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range5</span><span class="hljs-params">(ncouls)</span></span>;<br><span class="hljs-comment">// range for inv_igp_index</span><br><span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range6</span><span class="hljs-params">(ngpown)</span></span>;<br><span class="hljs-comment">// range for indinv</span><br><span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range7</span><span class="hljs-params">(ncouls + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-comment">// buffer</span><br><span class="hljs-function">buffer <span class="hljs-title">inv_igp_index_buf</span><span class="hljs-params">(inv_igp_index.dptr, array_range6)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">indinv_buf</span><span class="hljs-params">(indinv.dptr, array_range7)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">wx_array_buf</span><span class="hljs-params">(wx_array.dptr, array_range1)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">wtilde_array_buf</span><span class="hljs-params">(wtilde_array.dptr, array_range4)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">aqsmtemp_buf</span><span class="hljs-params">(aqsmtemp.dptr, array_range2)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">aqsntemp_buf</span><span class="hljs-params">(aqsntemp.dptr, array_range2)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">I_eps_array_buf</span><span class="hljs-params">(I_eps_array.dptr, array_range3)</span></span>;<br><span class="hljs-function">buffer <span class="hljs-title">vcoul_buf</span><span class="hljs-params">(vcoul.dptr, array_range5)</span></span>;<br><span class="hljs-comment">// queue and loop range</span><br><span class="hljs-function"><span class="hljs-built_in">queue</span> <span class="hljs-title">q</span><span class="hljs-params">(gpu_selector&#123;&#125;)</span></span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> N = <span class="hljs-number">1024</span>; <span class="hljs-comment">// global size</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> B = <span class="hljs-number">256</span>; <span class="hljs-comment">// work-group size</span><br><span class="hljs-function">range&lt;3&gt; <span class="hljs-title">loop_range</span><span class="hljs-params">(number_bands, ncouls, ngpown)</span></span>;<br>ComplexType *ach0 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q);<br>ComplexType *ach1 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q);<br>ComplexType *ach2 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q);<br><br><span class="hljs-comment">// ...</span><br>q.submit([&amp;](handler &amp;h) &#123;<br>  <span class="hljs-comment">// accessor</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Update read-only</span><br>  <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>  <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>  <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>  <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>  <span class="hljs-keyword">auto</span> aqsmtemp_acc = aqsmtemp_buf.get_access&lt;access::mode::read&gt;(h);<br>  <span class="hljs-keyword">auto</span> aqsntemp_acc = aqsntemp_buf.get_access&lt;access::mode::read&gt;(h);<br>  <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>  <span class="hljs-keyword">auto</span> vcoul_acc = vcoul_buf.get_access&lt;access::mode::read&gt;(h);<br>  <br>  h.parallel_for(<br>    nd_range&lt;<span class="hljs-number">3</span>&gt;(loop_range, range&lt;<span class="hljs-number">3</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ngpown / <span class="hljs-number">2</span>)),<br>    sycl::ext::oneapi::reduction(<br>        ach2,<br>        ComplexType(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">std</span>::plus&lt;ComplexType&gt;()<br>    ),<br>    [=](nd_item&lt;<span class="hljs-number">3</span>&gt; index, <span class="hljs-keyword">auto</span> &amp;temp) &#123;<br>        <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> j = index.get_global_id(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>        <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>        ComplexType aqsmconj = ComplexType(aqsmtemp_acc[i][igp].real(), \<br>               -aqsmtemp_acc[i][igp].imag());<br>      ComplexType sch_store1 = aqsmconj * aqsntemp_acc[i][igp] * <span class="hljs-number">0.5</span> * \<br>                             vcoul_acc[igp] * wtilde_array_acc[igp][k];<br>        ComplexType wdiff = wx_array_acc[<span class="hljs-number">2</span>] - wtilde_array_acc[j][k];<br>        ComplexType delw = ComplexType_conj(wdiff) * \<br>                       (<span class="hljs-number">1</span> / (wdiff * ComplexType_conj(wdiff)).real());<br>        ComplexType sch_array = delw * I_eps_array_acc[j][k] * sch_store1;<br>        temp.combine(sch_array);<br>      &#125;<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>由于类型限制，我们三次统计需要分别执行，这里省去了一些同样的代码片段</p><h1 id="BlockSize"><a href="#BlockSize" class="headerlink" title="BlockSize"></a>BlockSize</h1><p>对于 GPU 来说，最重要的一个参数调整，就是计算网格大小的划分。我们每一个 block 计算多少，维度如何分配，这些都会对计算效率产生一定的影响。Intel 计算中也是如此。一般的做法是可以使用调参脚本完成，也可以使用对 Cache 大小进行粗略计算得到范围后细致微调。</p><p>例如本算例中我们试出<br>nd_range<3>(loop_range, range<3>(8, 2, 64))<br>是最好的 blocksize。</p><h1 id="双卡双开"><a href="#双卡双开" class="headerlink" title="双卡双开"></a>双卡双开</h1><p>之后一个重要的方法是调用多设备，构建了可以调度两张卡的设备队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_multi_gpu_v2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">queue</span>&gt; &amp;qs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">auto</span> platforms = platform::get_platforms();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; p : platforms) &#123;<br>    <span class="hljs-keyword">auto</span> pname = p.get_info&lt;info::platform::name&gt;();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Platform: &quot;</span> &lt;&lt; pname &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">if</span> ( pname.find(<span class="hljs-string">&quot;Level-Zero&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Level Zero GPU skipped&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> devices = p.get_devices();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; d : devices ) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; Device: &quot;</span> &lt;&lt; d.get_info&lt;info::device::name&gt;() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">if</span> ( d.is_gpu() ) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Device is GPU - adding to vector of queues&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>            qs.push_back(<span class="hljs-built_in">queue</span>(d));<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并将计算均匀划分到两个队列中。</p><h1 id="提取因子"><a href="#提取因子" class="headerlink" title="提取因子"></a>提取因子</h1><p>这里提取了一些公因子用更好的计算，我们回顾一下之前的 kernel function：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">h.parallel_for(<br>  nd_range&lt;<span class="hljs-number">3</span>&gt;(loop_range, range&lt;<span class="hljs-number">3</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ngpown / <span class="hljs-number">2</span>)),<br>  sycl::ext::oneapi::reduction(<br>      ach2,<br>      ComplexType(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">std</span>::plus&lt;ComplexType&gt;()<br>  ),<br>  [=](nd_item&lt;<span class="hljs-number">3</span>&gt; index, <span class="hljs-keyword">auto</span> &amp;temp) &#123;<br>      <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">int</span> j = index.get_global_id(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>      <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>      ComplexType aqsmconj = ComplexType(aqsmtemp_acc[i][igp].real(), \<br>             -aqsmtemp_acc[i][igp].imag());<br>    ComplexType sch_store1 = aqsmconj * aqsntemp_acc[i][igp] * <span class="hljs-number">0.5</span> * \<br>                           vcoul_acc[igp] * wtilde_array_acc[igp][k];<br>      ComplexType wdiff = wx_array_acc[<span class="hljs-number">2</span>] - wtilde_array_acc[j][k];<br>      ComplexType delw = ComplexType_conj(wdiff) * \<br>                     (<span class="hljs-number">1</span> / (wdiff * ComplexType_conj(wdiff)).real());<br>      ComplexType sch_array = delw * I_eps_array_acc[j][k] * sch_store1;<br>      temp.combine(sch_array);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p>不难看出：sch_store1 是一个只和 i k 相关的量，进行了重复的计算。为此将这部分单独提取计算存储。<br>优化代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// queue and loop range</span><br> <span class="hljs-built_in">queue</span> &amp;q1 = qs[<span class="hljs-number">0</span>];<br> <span class="hljs-built_in">queue</span> &amp;q2 = qs[<span class="hljs-number">1</span>];<br> <span class="hljs-function">range&lt;3&gt; <span class="hljs-title">loop_range</span><span class="hljs-params">(ncouls / <span class="hljs-number">2</span>, ngpown, number_bands)</span></span>;<br> <span class="hljs-function">range&lt;2&gt; <span class="hljs-title">factor_loop_range</span><span class="hljs-params">(ngpown / <span class="hljs-number">2</span>, number_bands)</span></span>;<br><br> ComplexType *ach0 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q1);<br> ComplexType *ach1 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q1);<br> ComplexType *ach2 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q1);<br><br> ComplexType *bch0 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q2);<br> ComplexType *bch1 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q2);<br> ComplexType *bch2 = malloc_shared&lt;ComplexType&gt;(<span class="hljs-number">1</span>, q2);<br> <br> <br> q1.submit([&amp;](handler &amp;h) &#123;<br>         <span class="hljs-comment">// accessor</span><br>         <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> aqsmtemp_acc = aqsmtemp_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> aqsntemp_acc = aqsntemp_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> vcoul_acc = vcoul_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::write&gt;(h);<br>         h.parallel_for(<br>                 nd_range&lt;<span class="hljs-number">2</span>&gt;(factor_loop_range, range&lt;<span class="hljs-number">2</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">512</span>)),<br>                 [=](nd_item&lt;<span class="hljs-number">2</span>&gt; index) &#123;<br>                     <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">0</span>);<br>                     <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">1</span>);<br>                     <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                     <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                     ComplexType aqsmconj = ComplexType(aqsmtemp_acc[igp][i].real(), -aqsmtemp_acc[igp][i].imag());<br>                     factor_acc[k][i] = aqsmconj * aqsntemp_acc[igp][i] * <span class="hljs-number">0.5</span> * vcoul_acc[igp] * wtilde_array_acc[igp][k];<br>                 &#125;<br>       );<br> &#125;);<br> q2.submit([&amp;](handler &amp;h) &#123;<br>         <span class="hljs-comment">// accessor</span><br>         <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> aqsmtemp_acc = aqsmtemp_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> aqsntemp_acc = aqsntemp_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> vcoul_acc = vcoul_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::write&gt;(h);<br>         h.parallel_for(<br>                 nd_range&lt;<span class="hljs-number">2</span>&gt;(factor_loop_range, range&lt;<span class="hljs-number">2</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">512</span>)),<br>                 [=](nd_item&lt;<span class="hljs-number">2</span>&gt; index) &#123;<br>                     <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">0</span>) + ngpown / <span class="hljs-number">2</span>;<br>                     <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">1</span>);<br>                     <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                     <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                     ComplexType aqsmconj = ComplexType(aqsmtemp_acc[igp][i].real(), -aqsmtemp_acc[igp][i].imag());<br>                     factor_acc[k][i] = aqsmconj * aqsntemp_acc[igp][i] * <span class="hljs-number">0.5</span> * vcoul_acc[igp] * wtilde_array_acc[igp][k];<br>                 &#125;<br>       );<br> &#125;);<br> q1.wait();<br> q2.wait();<br><br> q1.submit([&amp;](handler &amp;h) &#123;<br>         <span class="hljs-comment">// accessor</span><br>         <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::read&gt;(h);<br><br>         h.parallel_for(<br>                 nd_range&lt;<span class="hljs-number">3</span>&gt;(loop_range, range&lt;<span class="hljs-number">3</span>&gt;(<span class="hljs-number">32</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>)),<br>                 sycl::ext::oneapi::reduction(<br>                     ach0,<br>                     ComplexType(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>                     <span class="hljs-built_in">std</span>::plus&lt;ComplexType&gt;()<br>                 ),<br>                 [=](nd_item&lt;<span class="hljs-number">3</span>&gt; index, <span class="hljs-keyword">auto</span> &amp;temp) &#123;<br>                     <span class="hljs-keyword">int</span> j = index.get_global_id(<span class="hljs-number">0</span>);<br>                     <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">1</span>);<br>                     <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">2</span>);<br>                     <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                     <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                     ComplexType wdiff = wx_array_acc[<span class="hljs-number">0</span>] - wtilde_array_acc[j][k];<br>                     ComplexType delw = ComplexType_conj(wdiff) / (wdiff.real() * wdiff.real() + wdiff.imag() * wdiff.imag());<br>                     ComplexType sch_array = delw * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                     temp.combine(sch_array);<br>                 &#125;<br>       );<br> &#125;);<br> q2.submit([&amp;](handler &amp;h) &#123;<br>         <span class="hljs-comment">// accessor</span><br>         <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> aqsmtemp_acc = aqsmtemp_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> aqsntemp_acc = aqsntemp_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> vcoul_acc = vcoul_buf.get_access&lt;access::mode::read&gt;(h);<br>         <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::read&gt;(h);<br><br>         h.parallel_for(<br>                 nd_range&lt;<span class="hljs-number">3</span>&gt;(loop_range, range&lt;<span class="hljs-number">3</span>&gt;(<span class="hljs-number">32</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>)),<br>                 sycl::ext::oneapi::reduction(<br>                     bch0,<br>                     ComplexType(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>                     <span class="hljs-built_in">std</span>::plus&lt;ComplexType&gt;()<br>                 ),<br>                 [=](nd_item&lt;<span class="hljs-number">3</span>&gt; index, <span class="hljs-keyword">auto</span> &amp;temp) &#123;<br>                     <span class="hljs-keyword">int</span> j = index.get_global_id(<span class="hljs-number">0</span>) + ncouls / <span class="hljs-number">2</span>;<br>                     <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">1</span>);<br>                     <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">2</span>);<br>                     <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                     <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                     ComplexType wdiff = wx_array_acc[<span class="hljs-number">0</span>] - wtilde_array_acc[j][k];<br>                     ComplexType delw = ComplexType_conj(wdiff) / (wdiff.real() * wdiff.real() + wdiff.imag() * wdiff.imag());<br>                     ComplexType sch_array = delw * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                     temp.combine(sch_array);<br>                 &#125;<br>       );<br> &#125;);<br><br> q1.wait();<br> q2.wait();<br> ach_re0 = ach0-&gt;real() + bch0-&gt;real();<br> ach_im0 = ach0-&gt;imag() + bch0-&gt;imag();<br> sycl::<span class="hljs-built_in">free</span>(ach0, q1);<br> sycl::<span class="hljs-built_in">free</span>(bch0, q2);<br></code></pre></td></tr></table></figure></p><h1 id="自定义-reduction-类型"><a href="#自定义-reduction-类型" class="headerlink" title="自定义 reduction 类型"></a>自定义 reduction 类型</h1><p>最后，整理代码，重复三次的计算带来了更多的工作量，如果需要更好的提升效率，我们需要将 reduction 进行微调处理，自定义重载 <code>std::plus</code> 的类型。</p><p>完整的函数如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noflagOCC_solver</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> number_bands, <span class="hljs-keyword">size_t</span> ngpown, <span class="hljs-keyword">size_t</span> ncouls,</span></span><br><span class="hljs-function"><span class="hljs-params">                      ARRAY1D_int &amp;inv_igp_index, ARRAY1D_int &amp;indinv,</span></span><br><span class="hljs-function"><span class="hljs-params">                      ARRAY1D_DataType &amp;wx_array, ARRAY2D &amp;wtilde_array,</span></span><br><span class="hljs-function"><span class="hljs-params">                      ARRAY2D &amp;aqsmtemp, ARRAY2D &amp;aqsntemp,</span></span><br><span class="hljs-function"><span class="hljs-params">                      ARRAY2D &amp;I_eps_array, ARRAY1D_DataType &amp;vcoul,</span></span><br><span class="hljs-function"><span class="hljs-params">                      ARRAY1D &amp;achtemp,  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">queue</span>&gt; &amp;qs)</span> </span>&#123;<br>  time_point&lt;system_clock&gt; start, end;<br>  start = system_clock::now();<br>  <span class="hljs-comment">// Vars to use for reduction</span><br>  DataType ach_re0 = <span class="hljs-number">0.00</span>, ach_re1 = <span class="hljs-number">0.00</span>, ach_re2 = <span class="hljs-number">0.00</span>, ach_im0 = <span class="hljs-number">0.00</span>,<br>           ach_im1 = <span class="hljs-number">0.00</span>, ach_im2 = <span class="hljs-number">0.00</span>;<br><br>  <span class="hljs-comment">// array range</span><br>  <span class="hljs-comment">// range for achtemp, wx_array</span><br>  <span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range1</span><span class="hljs-params">(nend - nstart)</span></span>;<br>  <span class="hljs-comment">// range for aqsmtemp, aqsntemp</span><br>  <span class="hljs-function">range&lt;2&gt; <span class="hljs-title">array_range2</span><span class="hljs-params">(ncouls, number_bands)</span></span>;<br>  <span class="hljs-comment">// range for I_eps_array</span><br>  <span class="hljs-function">range&lt;2&gt; <span class="hljs-title">array_range3</span><span class="hljs-params">(ncouls, ngpown)</span></span>;<br>  <span class="hljs-comment">// range for wtilde_array</span><br>  <span class="hljs-function">range&lt;2&gt; <span class="hljs-title">array_range4</span><span class="hljs-params">(ncouls, ngpown)</span></span>;<br>  <span class="hljs-comment">// range for vcoul</span><br>  <span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range5</span><span class="hljs-params">(ncouls)</span></span>;<br>  <span class="hljs-comment">// range for inv_igp_index</span><br>  <span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range6</span><span class="hljs-params">(ngpown)</span></span>;<br>  <span class="hljs-comment">// range for indinv</span><br>  <span class="hljs-function">range&lt;1&gt; <span class="hljs-title">array_range7</span><span class="hljs-params">(ncouls + <span class="hljs-number">1</span>)</span></span>;<br><br>  <span class="hljs-function">ARRAY2D <span class="hljs-title">factor</span><span class="hljs-params">(ncouls, number_bands)</span></span>;<br>  <span class="hljs-comment">// buffer</span><br>  <span class="hljs-function">buffer <span class="hljs-title">inv_igp_index_buf</span><span class="hljs-params">(inv_igp_index.dptr, array_range6)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">indinv_buf</span><span class="hljs-params">(indinv.dptr, array_range7)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">wx_array_buf</span><span class="hljs-params">(wx_array.dptr, array_range1)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">wtilde_array_buf</span><span class="hljs-params">(wtilde_array.dptr, array_range4)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">aqsmtemp_buf</span><span class="hljs-params">(aqsmtemp.dptr, array_range2)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">aqsntemp_buf</span><span class="hljs-params">(aqsntemp.dptr, array_range2)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">I_eps_array_buf</span><span class="hljs-params">(I_eps_array.dptr, array_range3)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">vcoul_buf</span><span class="hljs-params">(vcoul.dptr, array_range5)</span></span>;<br>  <span class="hljs-function">buffer <span class="hljs-title">factor_buf</span><span class="hljs-params">(factor.dptr, array_range2)</span></span>;<br><br>  <span class="hljs-comment">// queue and loop range</span><br>  <span class="hljs-built_in">queue</span> &amp;q1 = qs[<span class="hljs-number">0</span>];<br>  <span class="hljs-built_in">queue</span> &amp;q2 = qs[<span class="hljs-number">1</span>];<br>  <span class="hljs-function">range&lt;3&gt; <span class="hljs-title">loop_range</span><span class="hljs-params">(ncouls / <span class="hljs-number">2</span>, ngpown, number_bands)</span></span>;<br>  <span class="hljs-function">range&lt;2&gt; <span class="hljs-title">factor_loop_range</span><span class="hljs-params">(ngpown / <span class="hljs-number">2</span>, number_bands)</span></span>;<br>  <br>  q1.submit([&amp;](handler &amp;h) &#123;<br>          <span class="hljs-comment">// accessor</span><br>          <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> aqsmtemp_acc = aqsmtemp_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> aqsntemp_acc = aqsntemp_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> vcoul_acc = vcoul_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::write&gt;(h);<br>          h.parallel_for(<br>                  nd_range&lt;<span class="hljs-number">2</span>&gt;(factor_loop_range, range&lt;<span class="hljs-number">2</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">512</span>)),<br>                  [=](nd_item&lt;<span class="hljs-number">2</span>&gt; index) &#123;<br>                      <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">1</span>);<br>                      <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                      <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                      ComplexType aqsmconj = ComplexType(aqsmtemp_acc[igp][i].real(), -aqsmtemp_acc[igp][i].imag());<br>                      factor_acc[k][i] = aqsmconj * aqsntemp_acc[igp][i] * <span class="hljs-number">0.5</span> * vcoul_acc[igp] * wtilde_array_acc[igp][k];<br>                  &#125;<br>        );<br>  &#125;);<br>  q2.submit([&amp;](handler &amp;h) &#123;<br>          <span class="hljs-comment">// accessor</span><br>          <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> aqsmtemp_acc = aqsmtemp_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> aqsntemp_acc = aqsntemp_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> vcoul_acc = vcoul_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::write&gt;(h);<br>          h.parallel_for(<br>                  nd_range&lt;<span class="hljs-number">2</span>&gt;(factor_loop_range, range&lt;<span class="hljs-number">2</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">512</span>)),<br>                  [=](nd_item&lt;<span class="hljs-number">2</span>&gt; index) &#123;<br>                      <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">0</span>) + ngpown / <span class="hljs-number">2</span>;<br>                      <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">1</span>);<br>                      <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                      <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                      ComplexType aqsmconj = ComplexType(aqsmtemp_acc[igp][i].real(), -aqsmtemp_acc[igp][i].imag());<br>                      factor_acc[k][i] = aqsmconj * aqsntemp_acc[igp][i] * <span class="hljs-number">0.5</span> * vcoul_acc[igp] * wtilde_array_acc[igp][k];<br>                  &#125;<br>        );<br>  &#125;);<br>  q1.wait();<br>  q2.wait();<br><br>  CollectorResult *collector_a = malloc_shared&lt;CollectorResult&gt;(<span class="hljs-number">1</span>, q1);<br>  CollectorResult *collector_b = malloc_shared&lt;CollectorResult&gt;(<span class="hljs-number">2</span>, q2);<br>  q1.submit([&amp;](handler &amp;h) &#123;<br>          <span class="hljs-comment">// accessor</span><br>          <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::read&gt;(h);<br><br>          h.parallel_for(<br>                  nd_range&lt;<span class="hljs-number">3</span>&gt;(loop_range, range&lt;<span class="hljs-number">3</span>&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>)),<br>                  sycl::ext::oneapi::reduction(<br>                      collector_a,<br>                      CollectorResult(),<br>                      <span class="hljs-built_in">std</span>::plus&lt;CollectorResult&gt;()<br>                  ),<br>                  [=](nd_item&lt;<span class="hljs-number">3</span>&gt; index, <span class="hljs-keyword">auto</span> &amp;temp) &#123;<br>                      <span class="hljs-keyword">int</span> j = index.get_global_id(<span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">1</span>);<br>                      <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">2</span>);<br>                      <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                      <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                      ComplexType wdiff0 = wx_array_acc[<span class="hljs-number">0</span>] - wtilde_array_acc[j][k];<br>                      ComplexType wdiff1 = wx_array_acc[<span class="hljs-number">1</span>] - wtilde_array_acc[j][k];<br>                      ComplexType wdiff2 = wx_array_acc[<span class="hljs-number">2</span>] - wtilde_array_acc[j][k];<br>                      ComplexType delw0 = ComplexType_conj(wdiff0) / (wdiff0.real() * wdiff0.real() + wdiff0.imag() * wdiff0.imag());<br>                      ComplexType delw1 = ComplexType_conj(wdiff1) / (wdiff1.real() * wdiff1.real() + wdiff1.imag() * wdiff1.imag());<br>                      ComplexType delw2 = ComplexType_conj(wdiff2) / (wdiff2.real() * wdiff2.real() + wdiff2.imag() * wdiff2.imag());<br>                      ComplexType sch_array0 = delw0 * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                      ComplexType sch_array1 = delw1 * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                      ComplexType sch_array2 = delw2 * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                      temp.combine(CollectorResult(sch_array0, sch_array1, sch_array2));<br>                  &#125;<br>        );<br>  &#125;);<br>  q2.submit([&amp;](handler &amp;h) &#123;<br>          <span class="hljs-comment">// accessor</span><br>          <span class="hljs-keyword">auto</span> inv_igp_index_acc = inv_igp_index_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> indinv_acc = indinv_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wx_array_acc = wx_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> wtilde_array_acc = wtilde_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> aqsmtemp_acc = aqsmtemp_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> aqsntemp_acc = aqsntemp_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> I_eps_array_acc = I_eps_array_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> vcoul_acc = vcoul_buf.get_access&lt;access::mode::read&gt;(h);<br>          <span class="hljs-keyword">auto</span> factor_acc = factor_buf.get_access&lt;access::mode::read&gt;(h);<br><br>          h.parallel_for(<br>                  nd_range&lt;<span class="hljs-number">3</span>&gt;(loop_range, range&lt;<span class="hljs-number">3</span>&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>)),<br>                  sycl::ext::oneapi::reduction(<br>                      collector_b,<br>                      CollectorResult(),<br>                      <span class="hljs-built_in">std</span>::plus&lt;CollectorResult&gt;()<br>                  ),<br>                  [=](nd_item&lt;<span class="hljs-number">3</span>&gt; index, <span class="hljs-keyword">auto</span> &amp;temp) &#123;<br>                      <span class="hljs-keyword">int</span> j = index.get_global_id(<span class="hljs-number">0</span>) + ncouls / <span class="hljs-number">2</span>;<br>                      <span class="hljs-keyword">int</span> k = index.get_global_id(<span class="hljs-number">1</span>);<br>                      <span class="hljs-keyword">int</span> i = index.get_global_id(<span class="hljs-number">2</span>);<br>                      <span class="hljs-keyword">int</span> indigp = inv_igp_index_acc[k];<br>                      <span class="hljs-keyword">int</span> igp = indinv_acc[indigp];<br>                      ComplexType wdiff0 = wx_array_acc[<span class="hljs-number">0</span>] - wtilde_array_acc[j][k];<br>                      ComplexType wdiff1 = wx_array_acc[<span class="hljs-number">1</span>] - wtilde_array_acc[j][k];<br>                      ComplexType wdiff2 = wx_array_acc[<span class="hljs-number">2</span>] - wtilde_array_acc[j][k];<br>                      ComplexType delw0 = ComplexType_conj(wdiff0) / (wdiff0.real() * wdiff0.real() + wdiff0.imag() * wdiff0.imag());<br>                      ComplexType delw1 = ComplexType_conj(wdiff1) / (wdiff1.real() * wdiff1.real() + wdiff1.imag() * wdiff1.imag());<br>                      ComplexType delw2 = ComplexType_conj(wdiff2) / (wdiff2.real() * wdiff2.real() + wdiff2.imag() * wdiff2.imag());<br>                      ComplexType sch_array0 = delw0 * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                      ComplexType sch_array1 = delw1 * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                      ComplexType sch_array2 = delw2 * I_eps_array_acc[j][k] * factor_acc[k][i];<br>                      temp.combine(CollectorResult(sch_array0, sch_array1, sch_array2));<br>                  &#125;<br>        );<br>  &#125;);<br><br>  q1.wait();<br>  q2.wait();<br>  ach_re0 = collector_a-&gt;a0.real() + collector_b-&gt;a0.real();<br>  ach_im0 = collector_a-&gt;a0.imag() + collector_b-&gt;a0.imag();<br>  ach_re1 = collector_a-&gt;a1.real() + collector_b-&gt;a1.real();<br>  ach_im1 = collector_a-&gt;a1.imag() + collector_b-&gt;a1.imag();<br>  ach_re2 = collector_a-&gt;a2.real() + collector_b-&gt;a2.real();<br>  ach_im2 = collector_a-&gt;a2.imag() + collector_b-&gt;a2.imag();<br><br>  sycl::<span class="hljs-built_in">free</span>(collector_a, q1);<br>  sycl::<span class="hljs-built_in">free</span>(collector_b, q2);<br><br><br>  achtemp(<span class="hljs-number">0</span>) = ComplexType(ach_re0, ach_im0);<br>  achtemp(<span class="hljs-number">1</span>) = ComplexType(ach_re1, ach_im1);<br>  achtemp(<span class="hljs-number">2</span>) = ComplexType(ach_re2, ach_im2);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其中重载的加法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CollectorResult</span> &#123;</span><br>    ComplexType a0;<br>    ComplexType a1;<br>    ComplexType a2;<br>    <br>    CollectorResult() = <span class="hljs-keyword">default</span>;<br>    CollectorResult(ComplexType a, ComplexType b, ComplexType c) : a0(a), a1(b), a2(c) &#123;&#125;<br>    CollectorResult &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CollectorResult &amp;other) = <span class="hljs-keyword">default</span>;<br>    CollectorResult <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> CollectorResult &amp;other) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> CollectorResult(a0 + other.a0, a1 + other.a1, a2 + other.a2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>DPCPP book <a href="https://link.springer.com/content/pdf/10.1007/978-1-4842-5574-2.pdf">https://link.springer.com/content/pdf/10.1007/978-1-4842-5574-2.pdf</a></li><li><a href="https://www.intel.com/content/www/us/en/develop/documentation/oneapi-gpu-optimization-guide/top.html">https://www.intel.com/content/www/us/en/develop/documentation/oneapi-gpu-optimization-guide/top.html</a></li><li>oneapi-3dopt <a href="https://github.com/raoberman/oneAPI-samples-Feb2022/tree/2ea2f30710bed37000a6905662fbbdbf37a30e25/DirectProgramming/DPC%2B%2B/StructuredGrids/iso3dfd_dpcpp">https://github.com/raoberman/oneAPI-samples-Feb2022/tree/2ea2f30710bed37000a6905662fbbdbf37a30e25/DirectProgramming/DPC%2B%2B/StructuredGrids/iso3dfd_dpcpp</a></li><li>oneapi-samples <a href="https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC%2B%2B/StructuredGrids/guided_iso3dfd_GPUOptimization">https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC%2B%2B/StructuredGrids/guided_iso3dfd_GPUOptimization</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OneAPI</tag>
      
      <tag>DPCPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2207-功耗监测软件开发笔记</title>
    <link href="/2022/07/06/2022/2207-%E5%8A%9F%E8%80%97%E7%9B%91%E6%B5%8B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/06/2022/2207-%E5%8A%9F%E8%80%97%E7%9B%91%E6%B5%8B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Version-0-0"><a href="#Version-0-0" class="headerlink" title="Version 0.0"></a>Version 0.0</h1><span id="more"></span><h2 id="功耗监测软件"><a href="#功耗监测软件" class="headerlink" title="功耗监测软件"></a>功耗监测软件</h2><p>2022-07-05 开发测试<br>为了更好的对软件的功耗和行为进行监测</p><h2 id="设计阶段-1"><a href="#设计阶段-1" class="headerlink" title="设计阶段 1"></a>设计阶段 1</h2><p>首先，启发我完善该项目的是一位师弟: <a href="https://github.com/xwy-bit">https://github.com/xwy-bit</a></p><p>原始项目： <a href="https://github.com/xwy-bit/IPMI">https://github.com/xwy-bit/IPMI</a></p><p>那么整理需求，绘制设计草稿：</p><img src="image1.jpeg" width="80%" height="80%"><p>需求有如下：</p><ol><li>如果绘制程序的设置进行了变更，我们需要 Reset</li><li>可以读取 IPMI config，如果将账户和密码写在程序中不方便</li><li>可以读取峰值功耗，从而检测是否超过了 3kW</li><li>可以设置时间间隔和检测时间长度</li><li>UI 美观</li></ol><h1 id="Development-Step-1"><a href="#Development-Step-1" class="headerlink" title="Development Step 1"></a>Development Step 1</h1><p>首先我们选择框架和组件。框架上选择 PyQt6 作为顶层框架，之后开始设计布局：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dashboard</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.setWindowTitle(<span class="hljs-string">&quot;Dashboard&quot;</span>)<br>        self.setGeometry(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>, <span class="hljs-number">850</span>, <span class="hljs-number">500</span>)<br>...<br>        self.initUI()<br>        self.show()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1. define basic items</span><br><span class="hljs-string">2. set item</span><br><span class="hljs-string">3. set layout</span><br><span class="hljs-string">4. connect items</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>...<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_machine</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">load machine ipmi config</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_interval</span>(<span class="hljs-params">self, text</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">update interval</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_maxtime</span>(<span class="hljs-params">self, text</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">update maxtime</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_system</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">reset system</span><br><span class="hljs-string">Clear Plot</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_machine</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">reset_machine</span><br><span class="hljs-string">Reset machine information and status</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear_layout</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">update layout</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timer_start</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">timer start trigger</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_power</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">update power information and plot</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>设计框架完成之后开始设计链接逻辑</p><h2 id="按钮逻辑"><a href="#按钮逻辑" class="headerlink" title="按钮逻辑"></a>按钮逻辑</h2><p>Start/Reset 按钮:</p><ul><li>重置 Plot</li><li>读取数值</li><li>不重置机器配置文件</li><li>重置 timer</li></ul><p>Load 按钮：</p><ul><li>重置 Plot</li><li>重置机器配置文件</li><li>重置布局</li><li>重置 timer</li></ul><h2 id="CheckBox-逻辑"><a href="#CheckBox-逻辑" class="headerlink" title="CheckBox 逻辑"></a>CheckBox 逻辑</h2><p>勾选了新的机器之后需要停止 timer</p><h2 id="输入文本逻辑"><a href="#输入文本逻辑" class="headerlink" title="输入文本逻辑"></a>输入文本逻辑</h2><ul><li>重置 Plot</li><li>读取数值</li><li>不重置机器配置文件</li><li>重置 timer</li></ul><p>分别 connected 对应函数即可。</p><p>效果如下：</p><img src="image2.png" width="80%" height="80%"><h1 id="之后的计划"><a href="#之后的计划" class="headerlink" title="之后的计划"></a>之后的计划</h1><ul><li><input disabled="" type="checkbox"> 代码重构，添加注释</li><li><input disabled="" type="checkbox"> 多条曲线分别显示机器的功耗</li><li><input disabled="" type="checkbox"> 显示 GPU 和 CPU 的功耗</li><li><input disabled="" type="checkbox"> 曲线平滑、粗细调整</li><li><input disabled="" type="checkbox"> 添加图例</li><li><input disabled="" type="checkbox"> 坐标轴添加单位</li><li><input disabled="" type="checkbox"> x 轴更新为程序运行时间</li><li><input disabled="" type="checkbox"> 添加风扇控制页面</li><li><input disabled="" type="checkbox"> Label 的自体调整</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>Qt6 教程 <a href="https://maicss.gitbook.io/pyqt-chinese-tutoral/pyqt6/layout">https://maicss.gitbook.io/pyqt-chinese-tutoral/pyqt6/layout</a></li><li>qt-theme <a href="https://github.com/UN-GCPDS/qt-material">https://github.com/UN-GCPDS/qt-material</a></li><li>更新 layout 方法 <a href="https://stackoverflow.com/questions/7882749/how-to-update-a-qlayout-and-get-the-new-dimensions-before-returning">https://stackoverflow.com/questions/7882749/how-to-update-a-qlayout-and-get-the-new-dimensions-before-returning</a></li><li>qt 字体设置 <a href="https://stackoverflow.com/questions/1464591/how-to-create-a-bold-red-text-label-in-qt">https://stackoverflow.com/questions/1464591/how-to-create-a-bold-red-text-label-in-qt</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Develop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2205-omp2tbb开发笔记</title>
    <link href="/2022/07/01/2022/2205-omp2tbb%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/01/2022/2205-omp2tbb%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Version-0-0"><a href="#Version-0-0" class="headerlink" title="Version 0.0"></a>Version 0.0</h1><span id="more"></span><h2 id="omp2tbb"><a href="#omp2tbb" class="headerlink" title="omp2tbb"></a>omp2tbb</h2><p>2022-05-04 开发测试</p><h2 id="整理-OpenMP-5-2-导语"><a href="#整理-OpenMP-5-2-导语" class="headerlink" title="整理 OpenMP 5.2 导语"></a>整理 OpenMP 5.2 导语</h2><p>制作测试集合，用来测试各种导语的 LLVM-openmp 对应的导语。</p><p>首先位于上层的接口是：</p><p>LLVM OMP Stmt</p><table><thead><tr><th>LLVM OPENMPIR</th><th>OMP CLAUSE</th><th align="center">Care?(Y/N)</th></tr></thead><tbody><tr><td>OMPParallelDirective</td><td>pragma omp parallel</td><td align="center">Y</td></tr><tr><td>OMPSimdDirective</td><td>pragma omp simd</td><td align="center">Y</td></tr><tr><td>OMPForDirective</td><td>pragma omp for</td><td align="center">Y</td></tr><tr><td>OMPForSimdDirective</td><td>pragma omp for simd</td><td align="center"></td></tr><tr><td>OMPSectionsDirective</td><td>pragma omp sections</td><td align="center">Y</td></tr><tr><td>OMPSectionDirective</td><td>pragma omp section</td><td align="center">Y</td></tr><tr><td>OMPSingleDirective</td><td>pragma omp single</td><td align="center">Y</td></tr><tr><td>OMPMasterDirective</td><td>pragma omp master</td><td align="center">Y</td></tr><tr><td>OMPCriticalDirective</td><td>pragma omp critical</td><td align="center">Y</td></tr><tr><td>OMPParallelForDirective</td><td>pragma omp parallel for</td><td align="center"></td></tr><tr><td>OMPParallelForSimdDirective</td><td>pragma omp parallel for simd</td><td align="center"></td></tr><tr><td>OMPParallelMasterDirective</td><td>pragma omp parallel master</td><td align="center"></td></tr><tr><td>OMPParallelSectionsDirective</td><td>pragma omp parallel sections</td><td align="center"></td></tr><tr><td>OMPTaskDirective</td><td>pragma omp task</td><td align="center"></td></tr><tr><td>OMPTaskyieldDirective</td><td>pragma omp taskyield</td><td align="center"></td></tr><tr><td>OMPBarrierDirective</td><td>pragma omp barrier</td><td align="center"></td></tr><tr><td>OMPTaskwaitDirective</td><td>pragma omp taskwait</td><td align="center"></td></tr><tr><td>OMPTaskgroupDirective</td><td>pragma omp taskgroup</td><td align="center"></td></tr><tr><td>OMPFlushDirective</td><td>pragma omp flush</td><td align="center"></td></tr><tr><td>OMPDepobjDirective</td><td>pragma omp depobj</td><td align="center"></td></tr><tr><td>OMPOrderedDirective</td><td>pragma omp ordered</td><td align="center"></td></tr><tr><td>OMPAtomicDirective</td><td>pragma omp atomic</td><td align="center"></td></tr><tr><td>OMPTargetDirective</td><td>pragma omp target</td><td align="center"></td></tr><tr><td>OMPTargetDataDirective</td><td>pragma omp target data</td><td align="center"></td></tr><tr><td>OMPTargetEnterDataDirective</td><td>pragma omp target enter data</td><td align="center"></td></tr><tr><td>OMPTargetExitDataDirective</td><td>pragma omp target exit data</td><td align="center"></td></tr><tr><td>OMPTargetParallelDirective</td><td>pragma omp target parallel</td><td align="center"></td></tr><tr><td>OMPTargetParallelForDirective</td><td>pragma omp target parallel for</td><td align="center"></td></tr><tr><td>OMPTeamsDirective</td><td>pragma omp teams</td><td align="center"></td></tr><tr><td>OMPCancellationPointDirective</td><td>pragma omp cancellation point</td><td align="center"></td></tr><tr><td>OMPCancelDirective</td><td>pragma omp cancel</td><td align="center"></td></tr><tr><td>OMPTaskLoopDirective</td><td>pragma omp taskloop</td><td align="center"></td></tr><tr><td>OMPTaskLoopSimdDirective</td><td>pragma omp taskloop simd</td><td align="center"></td></tr><tr><td>OMPMasterTaskLoopDirective</td><td>pragma omp master taskloop</td><td align="center"></td></tr><tr><td>OMPMasterTaskLoopSimdDirective</td><td>pragma omp master taskloop simd</td><td align="center"></td></tr><tr><td>OMPParallelMasterTaskLoopDirective</td><td>pragma omp parallel master taskloop</td><td align="center"></td></tr><tr><td>OMPParallelMasterTaskLoopSimdDirective</td><td>pragma omp parallel master taskloop simd</td><td align="center"></td></tr><tr><td>OMPDistributeDirective</td><td>pragma omp distribute</td><td align="center"></td></tr><tr><td>OMPTargetUpdateDirective</td><td>pragma omp target update</td><td align="center"></td></tr><tr><td>OMPDistributeParallelForDirective</td><td>pragma omp distribute parallel for</td><td align="center"></td></tr><tr><td>OMPDistributeParallelForSimdDirective</td><td>pragma omp distribute parallel for simd</td><td align="center"></td></tr><tr><td>OMPDistributeSimdDirective</td><td>pragma omp distribute simd</td><td align="center"></td></tr><tr><td>OMPTargetParallelForSimdDirective</td><td>pragma omp target parallel for simd</td><td align="center"></td></tr><tr><td>OMPTargetSimdDirective</td><td>pragma omp target simd</td><td align="center"></td></tr><tr><td>OMPTeamsDistributeDirective</td><td>pragma omp teams distribute</td><td align="center"></td></tr><tr><td>OMPTeamsDistributeSimdDirective</td><td>pragma omp teams distribute simd</td><td align="center"></td></tr><tr><td>OMPTeamsDistributeParallelForSimdDirective</td><td>pragma omp teams distribute parallel for simd</td><td align="center"></td></tr><tr><td>OMPTeamsDistributeParallelForDirective</td><td>pragma omp teams distribute parallel for</td><td align="center"></td></tr><tr><td>OMPTargetTeamsDirective</td><td>pragma omp target teams</td><td align="center"></td></tr><tr><td>OMPTargetTeamsDistributeDirective</td><td>pragma omp target teams distribute</td><td align="center"></td></tr><tr><td>OMPTargetTeamsDistributeParallelForDirective</td><td>pragma omp target teams distribute parallel for</td><td align="center"></td></tr><tr><td>OMPTargetTeamsDistributeParallelForSimdDirective</td><td>pragma omp target teams distribute parallel for simd</td><td align="center"></td></tr><tr><td>OMPTargetTeamsDistributeSimdDirective</td><td>pragma omp target teams distribute simd</td><td align="center"></td></tr><tr><td>OMPTileDirective</td><td>pragma omp tile</td><td align="center"></td></tr><tr><td>OMPUnrollDirective</td><td>pragma omp unroll</td><td align="center"></td></tr><tr><td>OMPScanDirective</td><td>pragma omp scan</td><td align="center"></td></tr><tr><td>OMPInteropDirective</td><td>pragma omp interop</td><td align="center"></td></tr><tr><td>OMPDispatchDirective</td><td>pragma omp dispatch</td><td align="center"></td></tr><tr><td>OMPMaskedDirective</td><td>pragma omp masked</td><td align="center"></td></tr><tr><td>OMPMetaDirective</td><td>pragma omp metadirective</td><td align="center"></td></tr><tr><td>OMPGenericLoopDirective</td><td>pragma omp loop</td><td align="center"></td></tr><tr><td>OMPTeamsGenericLoopDirective</td><td>pragma omp teams loop</td><td align="center"></td></tr><tr><td>OMPTargetTeamsGenericLoopDirective</td><td>pragma omp target teams loop</td><td align="center"></td></tr><tr><td>OMPParallelGenericLoopDirective</td><td>pragma omp parallel loop</td><td align="center"></td></tr><tr><td>OMPTargetParallelGenericLoopDirective</td><td>pragma omp target parallel loop</td><td align="center"></td></tr></tbody></table><p>作为最上层的识别层，之后下一层的是：</p><p>LLVM Decl</p><table><thead><tr><th align="left">LLVM OpenMP Decl</th><th>openmp decl</th><th>Care?(Y/N)</th></tr></thead><tbody><tr><td align="left">OMPAllocatorClause</td><td>allocator</td><td></td></tr><tr><td align="left">OMPAlignClause</td><td>align</td><td></td></tr><tr><td align="left">OMPAllocateClause</td><td>allocate</td><td></td></tr><tr><td align="left">OMPIfClause</td><td>if</td><td></td></tr><tr><td align="left">OMPFinalClause</td><td>final</td><td></td></tr><tr><td align="left">OMPNumThreadsClause</td><td>num_threads</td><td></td></tr><tr><td align="left">OMPSafelenClause</td><td>safelen</td><td></td></tr><tr><td align="left">OMPSimdlenClause</td><td>simdlen</td><td></td></tr><tr><td align="left">OMPSizesClause</td><td>sizes</td><td></td></tr><tr><td align="left">OMPCollapseClause</td><td>collapse</td><td></td></tr><tr><td align="left">OMPDefaultClause</td><td>default</td><td></td></tr><tr><td align="left">OMPProcBindClause</td><td>proc_bind</td><td></td></tr><tr><td align="left">OMPUnifiedAddressClause</td><td>unified_address</td><td></td></tr><tr><td align="left">OMPUnifiedSharedMemoryClause</td><td>unified_shared_memory</td><td></td></tr><tr><td align="left">OMPReverseOffloadClause</td><td>reverse_offload</td><td></td></tr><tr><td align="left">OMPDynamicAllocatorsClause</td><td>dynamic_allocators</td><td></td></tr><tr><td align="left">OMPAtomicDefaultMemOrderClause</td><td>atomic_default_mem_order</td><td></td></tr><tr><td align="left">OMPScheduleClause</td><td>schedule</td><td></td></tr><tr><td align="left">OMPOrderedClause</td><td>ordered</td><td></td></tr><tr><td align="left">OMPNowaitClause</td><td>nowait</td><td></td></tr><tr><td align="left">OMPUntiedClause</td><td>untied</td><td></td></tr><tr><td align="left">OMPMergeableClause</td><td>mergeable</td><td></td></tr><tr><td align="left">OMPReadClause</td><td>read</td><td></td></tr><tr><td align="left">OMPWriteClause</td><td>write</td><td></td></tr><tr><td align="left">OMPUpdateClause</td><td>update</td><td></td></tr><tr><td align="left">OMPCaptureClause</td><td>capture</td><td></td></tr><tr><td align="left">OMPCompareClause</td><td>compare</td><td></td></tr><tr><td align="left">OMPSeqCstClause</td><td>seq_cst</td><td></td></tr><tr><td align="left">OMPAcqRelClause</td><td>acq_rel</td><td></td></tr><tr><td align="left">OMPAcquireClause</td><td>acquire</td><td></td></tr><tr><td align="left">OMPReleaseClause</td><td>release</td><td></td></tr><tr><td align="left">OMPRelaxedClause</td><td>relaxed</td><td></td></tr><tr><td align="left">OMPPrivateClause</td><td>private</td><td></td></tr><tr><td align="left">OMPFirstprivateClause</td><td>firstprivate</td><td></td></tr><tr><td align="left">OMPLastprivateClause</td><td>lastprivate</td><td></td></tr><tr><td align="left">OMPSharedClause</td><td>shared</td><td></td></tr><tr><td align="left">OMPReductionClause</td><td>reduction</td><td></td></tr><tr><td align="left">OMPTaskReductionClause</td><td>task_reduction</td><td></td></tr><tr><td align="left">OMPInReductionClause</td><td>in_reduction</td><td></td></tr><tr><td align="left">OMPLinearClause</td><td>linear</td><td></td></tr><tr><td align="left">OMPAlignedClause</td><td>aligned</td><td></td></tr><tr><td align="left">OMPCopyinClause</td><td>copyin</td><td></td></tr><tr><td align="left">OMPCopyprivateClause</td><td>copyprivate</td><td></td></tr><tr><td align="left">OMPFlushClause</td><td>flush</td><td></td></tr><tr><td align="left">OMPDepobjClause</td><td>depobj</td><td></td></tr><tr><td align="left">OMPDependClause</td><td>depend</td><td></td></tr><tr><td align="left">OMPDeviceClause</td><td>device</td><td></td></tr><tr><td align="left">OMPThreadsClause</td><td>threads</td><td></td></tr><tr><td align="left">OMPSIMDClause</td><td>simd</td><td></td></tr><tr><td align="left">OMPMapClause</td><td>map</td><td></td></tr><tr><td align="left">OMPNumTeamsClause</td><td>num_teams</td><td></td></tr><tr><td align="left">OMPThreadLimitClause</td><td>thread_limit</td><td></td></tr><tr><td align="left">OMPPriorityClause</td><td>priority</td><td></td></tr><tr><td align="left">OMPGrainsizeClause</td><td>grainsize</td><td></td></tr><tr><td align="left">OMPNogroupClause</td><td>nogroup</td><td></td></tr><tr><td align="left">OMPNumTasksClause</td><td>num_tasks</td><td></td></tr><tr><td align="left">OMPHintClause</td><td>hint</td><td></td></tr><tr><td align="left">OMPDistScheduleClause</td><td>dist_schedule</td><td></td></tr><tr><td align="left">OMPDefaultmapClause</td><td>defaultmap</td><td></td></tr><tr><td align="left">OMPToClause</td><td>to</td><td></td></tr><tr><td align="left">OMPFromClause</td><td>from</td><td></td></tr><tr><td align="left">OMPUseDevicePtrClause</td><td>use_device_ptr</td><td></td></tr><tr><td align="left">OMPUseDeviceAddrClause</td><td>use_device_addr</td><td></td></tr><tr><td align="left">OMPIsDevicePtrClause</td><td>is_device_ptr</td><td></td></tr><tr><td align="left">OMPHasDeviceAddrClause</td><td>has_device_ptr</td><td></td></tr><tr><td align="left">OMPNontemporalClause</td><td>nontemporal</td><td></td></tr><tr><td align="left">OMPOrderClause</td><td>order</td><td></td></tr><tr><td align="left">OMPInitClause</td><td>init</td><td></td></tr><tr><td align="left">OMPUseClause</td><td>use</td><td></td></tr><tr><td align="left">OMPDestroyClause</td><td>destroy</td><td></td></tr><tr><td align="left">OMPNovariantsClause</td><td>novariants</td><td></td></tr><tr><td align="left">OMPNocontextClause</td><td>nocontext</td><td></td></tr><tr><td align="left">OMPDetachClause</td><td>detach</td><td></td></tr><tr><td align="left">OMPInclusiveClause</td><td>inclusive</td><td></td></tr><tr><td align="left">OMPExclusiveClause</td><td>exclusive</td><td></td></tr><tr><td align="left">OMPUsesAllocatorsClause</td><td>uses_allocators</td><td></td></tr><tr><td align="left">OMPAffinityClause</td><td>affinity</td><td></td></tr><tr><td align="left">OMPFilterClause</td><td>filter</td><td></td></tr><tr><td align="left">OMPBindClause</td><td>bind</td><td></td></tr></tbody></table><p>属实有点多，目前位置我们的目标是：<br>对于 OpenMP 的代码块，我们识别出”最上层的逻辑块”，之后将其提取成为新的函数。<br>对于包含了 OpenMP 的函数块，我们也将其提取成”新函数”。</p><p>我们给新的函数命名，之后进行我们的代码翻译工作。<br>首先第一步工作是将并行代码串行化。</p><h1 id="Development-Step-1"><a href="#Development-Step-1" class="headerlink" title="Development Step 1"></a>Development Step 1</h1><ul><li><input checked="" disabled="" type="checkbox"> 构建可以识别 Stmt 的 Visitor</li><li><input checked="" disabled="" type="checkbox"> 构建可以识别 OpenMP Directive 的 Visitor ✅ 2022-05-05</li><li><input checked="" disabled="" type="checkbox"> 找出 OpenMP Directive 的范围，从而找出新的范围 ✅ 2022-05-05</li></ul><p>记录：<br>这里遇到一个非常大的坑点，使用 libclang 开发的工具需要加 – -fopenmp 才能启用编译选项</p><ul><li><input checked="" disabled="" type="checkbox"> 详细构建 Openmp 的树形结构</li></ul><h1 id="Development-Step-0"><a href="#Development-Step-0" class="headerlink" title="Development Step 0"></a>Development Step 0</h1><p>OpenMP Examples Build</p><p>顺着 openmp 官方的 example 文档构建 openmp 的并行例子。从而方便我们做之后的优化分析。</p><h2 id="例子构建"><a href="#例子构建" class="headerlink" title="例子构建"></a>例子构建</h2><ul><li><input checked="" disabled="" type="checkbox"> 测试时间工具部署 ✅ 2022-05-11</li><li><input checked="" disabled="" type="checkbox"> 阅读 Structured Programming Models</li></ul><p>分为两类:</p><ul><li>构建 bottom 类别<ul><li>从底层方案出发</li></ul></li><li>构建 top 类别<ul><li>从上层方案出发</li></ul></li></ul><p>目标：</p><ul><li>充分发挥 omp5.2 的特性</li><li>使用 omp task 、parallel、for 方便之后进行检测和转化</li><li>熟悉 intel tbb 的具体操作和语法</li></ul><p><strong>思路!!</strong><br>产生了新的想法：</p><ul><li>如果分析了数据访问的行为模式，分析一维/二维/三维的模式特征<ul><li>整数泛函</li><li>NLP 分析表达式特征</li></ul></li><li>为函数/openmp 代码快称重<ul><li>是否有必要 inline</li><li>是否有必要并行</li><li>NLP？</li><li>试一试，生成这个模式的 inline/noinline 代码</li></ul></li><li>针对多重循环</li><li>针对随机离散的应用<ul><li>ising model</li><li>2 维图片随机的处理</li><li>SPH</li><li>Conway 生命游戏</li></ul></li></ul><p>已经成功构建 bottom cases。位于</p><p><a href="https://github.com/Chivier/ompfuns">https://github.com/Chivier/ompfuns</a></p><h1 id="Develop-Step-1"><a href="#Develop-Step-1" class="headerlink" title="Develop Step 1"></a>Develop Step 1</h1><p>测试代码重写。找到一个合适的例子：<br>upc2c</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2205-Lammps-EFF GPU version 开发笔记1</title>
    <link href="/2022/05/16/2022/2205-Lammps-EFF-GPU-version-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/05/16/2022/2205-Lammps-EFF-GPU-version-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p>对于 LAMMPS 的 EFF 模块进行整理分析，目标是开发出 GPU 版本。</p><span id="more"></span><h1 id="0-背景调研"><a href="#0-背景调研" class="headerlink" title="0 背景调研"></a>0 背景调研</h1><h2 id="0-0-LAMMPS-项目结构和编译方法"><a href="#0-0-LAMMPS-项目结构和编译方法" class="headerlink" title="0.0 LAMMPS 项目结构和编译方法"></a>0.0 LAMMPS 项目结构和编译方法</h2><p>Lammps 官网提供了相关资料：<a href="#References">ref1</a></p><p>经过和李森师兄进行商讨分析，希望尽可能多利用近年来 Lammps 在 GPU 平台上的优化和其他项目工具的辅助。选择版本为：lammps-stable_29Sep2021_update3 <a href="#References">ref2</a></p><p>之后我们对如下的问题进行整理和分析：</p><ol><li>Lammps 的项目结构是怎样的，EFF 是什么</li><li>Lammps 的 GPU 版本如何编译，那些部分使用了 GPU 加速</li><li>Lammps 如何运行起来</li><li>如何使用 Cuda 对程序进行优化，其他的 Cuda 代码负责了什么功能</li><li>针对我们的算例，我们如何获取函数热点</li><li>能否摆脱 Lammps 框架，单独提取 EFF 部分使用 Cuda 进行编程操作</li></ol><h2 id="0-1-Lammps-编译"><a href="#0-1-Lammps-编译" class="headerlink" title="0.1 Lammps 编译"></a>0.1 Lammps 编译</h2><p>首先我们根据官方手册的方法进行一些编译和测试 <a href="#References">ref3</a></p><p>这里，官网提供了 Cmake 和 Make 两种编译方案，处于编译方法的简单性，我暂时选择了 CMake 进行编译和测试，效率较高，可以直接得到一个 GPU 版本的代码。不用认为指定对应的 cuda 环境变量。</p><p>EFF 是 LAMMPS 中的一个模块，主要是借助了 Lammps 的大规模计算框架的便利性，提升 Electron Force Field 的计算性能。<a href="#References">ref4</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ad-note">发现了 LAMMPS 中也使用了 VORONOI 算法，需要调研他的 VORONOI 和我的哪一个效率更高，进行对比测试。以及我提出的 VORONOI Entropy 可能在 LAMMPS 中作为一个平衡负载的重要指标。<br></code></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir build <br><span class="hljs-built_in">cd</span> build<br><br>cmake ../cmake -DGUP_API=cuda \  <br>-DGPU_PREC=mixed \  <br>-DGPU_ARCH=sm_80 \  <br>-DPKG_EFF=yes \  <br>-DCMAKE_BUILD_TYPE=Debug<br><br>make -j48<br></code></pre></td></tr></table></figure><h2 id="0-2-GPU-版本编译和运行"><a href="#0-2-GPU-版本编译和运行" class="headerlink" title="0.2 GPU 版本编译和运行"></a>0.2 GPU 版本编译和运行</h2><p>在李森师兄的指导下，成功的跑起了 LAMMPS 中的 example, 也成功的执行了张师兄给我的算例。</p><p>分析测试如下：</p><img src="image1.png" width="80%" height="80%">这里成功的启动了程序，也可以发现 mlx5_0 的卡槽，但是不能正常的使用 GPU。这里需要对程序进行更改。<img src="image2.png" width="80%" height="80%">这里无法成功启动 GPU。所以之后计算开始使用 CPU 和 mpi 进行。<img src="image3.png" width="80%" height="80%">此处可以正常进行计算，四列分别是：Step, Press, Temp, CPU<h2 id="0-3-GPU-问题处理-1"><a href="#0-3-GPU-问题处理-1" class="headerlink" title="0.3 GPU 问题处理 1"></a>0.3 GPU 问题处理 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">WARNING: There was an error initializing an OpenFabrics device.<br></code></pre></td></tr></table></figure><p>之前主要报错信息位于此处：</p><p>问题原因 mpich 不支持 GPU 的并行，无法查询设备。</p><h3 id="解决尝试-1"><a href="#解决尝试-1" class="headerlink" title="解决尝试 1"></a>解决尝试 1</h3><p>更换 openmpi 的 GPU 编译方案。手动编译 openmpi 的 GPU 版本，方案参考：<a href="#References">ref5</a></p><p>首先编译 gdrcopy <a href="#References">ref6</a></p><p>编译命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make prefix=<span class="hljs-variable">$HOME</span>/opt/gdrcopy/chver CUDA=/usr/<span class="hljs-built_in">local</span>/cuda all install<br>sudo ./insmod.sh<br></code></pre></td></tr></table></figure><p>补充，如果此处 prefix 指定为自己的路径之后可以不需要 sudo 权限</p><p>结果失败，在 sanity test 中报错为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sanity: error <span class="hljs-keyword">while</span> loading shared libraries: libgdrapi.so.2: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><p>更新 PATH LD_LIBRARY_PATH 之后恢复正常。</p><p>下一步编译 UCX</p><p>参考版本：<a href="https://github.com/openucx/ucx/releases/download/v1.12.1/ucx-1.12.1.tar.gz">UCX1.12</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ad-warning">请务必使用最新版本，否则 ucx 和 Ampere 架构的 GPU 会因为 Cuda11 的 hook 问题无法兼容，导致各种段错误发生。<br>手册中写的是 1.4 版本，但是 ucx 向下兼容，所以不会影响之后的工作。<br></code></pre></td></tr></table></figure><p>由于测试机器是单卡，暂时砍掉 gdrcopy 的测试。<br>推荐方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:openucx/ucx.git<br>git checkout v1.12.1-rc4<br>./autogen.sh<br>./contrib/configure-release --prefix=<span class="hljs-variable">$HOME</span>/opt/ucx/chver --with-cuda=/usr/<span class="hljs-built_in">local</span>/cuda<br>make -j8<br>make install<br></code></pre></td></tr></table></figure><p>之后相应的更新环境，开始编译 openmpi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --with-cuda=/usr/<span class="hljs-built_in">local</span>/cuda --with-ucx=/path/to/ucx-cuda-install<br>make -j48<br>make install<br></code></pre></td></tr></table></figure><p>现在返回测试，报错依然存在。</p><h3 id="解决尝试-2"><a href="#解决尝试-2" class="headerlink" title="解决尝试 2"></a>解决尝试 2</h3><p>分析问题还是在 openmpi 的 ib 驱动上，这里更换版本为 1.10 的 ucx。理由参考 Nvidia a100 进行 HPL 测试时使用的库版本:</p><p><a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/hpc-benchmarks">https://catalog.ngc.nvidia.com/orgs/nvidia/containers/hpc-benchmarks</a></p><p>首先自己编译 libcheck, 从 gdrcopy 重新开始：<a href="#References">ref7</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo PKG_CONFIG_PATH=<span class="hljs-variable">$HOME</span>/opt/check/chver/lib/pkgconfig/ make prefix=<span class="hljs-variable">$HOME</span>/opt/gdrcopy/chver CUDA=/usr/<span class="hljs-built_in">local</span>/cuda all install<br></code></pre></td></tr></table></figure><p>如果这里使用 sudo 之后可以解决，重新使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo PKG_CONFIG_PATH=<span class="hljs-variable">$HOME</span>/opt/check/chver/lib/pkgconfig/ make CUDA=/usr/<span class="hljs-built_in">local</span>/cuda all install<br></code></pre></td></tr></table></figure><p>之后在编译的时候 ld 可以找到 lgdrapi 了，非常顺利，这里巨大进步，进入 ucx 步骤，同上，无问题。</p><p>进入 openmpi 步骤，同上。<br>报错同上。</p><h3 id="解决尝试-3"><a href="#解决尝试-3" class="headerlink" title="解决尝试 3"></a>解决尝试 3</h3><p>使用 intel mpi, 其余步骤一样，解决。</p><img src="image4.png" width="80%" height="80%"><p>成功空占了 GPU</p><h2 id="0-4-GPU-问题处理-2"><a href="#0-4-GPU-问题处理-2" class="headerlink" title="0.4 GPU 问题处理 2"></a>0.4 GPU 问题处理 2</h2><p>在多次尝试的时候发现了第二套解决方案，mpi 不使用 intel 的版本，但是编译的时候使用 makefile 进行编译。</p><p><a href="#References">ref:github-lammps-gpu</a></p><p>此方案可行，测试无误，虽然会报和之前一样的报错，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">WARNING: There was an error initializing an OpenFabrics device.<br></code></pre></td></tr></table></figure><p>但是 GPU 确实可以成功启用。预计此方案在通信性能上会有一定的损失，但此损失可以接受。</p><h1 id="1-模块分析"><a href="#1-模块分析" class="headerlink" title="1 模块分析"></a>1 模块分析</h1><h2 id="1-1-EFF-代码逻辑测试工具准备"><a href="#1-1-EFF-代码逻辑测试工具准备" class="headerlink" title="1.1 EFF 代码逻辑测试工具准备"></a>1.1 EFF 代码逻辑测试工具准备</h2><ul><li><input checked="" disabled="" type="checkbox"> 使用 Sourcetrail 建立代码逻辑</li><li><input checked="" disabled="" type="checkbox"> 使用 gdb 进入调试</li></ul><h2 id="1-2-EFF-的模块初步分析"><a href="#1-2-EFF-的模块初步分析" class="headerlink" title="1.2 EFF 的模块初步分析"></a>1.2 EFF 的模块初步分析</h2><p>首先，Lammps 是一个组件模式的应用，所有的部件都是通过 Lammps 的 main 对读入文件进行分析进行处理的。我们处理的方法是通过 <a href="#References">ref: lammps-add-module</a> 使用 pair_style 调用构建类。</p><p>至此，开发前提出的 6 个问题都得到了回答：</p><ol><li>Lammps 的项目结构是怎样的，EFF 是什么<ol><li> 模块化，每一个独立模块内部构建类</li><li> EFF 是 Lammps 计算 Electron Force Field</li></ol></li><li>Lammps 的 GPU 版本如何编译，那些部分使用了 GPU 加速<ol><li> Lammp GPU 编译方法见 [[#0 3 GPU 问题处理 1]] , [[#0 2 GPU 版本编译和运行]]</li><li>GPU 主要为： short-range long-range three-bosy 三种势能计算提供加速。作用有限。<br> ![[Pasted image 20220516144211.png]]</li></ol></li><li>Lammps 如何运行起来<ol><li> mpirun + 对应参数实现 CPU 运行</li><li> mpirun -np 1 ../src/lmp_mpi -sf gpu -pk gpu 1 -in nvt.in 实现 GPU 运行</li></ol></li><li>如何使用 Cuda 对程序进行优化，其他的 Cuda 代码负责了什么功能<ol><li> 将原来的 C 代码替换成 Cuda 代码，链接统一处理</li><li> 参考 libgpu 的编译方法</li></ol></li><li>针对我们的算例，我们如何获取函数热点<ol><li> vtune 分析即可，因为 eff 不使用 GPU, 没有必要使用 gprof</li></ol></li><li>能否摆脱 Lammps 框架，单独提取 EFF 部分使用 Cuda 进行编程操作<ol><li> 不可以，目前为止的输入文件中需要借助 lammps 处理的部分还是占据大部分的，不方便进行处理。</li><li> EFF 部分的 GPU 优化目前为止并没有流行的版本，可以考虑以此写文章</li></ol></li></ol><h2 id="1-3-代码阅读"><a href="#1-3-代码阅读" class="headerlink" title="1.3 代码阅读"></a>1.3 代码阅读</h2><img src="image5.png" width="80%" height="80%"><p>根据框架首先找到模块入口。结合调用关系，设置断点：</p><img src="image6.png" width="80%" height="80%"><p>为 PairEffCut 设置即可。</p><p>可以进入断点进行测试。</p><p>下一步目标：</p><ol><li>测试 EFF 模块的热点（进行中）</li><li>替换 EFF 的部分代码，测试插入 cuda 代码</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>1 <a href="https://www.lammps.org/">https://www.lammps.org/</a></li><li>2 <a href="https://codeload.github.com/lammps/lammps/tar.gz/refs/tags/stable_29Sep2021_update3">https://codeload.github.com/lammps/lammps/tar.gz/refs/tags/stable_29Sep2021_update3</a></li><li>3 <a href="https://docs.lammps.org/Manual.html">https://docs.lammps.org/Manual.html</a></li><li>4  <a href="https://www.lammps.org/movies.html#eff">https://www.lammps.org/movies.html#eff</a></li><li>5  <a href="https://www.open-mpi.org/faq/?category=buildcuda">https://www.open-mpi.org/faq/?category=buildcuda</a></li><li>6  <a href="https://github.com/NVIDIA/gdrcopy">https://github.com/NVIDIA/gdrcopy</a></li><li>7  <a href="https://github.com/libcheck/check#installing">https://github.com/libcheck/check#installing</a></li><li>github-lammps-gpu <a href="https://github.com/Roy-Kid/lammpscn/issues/8">https://github.com/Roy-Kid/lammpscn/issues/8</a></li><li>lammps-add-module <a href="https://docs.lammps.org/Modify_overview.html">https://docs.lammps.org/Modify_overview.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cuda</tag>
      
      <tag>Applications</tag>
      
      <tag>Lammps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2205-MPI and timer</title>
    <link href="/2022/05/13/2022/2205-MPI-and-timer/"/>
    <url>/2022/05/13/2022/2205-MPI-and-timer/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-和-OpenMP-工作模式"><a href="#MPI-和-OpenMP-工作模式" class="headerlink" title="MPI 和 OpenMP 工作模式"></a>MPI 和 OpenMP 工作模式</h1><span id="more"></span><p>OpenMP对于共享内存处理更优，但是没有通信的功能，所以MPI可以弥补这一缺点。</p><h1 id="MPI快速上手"><a href="#MPI快速上手" class="headerlink" title="MPI快速上手"></a>MPI快速上手</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>关于进程和线程的说明我觉得英语的描述更为合适，可以非常清楚的说明这两个概念。</p><ol><li>进程：A process is (traditionally) a program counter and address space.</li><li>线程：Processes may have multiple threads (program counters and associated stacks) sharing a single address space. MPI is for communication among processes, which have separate address spaces.</li><li>进程处理需要进行：</li><li>同步</li><li>数据通信</li></ol><h2 id="OpenMPI-和-MPICH"><a href="#OpenMPI-和-MPICH" class="headerlink" title="OpenMPI 和 MPICH"></a>OpenMPI 和 MPICH</h2><p><strong>You can read following part later</strong><br>首先需要认识到这两者不是一个东西，在接口实现上有细微差异。MPICH应该是最新MPI标准的高质量参考实施，以及衍生实施以满足特殊用途需求的基础。OpenMPI在使用和网络通信方面实现更加普通。大部分时候两者都可以使用，但是如果是在有<strong>IB通信的机器上，MPICH不可用</strong>。</p><p>一般使用时，最大的差异是使用 <strong>Hydra</strong> 的时候会有差异。</p><p>OpenMPI的 Hostfile 格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># This is an example hostfile.  Comments begin with #</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The following node is a single processor machine:</span><br>foo.example.com<br> <br><span class="hljs-comment"># The following node is a dual-processor machine:</span><br>bar.example.com slots=2<br> <br><span class="hljs-comment"># The following node is a quad-processor machine, and we absolutely</span><br><span class="hljs-comment"># want to disallow over-subscribing it:</span><br>yow.example.com slots=4 max-slots=4<br></code></pre></td></tr></table></figure><p>MPICH的 Hostfile 格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">donner</span>:<span class="hljs-number">2</span>     # The first <span class="hljs-number">2</span> procs are scheduled to run here<br><span class="hljs-attribute">foo</span>:<span class="hljs-number">3</span>        # The next <span class="hljs-number">3</span> procs run <span class="hljs-literal">on</span> this host<br><span class="hljs-attribute">shakey</span>:<span class="hljs-number">2</span>     # The last <span class="hljs-number">2</span> procs run <span class="hljs-literal">on</span> this host<br></code></pre></td></tr></table></figure><p>更细节的参考：<br><a href="https://wiki.mpich.org/mpich/index.php/Using_the_Hydra_Process_Manager">MPICH Hydra</a><br><a href="https://www.open-mpi.org/faq/?category=running#mpirun-hostfile">OpenMPI FAQ</a></p><p>学习的时候个人推荐MPICH进行学习和研究。</p><h2 id="安装-MPICH"><a href="#安装-MPICH" class="headerlink" title="安装 MPICH"></a>安装 MPICH</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://www.mpich.org/static/downloads/3.4.2/mpich-3.4.2.tar.gz<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>不做赘述</p><h2 id="3对基本函数"><a href="#3对基本函数" class="headerlink" title="3对基本函数"></a>3对基本函数</h2><h3 id="MPI-Hello-World"><a href="#MPI-Hello-World" class="headerlink" title="MPI Hello World"></a>MPI Hello World</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// Initialize the MPI environment</span><br>    MPI_Init(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Get the number of processes</span><br>    <span class="hljs-keyword">int</span> world_size;<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size);<br><br>    <span class="hljs-comment">// Get the rank of the process</span><br>    <span class="hljs-keyword">int</span> world_rank;<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank);<br><br>    <span class="hljs-comment">// Get the name of the processor</span><br>    <span class="hljs-keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];<br>    <span class="hljs-keyword">int</span> name_len;    <br>    MPI_Get_processor_name(processor_name, &amp;name_len);<br><br>    <span class="hljs-comment">// Print off a hello world message</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world from processor %s, rank %d out of %d processors\n&quot;</span>,<br>           processor_name, world_rank, world_size);<br><br>    <span class="hljs-comment">// Finalize the MPI environment.</span><br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><p>编译方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mpicxx hello.cpp -o hello<br></code></pre></td></tr></table></figure><h3 id="MPI-Init-amp-MPI-Finalize"><a href="#MPI-Init-amp-MPI-Finalize" class="headerlink" title="MPI_Init &amp; MPI_Finalize"></a>MPI_Init &amp; MPI_Finalize</h3><ul><li>MPI_Init用于启动</li><li>MPI_Finalize用于结束</li></ul><h3 id="MPI-Comm-rank-amp-MPI-Comm-size"><a href="#MPI-Comm-rank-amp-MPI-Comm-size" class="headerlink" title="MPI_Comm_rank &amp; MPI_Comm_size"></a>MPI_Comm_rank &amp; MPI_Comm_size</h3><ul><li>MPI_Comm_rank 用于计算当前的rank</li><li>MPI_Comm_size 用于当前通信器里面的总进程数</li></ul><h3 id="MPI-Send-amp-MPI-Recv"><a href="#MPI-Send-amp-MPI-Recv" class="headerlink" title="MPI_Send &amp; MPI_Recv"></a>MPI_Send &amp; MPI_Recv</h3><ul><li>MPI_Send 用于发送数据</li><li>MPI_Recv 用于接收数据</li></ul><p>接口格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Send(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype,<br>          <span class="hljs-keyword">int</span> dest, <span class="hljs-keyword">int</span> tag, MPI_Comm comm)<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Recv(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype,<br>         <span class="hljs-keyword">int</span> source, <span class="hljs-keyword">int</span> tag, MPI_Comm comm, MPI_Status *status)<br></code></pre></td></tr></table></figure><p>对于一个最简单的收发例子如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> rank, data[<span class="hljs-number">100</span>];<br><br>    MPI_Init(&amp;argc, &amp;argv);<br><br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br><br>    <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>)<br>        MPI_Send(data, <span class="hljs-number">100</span>, MPI_INT, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">1</span>)<br>        MPI_Recv(data, <span class="hljs-number">100</span>, MPI_INT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD,  MPI_STATUS_IGNORE);<br><br>    MPI_Finalize();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们指定了固定的数据收发模式，[RANK0]发送[RANK1]接收。更详细的说明在之后进行介绍，这里只作为入门例子。</p><h2 id="MPI-通信数据类型"><a href="#MPI-通信数据类型" class="headerlink" title="MPI 通信数据类型"></a>MPI 通信数据类型</h2><h3 id="一般数据类型"><a href="#一般数据类型" class="headerlink" title="一般数据类型"></a>一般数据类型</h3><p>(Tip: 下表是用来查的，不是用来背的)</p><table><thead><tr><th>MPI datatype</th><th>C datatype</th></tr></thead><tbody><tr><td>MPL_CHAR</td><td>char (treated as printable character)</td></tr><tr><td>MPI_SHORT</td><td>signed short int</td></tr><tr><td>MPL_INT</td><td>signed int</td></tr><tr><td>MPI_LONG</td><td>signed long int</td></tr><tr><td>MPI_LONG_LONG_INT</td><td>signed long long int</td></tr><tr><td>MPI_LONG_LONG (as a synonym)</td><td>signed long long int</td></tr><tr><td>MPI_SIGNED_CHAR</td><td>signed char (treated as integral value)</td></tr><tr><td>MPI_UNSIGNED_CHAR</td><td>unsigned char (treated as integral value)</td></tr><tr><td>MPI_UNSIGNED_SHORT</td><td>unsigned short int</td></tr><tr><td>MPI_UNSIGNED</td><td>unsigned int</td></tr><tr><td>MPI_UNSIGNED_LONG</td><td>unsigned long int</td></tr><tr><td>MPI_UNSIGNED_LONG_LONG</td><td>unsigned long long int</td></tr><tr><td>MPI_FLOAT</td><td>float</td></tr><tr><td>MPI_DOUBLE</td><td>double</td></tr><tr><td>MPI_LONG_DOUBLE</td><td>long double</td></tr><tr><td>MPL_WCHAR</td><td>wchar_t (defined in &lt;stddef.h&gt;) (treated as printable character)</td></tr><tr><td>MPI_C_BOOL</td><td>Bool</td></tr><tr><td>MPI_INT_T</td><td>int8_t</td></tr><tr><td>MPI_INT16_T</td><td>int16_t</td></tr><tr><td>MPI_INT32_T</td><td>int32_t</td></tr><tr><td>MPI_INT64_T</td><td>int64_t</td></tr><tr><td>MPI UINT8_T</td><td>uint8_t</td></tr><tr><td>MPI_UINT16_T</td><td>uint16_t</td></tr><tr><td>MPL_UINT32 T</td><td>uint32_t</td></tr><tr><td>MPI_UINT64_T</td><td>uint64_t</td></tr><tr><td>MPL_C_COMPLEX</td><td>float_Complex</td></tr><tr><td>MPI_C_FLOAT_COMPLEX (as a synonym)</td><td>float Complex</td></tr><tr><td>MPI_C_DOUBLE_COMPLEX</td><td>double_Complex</td></tr><tr><td>MPI_BYTE</td><td></td></tr><tr><td>MPL_PACKED</td><td></td></tr></tbody></table><p>对于 C++ 有一些拓展:</p><table><thead><tr><th>MPl datatype</th><th>C++ datatype</th></tr></thead><tbody><tr><td>MPI_CXX_BOOL</td><td>bool</td></tr><tr><td>MPI_CXX_FLOAT_COMPLEX</td><td>std::complex&lt;float&gt;</td></tr><tr><td>MPI_CXX_DOUBLE_COMPLEX</td><td>std::complex&lt;double&gt;</td></tr><tr><td>MPI_CXX_LONG_DOUBLE_COMPLEX</td><td>std::complex&lt;long double&gt;</td></tr></tbody></table><p>其中的 MPI_PACKED 和 MPI_BYTE 作为拓展消息类型。就是对数据进行压包后进行发送。</p><h3 id="MPI-PACKED-数据类型"><a href="#MPI-PACKED-数据类型" class="headerlink" title="MPI_PACKED 数据类型"></a>MPI_PACKED 数据类型</h3><p>MPI_PACKED数据类型是一个特殊封装的数据类型，一般用来实现传输地址空间不连续的数据项。</p><p>接口格式为： (由于接口文档上，OpenMPI做的更好，后面可能会参考OpenMPI的文档)</p><p><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Pack.3.php#toc2">MPI_Pack</a><br><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Unpack.3.php">MPI_Unpack</a><br><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Pack_size.3.php">MPI_Pack_size</a></p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    MPI_Init(&amp;argc, &amp;argv);<br>    <span class="hljs-keyword">int</span> position;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-keyword">int</span> myrank;<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);<br><br>    <span class="hljs-keyword">if</span> (myrank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* I am sending */</span><br>        position = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> true_packed_size;<br>        MPI_Pack_size(<span class="hljs-number">2</span>, MPI_INT, MPI_COMM_WORLD, &amp;true_packed_size);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;True packed size = &quot;</span> &lt;&lt; true_packed_size &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">char</span> *buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[true_packed_size];<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Packing number i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, pos = &quot;</span> &lt;&lt; position &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        MPI_Pack(&amp;i, <span class="hljs-number">1</span>, MPI_INT, buffer, <span class="hljs-number">1000</span>, &amp;position, MPI_COMM_WORLD);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Packing number j = &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;, pos = &quot;</span> &lt;&lt; position &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        MPI_Pack(&amp;j, <span class="hljs-number">1</span>, MPI_INT, buffer, <span class="hljs-number">1000</span>, &amp;position, MPI_COMM_WORLD);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Packing finished, pos = &quot;</span> &lt;&lt; position &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        MPI_Send(buffer, position, MPI_PACKED, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>        <span class="hljs-keyword">delete</span>[] buffer;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        MPI_Recv(a, <span class="hljs-number">2</span>, MPI_INT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MPI-点对点通信"><a href="#MPI-点对点通信" class="headerlink" title="MPI 点对点通信"></a>MPI 点对点通信</h2><h3 id="阻塞通信和非阻塞通信"><a href="#阻塞通信和非阻塞通信" class="headerlink" title="阻塞通信和非阻塞通信"></a>阻塞通信和非阻塞通信</h3><p>阻塞通信主要特征是：<br>如果假设进程A发送，进程B接收。在这一对收发任务完成之前，进程A会一致在发送接口处停住，而B会在接收接口处停住。</p><p>发送类别主要有以下四类：</p><ol><li>标准模式 MPI_Send/MPI_Isend： 自由发送接收，不考虑其它进程状态</li><li>缓存模式 MPI_Bsend/MPI_Ibsend： 由用户显式提供缓存区，辅助通信</li><li>同步模式 MPI_Ssend/MPI_Issend： 通信双方先建立联系，再通信</li><li>就绪模式 MPI_Rsend/MPI_Irsend： 接受进程必须先于发送进程提出通信要求</li></ol><p>一般使用的时候主要使用标准模式即可。</p><table><thead><tr><th>MPI 原语</th><th>阻塞</th><th>非阻塞</th></tr></thead><tbody><tr><td>Standard Send</td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Send.3.php">MPI_Send</a></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Isend.3.php">MPI_Isend</a></td></tr><tr><td>Buffered Send</td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Bsend.3.php">MPI_Bsend</a></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Ibsend.3.php">MPI_Ibsend</a></td></tr><tr><td>Synchronous Send</td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Ssend.3.php">MPI_Ssend</a></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Issend.3.php">MPI_Issend</a></td></tr><tr><td>Ready Send</td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Rsend.3.php">MPI_Rsend</a></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Irsend.3.php">MPI_Irsend</a></td></tr><tr><td>Receive</td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Recv.3.php">MPI_Recv</a></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Irecv.3.php">MPI_Irecv</a></td></tr><tr><td>Completion Check</td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Wait.3.php">MPI_Wait</a></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Test.3.php">MPI_Test</a></td></tr></tbody></table><h3 id="流水-管线通信"><a href="#流水-管线通信" class="headerlink" title="流水/管线通信"></a>流水/管线通信</h3><p>模式例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌───────┐   ┌───────┐   ┌───────┐<br>│       │   │       │   │       │<br>│   x   ├──&gt;│   y   ├──&gt;│   z   │<br>│       │   │       │   │       │<br>└───────┘   └───────┘   └───────┘<br></code></pre></td></tr></table></figure><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function_p</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> w + w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function_q</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">function_r</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> y - <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    MPI_Init(&amp;argc, &amp;argv);<br><br>    <span class="hljs-keyword">int</span> world_size, my_rank;<br><br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);<br><br>    <span class="hljs-keyword">if</span> (my_rank == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> ans[<span class="hljs-number">10</span>];<br>        MPI_Request req[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span>; ++index) &#123;<br>            <span class="hljs-keyword">int</span> number = index;<br>            MPI_Isend(&amp;number, <span class="hljs-number">1</span>, MPI_INT, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, &amp;req[index]);<br>            ans[index] = function_p(number);<br>            ans[index] = function_q(ans[index]);<br>            ans[index] = function_r(ans[index]);<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;should be: &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span>; ++index) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; ans[index] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (my_rank == <span class="hljs-number">1</span>) &#123;<br>        MPI_Request req;<br>        <span class="hljs-keyword">int</span> number;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            MPI_Irecv(&amp;number, <span class="hljs-number">1</span>, MPI_INT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, &amp;req);<br>            MPI_Wait(&amp;req, MPI_STATUS_IGNORE);<br>            number = function_p(number);<br>            MPI_Isend(&amp;number, <span class="hljs-number">1</span>, MPI_INT, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, &amp;req);<br>            cnt++;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">10</span>) &#123;<span class="hljs-keyword">break</span>; &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (my_rank == <span class="hljs-number">2</span>) &#123;<br>        MPI_Request req;<br>        <span class="hljs-keyword">int</span> number;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            MPI_Irecv(&amp;number, <span class="hljs-number">1</span>, MPI_INT, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, &amp;req);<br>            MPI_Wait(&amp;req, MPI_STATUS_IGNORE);<br>            number = function_q(number);<br>            MPI_Isend(&amp;number, <span class="hljs-number">1</span>, MPI_INT, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, &amp;req);<br>            cnt++;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">10</span>) &#123;<span class="hljs-keyword">break</span>; &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (my_rank == <span class="hljs-number">3</span>) &#123;<br>        MPI_Request req;<br>        <span class="hljs-keyword">int</span> number[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            MPI_Irecv(&amp;number[cnt], <span class="hljs-number">1</span>, MPI_INT, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, &amp;req);<br>            MPI_Wait(&amp;req, MPI_STATUS_IGNORE);<br>            number[cnt] = function_r(number[cnt]);<br>            cnt++;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">10</span>) &#123;<span class="hljs-keyword">break</span>; &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span>; index++)<br>            <span class="hljs-built_in">cout</span> &lt;&lt; number[index] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    MPI_Finalize();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>模式例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌─────────┐   ┌─────────────┐   ┌─────────┐<br>│ x buf 0 ├──&gt;│             ├──&gt;│ y buf 0 │<br>└─────────┘   │             │   └─────────┘<br>              │   Y = F(X)  │<br>┌─────────┐   │             │   ┌─────────┐<br>│ x buf 1 ├──&gt;│             ├──&gt;│ y buf 1 │<br>└─────────┘   └─────────────┘   └─────────┘<br></code></pre></td></tr></table></figure><p>针对计算复杂度比较高的情况，第一轮次使用xbuf0和ybuf0，第二轮次使用xbuf1和ybuf1，两组缓冲轮流使用。</p><h3 id="对位置消息探查"><a href="#对位置消息探查" class="headerlink" title="对位置消息探查"></a>对位置消息探查</h3><p>主要函数有：</p><ul><li><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Probe.3.php">MPI_Probe</a></li><li><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Iprobe.3.php">MPI_Iprobe</a></li></ul><p>MPI_Probe 的接口和 MPI_Recv 近似，他是不接受数据的 Recv<br>下面这个例子辅助理解(From <a href="https://mpitutorial.com/tutorials/dynamic-receiving-with-mpi-probe-and-mpi-status/zh_cn/">MPI-Tutorial</a>)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> number_amount;<br><span class="hljs-keyword">if</span> (world_rank == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_NUMBERS = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">int</span> numbers[MAX_NUMBERS];<br>    <span class="hljs-comment">// Pick a random amount of integers to send to process one</span><br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    number_amount = (rand() / (<span class="hljs-keyword">float</span>)RAND_MAX) * MAX_NUMBERS;<br><br>    <span class="hljs-comment">// Send the random amount of integers to process one</span><br>    MPI_Send(numbers, number_amount, MPI_INT, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 sent %d numbers to 1\n&quot;</span>, number_amount);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (world_rank == <span class="hljs-number">1</span>) &#123;<br>    MPI_Status status;<br>    <span class="hljs-comment">// Probe for an incoming message from process zero</span><br>    MPI_Probe(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD, &amp;status);<br><br>    <span class="hljs-comment">// When probe returns, the status object has the size and other</span><br>    <span class="hljs-comment">// attributes of the incoming message. Get the message size</span><br>    MPI_Get_count(&amp;status, MPI_INT, &amp;number_amount);<br><br>    <span class="hljs-comment">// Allocate a buffer to hold the incoming numbers</span><br>    <span class="hljs-keyword">int</span>* number_buf = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * number_amount);<br><br>    <span class="hljs-comment">// Now receive the message with the allocated buffer</span><br>    MPI_Recv(number_buf, number_amount, MPI_INT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>             MPI_COMM_WORLD, MPI_STATUS_IGNORE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 dynamically received %d numbers from 0.\n&quot;</span>,<br>           number_amount);<br>    <span class="hljs-built_in">free</span>(number_buf);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MPI-通信域"><a href="#MPI-通信域" class="headerlink" title="MPI 通信域"></a>MPI 通信域</h2><h2 id="MPI-集群通信"><a href="#MPI-集群通信" class="headerlink" title="MPI 集群通信"></a>MPI 集群通信</h2><table><thead><tr><th>类型</th><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>通信</td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Bcast.3.php">MPI_Bcast</a></td><td>一对多广播同样的消息</td></tr><tr><td></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Gather.3.php">MPI_Gather</a></td><td>多对一收集各个进程的消息</td></tr><tr><td></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Gatherv.3.php">MPI_Gatherv</a></td><td>MPI_Gather的一般化</td></tr><tr><td></td><td><a href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Allgather.3.php">MPI_Allgather</a></td><td>全局收集</td></tr><tr><td></td><td>MPI_Allgatherv</td><td>MPI_Allgather的一般化</td></tr><tr><td></td><td>MPI_Scatter</td><td>一对多散播不同的消息</td></tr><tr><td></td><td>MPI_Scatterv</td><td>MPI_Scatter的一般化</td></tr><tr><td></td><td>MPI_Alltoall</td><td>多对多全局交换消息</td></tr><tr><td></td><td>MPI_Alltoallv</td><td>MPI_Alltoall的一般化</td></tr><tr><td>聚集</td><td>MPI_Reduce</td><td>多对一归约</td></tr><tr><td></td><td>MPI_Allreduce</td><td>MPI_Reduce的一般化</td></tr><tr><td></td><td>MPI_Reduce_scatter</td><td>MPI_Reduce的一般化</td></tr><tr><td></td><td>MPI_Scan</td><td>扫描</td></tr><tr><td>同步</td><td>MPI_Barrier</td><td>路障同步</td></tr></tbody></table><h1 id="OpenMP快速上手"><a href="#OpenMP快速上手" class="headerlink" title="OpenMP快速上手"></a>OpenMP快速上手</h1><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="实例之前"><a href="#实例之前" class="headerlink" title="实例之前"></a>实例之前</h2><p>为了说明各种实例的效果和性能，这里先补充一下关于<strong>计时</strong>的方法。</p><h3 id="方法1：time"><a href="#方法1：time" class="headerlink" title="方法1：time"></a>方法1：time</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">time_t</span> tm_now;<br><br>    time(&amp;tm_now);<br><br>    <span class="hljs-comment">// 1970-1-1,00:00:00到现在的秒数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now time is %ld second\n&quot;</span>, tm_now);<br><br>    <span class="hljs-comment">// 转换成本地时间，精确到秒</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">p_local_tm</span> ;</span><br>    p_local_tm = localtime(&amp;tm_now) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now datetime: %04d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,<br>        p_local_tm-&gt;tm_year+<span class="hljs-number">1900</span>, <br>        p_local_tm-&gt;tm_mon+<span class="hljs-number">1</span>, <br>        p_local_tm-&gt;tm_mday, <br>        p_local_tm-&gt;tm_hour, <br>        p_local_tm-&gt;tm_min, <br>        p_local_tm-&gt;tm_sec);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法2：gettimeofday"><a href="#方法2：gettimeofday" class="headerlink" title="方法2：gettimeofday"></a>方法2：gettimeofday</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tm_now</span>;</span><br><br>    <span class="hljs-comment">// 获取当前时间戳(tv_sec, tv_usec)</span><br>    gettimeofday(&amp;tm_now,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 第二个参数是时区</span><br><br>    <span class="hljs-comment">// 转换成本地时间，精确到秒</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">p_local_tm</span>;</span><br>    p_local_tm = localtime(&amp;tm_now.tv_sec) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now datetime: %04d-%02d-%02d %02d:%02d:%02d.%06ld\n&quot;</span>,<br>        p_local_tm-&gt;tm_year+<span class="hljs-number">1900</span>, <br>        p_local_tm-&gt;tm_mon+<span class="hljs-number">1</span>, <br>        p_local_tm-&gt;tm_mday, <br>        p_local_tm-&gt;tm_hour, <br>        p_local_tm-&gt;tm_min, <br>        p_local_tm-&gt;tm_sec,<br>        tm_now.tv_usec); <span class="hljs-comment">// 有微秒时间戳了</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法3：clock-gettime"><a href="#方法3：clock-gettime" class="headerlink" title="方法3：clock_gettime"></a>方法3：clock_gettime</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_timestamp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> use_monotonic)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">tm_now</span>;</span><br><br>    <span class="hljs-comment">// 获取当前时间戳(tv_sec, tv_usec)</span><br>    <span class="hljs-keyword">if</span>(use_monotonic)<br>        clock_gettime(CLOCK_MONOTONIC, &amp;tm_now);<br>        <span class="hljs-comment">// 单调时间，屏蔽手动修改时间</span><br>    <span class="hljs-keyword">else</span><br>        clock_gettime(CLOCK_REALTIME, &amp;tm_now);<br>        <span class="hljs-comment">// 机器时间</span><br><br>    <span class="hljs-comment">// 转换成本地时间，精确到秒</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">p_local_tm</span>;</span><br>    p_local_tm = localtime(&amp;tm_now.tv_sec) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now datetime: %04d-%02d-%02d %02d:%02d:%02d.%09ld\n&quot;</span>,<br>        p_local_tm-&gt;tm_year+<span class="hljs-number">1900</span>, <br>        p_local_tm-&gt;tm_mon+<span class="hljs-number">1</span>, <br>        p_local_tm-&gt;tm_mday, <br>        p_local_tm-&gt;tm_hour, <br>        p_local_tm-&gt;tm_min, <br>        p_local_tm-&gt;tm_sec,<br>        tm_now.tv_nsec);<br>        <span class="hljs-comment">// 纳秒时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法4：chrono库"><a href="#方法4：chrono库" class="headerlink" title="方法4：chrono库"></a>方法4：chrono库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">auto</span> start = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br><br>...<br><br><span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">std</span>::chrono::system_clock::now();<br><span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">double</span>&gt; elapsed_seconds = end - start;<br>time1 = elapsed_seconds.count();<br></code></pre></td></tr></table></figure><h3 id="方法5：rdtsc"><a href="#方法5：rdtsc" class="headerlink" title="方法5：rdtsc"></a>方法5：rdtsc</h3><p>最精准也是最难用的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">get_tsc</span><span class="hljs-params">()</span> <span class="hljs-comment">// Time Stamp Counter寄存器</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint64_t</span> x;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;rdtsc&quot;</span> : <span class="hljs-string">&quot;=A&quot;</span>(x))</span></span>;<br>    <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">uint64_t</span> a, d;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;rdtsc&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(a), <span class="hljs-string">&quot;=d&quot;</span>(d))</span></span>;<br>    <span class="hljs-keyword">return</span> (d &lt;&lt; <span class="hljs-number">32</span>) | a;<br>    <span class="hljs-keyword">uint32_t</span> cc = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;mrc p15, 0, %0, c9, c13, 0&quot;</span>:<span class="hljs-string">&quot;=r&quot;</span> (cc))</span></span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint64_t</span>)cc; <br>&#125;<br></code></pre></td></tr></table></figure><p>使用限制：</p><ol><li><p>机器需要有constant_tsc的特性，使用：<code>cat /proc/cpu_info | grep constant_tsc</code>命令可以确定是否有该特性</p></li><li><p>乱序执行核能会打乱时钟周期的测量，必要时需要制造“依赖指令”去避免乱序执行</p></li><li><p>必要时需要使用<code>memory barrier</code></p></li><li><p><code>cat /proc/cpuinfo | grep rdtscp</code> 如果开启，可以使用rdtscp，更精准一点。使用方法基本一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">get_tscp</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">uint64_t</span> a, d; <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;rdtscp&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(a), <span class="hljs-string">&quot;=d&quot;</span>(d))</span></span>; <span class="hljs-keyword">return</span> (d &lt;&lt; <span class="hljs-number">32</span>) | a; &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果使用C++，那么使用<code>chrono</code>库是最好的选择，相信STL不会翻大车<br>如果机器由<code>constant tsc</code>特性，那么可以使用rdtsc方法<br>如果没有，那么使用<code>gettimeofday</code>时一个比较稳定的方法</p><h2 id="实例1：不适用并行的例子"><a href="#实例1：不适用并行的例子" class="headerlink" title="实例1：不适用并行的例子"></a>实例1：不适用并行的例子</h2><p>刻意并行化，或者过低的并行层级往往会带来巨大的负优化。这里用一个求和的例子说明。<br>采用如下方式对一个数组求和。</p><h3 id="MPI实现方案"><a href="#MPI实现方案" class="headerlink" title="MPI实现方案"></a>MPI实现方案</h3>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Parallel</tag>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2204-qinitial</title>
    <link href="/2022/04/26/2022/2204-qinitial/"/>
    <url>/2022/04/26/2022/2204-qinitial/</url>
    
    <content type="html"><![CDATA[<p>安装小工具，gkd</p><span id="more"></span><p><a href="https://github.com/Chivier/qinitial">https://github.com/Chivier/qinitial</a></p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><ul><li><input checked="" disabled="" type="checkbox"> gcc</li><li><input checked="" disabled="" type="checkbox"> llvm</li><li><input checked="" disabled="" type="checkbox"> intel compilers</li><li><input checked="" disabled="" type="checkbox"> mpich</li><li><input checked="" disabled="" type="checkbox"> rust</li><li><input checked="" disabled="" type="checkbox"> python</li><li><input checked="" disabled="" type="checkbox"> pyenv</li><li><input checked="" disabled="" type="checkbox"> cmake</li></ul><h1 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h1><ul><li><input checked="" disabled="" type="checkbox"> git</li><li><input checked="" disabled="" type="checkbox"> cmake</li><li><input checked="" disabled="" type="checkbox"> zsh</li><li><input checked="" disabled="" type="checkbox"> jupyter</li><li><input checked="" disabled="" type="checkbox"> fzf</li><li><input checked="" disabled="" type="checkbox"> ag search</li><li><input checked="" disabled="" type="checkbox"> htop</li><li><input checked="" disabled="" type="checkbox"> tmux</li><li><input checked="" disabled="" type="checkbox"> clang-format</li><li><input checked="" disabled="" type="checkbox"> vim basic</li></ul><h1 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h1><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Tools</tag>
      
      <tag>Tricks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2203-OMP2CD重新实现</title>
    <link href="/2022/04/17/2022/2203-OMP2CD%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/04/17/2022/2203-OMP2CD%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>之所以会有这一片文章，是因为 LLVM OMP2CD 的项目中出现了一些不太符合实验数据的情况，其项目完整性和项目可用性存疑。在这里提出一些我的个人异议。并且基于此异议提出新的个人实现方案。</p><span id="more"></span><p>由于一周前 LLVM14 正式发布稳定版本，因此之后的实现方案基于 LLVM14 进行。（好吧其实我个人之会 LLVM9 以前的项目框架，12 还在学习中，之后打算写一个 LLVM12 的学习笔记）</p><h1 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h1><p>首先看论文原文： <a href="https://dl.acm.org/doi/pdf/10.1145/3155288">https://dl.acm.org/doi/pdf/10.1145/3155288</a></p><img src="image1.png" width="80%" height="80%"><p>走的是一个传统的 LLVM 框架：</p><ol><li>首先是前端分析生成 AST</li><li>之后在 AST 基础上生成 Annotation</li><li>多粒度并行转换，Codelet：细，TP：粗</li><li>CDG 转换，Codelet Graph</li><li>代码生成</li></ol><p>TP Rule：</p><ul><li>TP- 1: The declaration of a function, other than main(), that contains an omp executable directive.</li><li>TP- 2: An omp region.</li></ul><p>Codelet Rule:</p><ul><li>CBB- 1: An omp executable directive.</li><li>CBB- 2: A call to a function containing an omp executable directive.</li><li>CBB- 3: The first statement in an omp region.</li><li>CBB- 4: The first statement in a function, other than main(), containing an omp executable directive.</li><li>CBB- 5: The first statement of a branch, provided any of the branch’s parent nodes are part of a CBB.</li><li>CBB- 6: The implicit barrier of an omp region.</li><li>CBB- 7: The statement following a CBB whose leader was created using rules CBB-1, CBB-2, or CBB-6.</li></ul><h1 id="翻译器逻辑整理"><a href="#翻译器逻辑整理" class="headerlink" title="翻译器逻辑整理"></a>翻译器逻辑整理</h1><p>维持代码运行的内容分布在两个部分里：</p><ul><li>extra-tools</li><li>clang</li></ul><img src="image2.png" width="80%" height="80%"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">./llvm/tools/clang/include/clang/AST/OpenMPClause.h:class OMPCodeletClause : public OMPClause &#123;  <br>./llvm/tools/clang/include/clang/AST/OpenMPClause.h: OMPCodeletClause(SourceLocation StartLoc, SourceLocation End  <br>Loc)  <br>./llvm/tools/clang/include/clang/AST/OpenMPClause.h: OMPCodeletClause()  <br>./llvm/tools/clang/include/clang/AST/RecursiveASTVisitor.h:bool RecursiveASTVisitor&lt;Derived&gt;::VisitOMPCodeletClaus  <br>e(OMPCodeletClause *) &#123;  <br>./llvm/tools/clang/include/clang/Basic/OpenMPKinds.def:OPENMP_CLAUSE(codelet, OMPCodeletClause)  <br>./llvm/tools/clang/lib/AST/StmtProfile.cpp:void OMPClauseProfiler::VisitOMPCodeletClause(const OMPCodeletClause *)  <br>&#123;&#125;  <br>./llvm/tools/clang/lib/AST/StmtPrinter.cpp:void OMPClausePrinter::VisitOMPCodeletClause(OMPCodeletClause*) &#123;&#125;  <br>./llvm/tools/clang/lib/Sema/SemaOpenMP.cpp: <span class="hljs-built_in">return</span> new (Context) OMPCodeletClause(StartLoc, EndLoc);  <br>./llvm/tools/clang/lib/Sema/TreeTransform.h:TreeTransform&lt;Derived&gt;::TransformOMPCodeletClause(OMPCodeletClause *C)  <br>&#123;  <br>./llvm/tools/clang/lib/Serialization/ASTWriterStmt.cpp:void OMPClauseWriter::VisitOMPCodeletClause(OMPCodeletClaus  <br>e *) &#123;&#125;  <br>./llvm/tools/clang/lib/Serialization/ASTReaderStmt.cpp: C = new (Context) OMPCodeletClause();  <br>./llvm/tools/clang/lib/Serialization/ASTReaderStmt.cpp:void OMPClauseReader::VisitOMPCodeletClause(OMPCodeletClaus  <br>e *) &#123;&#125;  <br>./llvm/tools/clang/tools/libclang/CIndex.cpp:void OMPClauseEnqueue::VisitOMPCodeletClause(const OMPCodeletClause *  <br>) &#123;&#125;  <br>./llvm/tools/clang/tools/extra/omp2cd/src/Compiler/ASTVisit.cpp: <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dyn_cast&lt;OMPCodeletClause&gt;(clause  <br>)) &#123;<br></code></pre></td></tr></table></figure><p>移植 llvm 14 已经完成：</p><p><a href="https://github.com/Chivier/chranslate">https://github.com/Chivier/chranslate</a></p><h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>如果我们使用 LLVM 的框架，我们需要遍历 AST。</p><img src="image3.png" width="80%" height="80%"><p>读取命令行参数</p><img src="image4.png" width="80%" height="80%"><p>只处理两层以内的 omp 嵌套。</p><p>代码精读：</p><h1 id="评价和思考"><a href="#评价和思考" class="headerlink" title="评价和思考"></a>评价和思考</h1><p>这个论文的工作其实不复杂，可以说非常工程，首先先评价一下这个工作。这个工作虽然发了 TACO，但是惨淡的引用量反应了很多问题：</p><ol><li>项目代码混乱，对于AST的行为描述上没有很好的继承clang的优势，而是自己打散重新建立，不仅麻烦，而且有一些逻辑上错误</li><li>项目在clang的代码部分这边有很多疏漏，应该继承一个出来，而不是直接在clang的基础上改代码，（作者应该不太懂设计模式的问题）</li><li>项目的可用性存疑，在 omp 嵌套的时候很多时候没法跑，这个应该是第一点导致的</li></ol><p>这个和 llvm-3.9 的历史也有一定的关系，有一些部分 API 不是作者不想进行继承，而是作者没有办法进行继承。</p><p>官网说明：</p><p><a href="https://openmp.llvm.org/optimizations/OpenMPOpt.html">https://openmp.llvm.org/optimizations/OpenMPOpt.html</a></p><p>有一句：</p><blockquote><p>LLVM, since <a href="https://releases.llvm.org/download.html#11.0.0">version 11</a> (12 Oct 2020), has an <a href="https://openmp.llvm.org/optimizations/OpenMPOpt.html">OpenMP-Aware optimization pass</a> as well as the ability to <a href="https://openmp.llvm.org/optimizations/OpenMPUnawareOptimizations.html">perform “scalar optimizations” across OpenMP region boundaries</a>.<br>In-depth discussion of the topic can be found <a href="https://openmp.llvm.org/optimizations/Overview.html">here</a>.</p></blockquote><p>说明 2020 年之前是不可能做成一个可以便捷拓展的项目的。<br><img src="image5.png" width="80%" height="80%"></p><img src="image6.png" width="80%" height="80%"><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLVM</tag>
      
      <tag>Compiler</tag>
      
      <tag>Dataflow</tag>
      
      <tag>DARTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2204-GPU程序优化方法</title>
    <link href="/2022/04/11/2022/2204-GPU%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2022/04/11/2022/2204-GPU%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在目前为止的科研和学习经历中，cuda 的使用已经成为了日程的一个通电和要点问题。这里总结一些我用过的优化方法，留作笔记。</p><span id="more"></span><h1 id="GPU-八门神器"><a href="#GPU-八门神器" class="headerlink" title="GPU 八门神器"></a>GPU 八门神器</h1><h2 id="1-人多力量大"><a href="#1-人多力量大" class="headerlink" title="1 人多力量大"></a>1 人多力量大</h2><p>这是一个“不算优化的优化”，如何在 cuda 中调用多张卡进行计算。</p><p>首先一个不是办法的办法： 使用 MPI 进行第一层级并行，通信到不同的机器上，在每一个机器上使用一张卡。（好吧我编不下去了，这个方法蠢了，单机多卡完全摆烂了）</p><p>(不过本优化还有一个明显的特性：依赖内存带宽，这个是 PCIE4.0 机器目前的瓶颈之一，NVLink 某种意义上可以有效处理这一矛盾，但是他也只是一种瓶颈转移——把瓶颈转移到我们的经费上)</p><p>使用的时候和大部分的方法是相同的，但是不同之处是我们需要使用 cudaSetDevice 去手动设置使用的设备编号。参考 cudatest-18。</p><p>但是由于鲁棒性的需求，我们的 cudaSetDevice 在下标超出范围的时候还是可以正常使用的，一般编号超过范围的卡，我们会把卡的计算信息映射到最后一张卡上面。但是会返回 cudaError 的 bool 数值，详情参考 cudaSetDevice 的 API 手册。</p><p>下面是使用 cudatest19 把 8 个 1080 都用满的例子。</p><p><img src="image1.png" width="80%" height="80%"></p><h2 id="2-fast-math-amp-精度"><a href="#2-fast-math-amp-精度" class="headerlink" title="2 fast math &amp; 精度"></a>2 fast math &amp; 精度</h2><p>如果程序中的数学函数：三角函数、快速傅立叶变换、幂次、根号，等等。这些使用频率过高的时候，我们在 cuda 中可以从用 fast math 编译选项进行优化。一般会有 5~15%的效率提升。</p><p><img src="image2.png" width="80%" height="80%"></p><p>nvcc -h 中可以读取 —use_fast_math 的具体内容和功能</p><h2 id="3-wrap-divergence"><a href="#3-wrap-divergence" class="headerlink" title="3 wrap divergence"></a>3 wrap divergence</h2><p>之前说过：</p><p>现在的 GPU 架构中</p><ul><li>一个 GPU = 多个 Streaming Multiprocessor (SM) + cache 组成</li><li>一个 SM = Streaming Processor（SP）+ cache 组成</li><li>SM 用于处理 block</li><li>SP 用于处理 thread</li></ul><p>但是我们调度的时候不会精细调度每一个 thread, 我们会用 wrap（1 wrap = 32 threads）去考虑这个事情。<br>所以如果出现分支的时候我们会发生所谓的 wrap divergence。（这个概念最早出现在 Cray 机器的 PDE 求解上，我以前一直以为 GPU 也会做分支预测，直到事情变得不太健康我才发现这个会消耗很多性能）</p><p>这里参考一个例子 20-wrapdivergence</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::duration_cast;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::milliseconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::seconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::system_clock;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>&gt;</span><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func func)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;<br>         i &lt; n; i += blockDim.x * gridDim.x) &#123;<br>        func(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Func2</span>&gt;</span><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel_split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func1 func1, Func2 func2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (threadIdx.x &amp; <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x; i &lt; n; i += blockDim.x * gridDim.x) &#123;<br>            func1(i);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x; i &lt; n; i += blockDim.x * gridDim.x) &#123;<br>            func2(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Func2</span>&gt;</span><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel_better</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func1 func1, Func2 func2)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>        func2(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>        func1(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">26</span>;<br><br>    <span class="hljs-keyword">int</span> block_dim = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">int</span> grid_dim = (n - <span class="hljs-number">1</span>) / block_dim;<br><br>    cudaDeviceSynchronize(); <br>    <span class="hljs-keyword">auto</span> begin_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>    <span class="hljs-function">thrust::host_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">x_host</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">thrust::host_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">y_host</span><span class="hljs-params">(n)</span></span>;<br><br>    thrust::generate(x_host.begin(), x_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">3.0</span>;&#125;);<br>    thrust::generate(y_host.begin(), y_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">11.0</span>;&#125;);<br><br>    <br>    <span class="hljs-function">thrust::device_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">x_dev</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">thrust::device_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">y_dev</span><span class="hljs-params">(n)</span></span>;<br>    x_dev = x_host;<br>    y_dev = y_host;<br><br>    kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [x = x_dev.data(), y = y_dev.data()] __device__ (<span class="hljs-keyword">int</span> index)&#123;<br>        <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            x[index] = x[index] + y[index];<br>        <span class="hljs-keyword">else</span><br>            x[index] = x[index] - y[index];<br>    &#125;);<br><br>    checkCudaErrors(cudaDeviceSynchronize());<br>    x_host = x_dev;<br><br>    <span class="hljs-keyword">auto</span> end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>    cudaDeviceSynchronize(); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, end_millis - begin_millis);<br>    <br>    cudaDeviceSynchronize(); <br>    begin_millis = end_millis;<br>    <br>    thrust::generate(x_host.begin(), x_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">3.0</span>;&#125;);<br>    thrust::generate(y_host.begin(), y_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">11.0</span>;&#125;);<br>    <br>    x_dev = x_host;<br>    y_dev = y_host;<br>    kernel_split&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n,<br>            [x = x_dev.data(), y = y_dev.data()] __device__ (<span class="hljs-keyword">int</span> index) &#123;<br>                x[index] = x[index] + y[index];<br>            &#125;,<br>            [x = x_dev.data(), y = y_dev.data()] __device__ (<span class="hljs-keyword">int</span> index) &#123;<br>                x[index] = x[index] - y[index];<br>            &#125;);<br><br>    checkCudaErrors(cudaDeviceSynchronize());<br>    x_host = x_dev;<br>    end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>    cudaDeviceSynchronize(); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,end_millis - begin_millis);<br>    <br>    cudaDeviceSynchronize(); <br>    begin_millis = end_millis;<br>    <br>    thrust::generate(x_host.begin(), x_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">3.0</span>;&#125;);<br>    thrust::generate(y_host.begin(), y_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">11.0</span>;&#125;);<br>    <br>    x_dev = x_host;<br>    y_dev = y_host;<br>    kernel_better&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n,<br>            [x = x_dev.data(), y = y_dev.data()] __device__ (<span class="hljs-keyword">int</span> index) &#123;<br>                x[index] = x[index] + y[index];<br>            &#125;,<br>            [x = x_dev.data(), y = y_dev.data()] __device__ (<span class="hljs-keyword">int</span> index) &#123;<br>                x[index] = x[index] - y[index];<br>            &#125;);<br><br>    checkCudaErrors(cudaDeviceSynchronize());<br>    x_host = x_dev;<br>    end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>    cudaDeviceSynchronize(); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,end_millis - begin_millis);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子有 3 个函数，第一个是没有考虑分支分离的写法，kernel 函数每一次函数都有大量的分支。<br>第二个例子是考虑了分支，我们将分支提取到函数体外层即可（这个例子奇偶数分离出来，但是一般的 x86 平台机器还是可以很好的分支预测的，但是 cuda 的分支预测不是那么强，这就是过于强大的 SIMD 的一种代价吧）<br>第三个例子是没有考虑数据局部性例子</p><p>在 n = 1 &lt;&lt; 20 的时候，三个耗时是（毫秒）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">44  <br>41  <br>9033<br></code></pre></td></tr></table></figure><p>在 n = 1 &lt;&lt; 26 的时候，三个耗时是（毫秒）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">2963  <br>2623<br>...(too long)<br></code></pre></td></tr></table></figure><p>这里看到提前分支可以做出很多优化。<br>但是不能为了编程方便忽视空间局部性的问题。在第 8 点中会详细介绍 GPU 内存的问题。</p><h2 id="4-register-spill-amp-local-memory-usage-amp-latency-hiding"><a href="#4-register-spill-amp-local-memory-usage-amp-latency-hiding" class="headerlink" title="4 register spill &amp; local memory usage &amp; latency hiding"></a>4 register spill &amp; local memory usage &amp; latency hiding</h2><h3 id="4-1-Cuda-Memory-Intro"><a href="#4-1-Cuda-Memory-Intro" class="headerlink" title="4.1 Cuda Memory Intro"></a>4.1 Cuda Memory Intro</h3><p>Local Memory 这里的意思其实是指</p><blockquote><p>memory where registers and other thread data is spilled</p></blockquote><p>之所以这么设计和 GPU 的架构有关，以 Fermi 架构为例：</p><p><img src="image3.png" width="80%" height="80%"></p><p>图中我们看到我们的 LMEM 指的是 “SMEM 用尽，或者说也就是 SM 资源用尽的时候，额外使用的内存”，充分利用 L1 的存储空间可以发挥最大性能，但是如果我们没有使用好，就会造成 L1 和 L2 通信，正如下面这个链接所示</p><p><a href="https://stackoverflow.com/questions/23876594/cuda-local-memory-register-spilling-overhead">https://stackoverflow.com/questions/23876594/cuda-local-memory-register-spilling-overhead</a></p><p>从 L2/DRAM 中取数据或者写数据的代价是非常昂贵的。</p><p><strong>在 Maxwell 和之后的架构中 L1 和 SMEM 合并</strong></p><p><img src="image4.png" width="80%" height="80%"></p><p>这里官方说了一下 LMEM 的使用场景，如果线程的场景比较复杂，我们就需要进行 register spill 从而达到避免寄存器冲突的目的。具体的 spill 策略未知，官方文档中也只有 <strong>heuristics</strong> 一词。<br>但是这里也说明了 Spill 不是坏事，数组是通过 SM 的 Register 访问的，这个在上面 20-wrapdivergence 的例子里面有个很好的对比，我们用错了访存顺序，就会导致每一次访存都进行 register spill。</p><p>cuda 对数组的使用不是用寄存器的，这个细节问题在下面的这个问题旁敲侧击给了一个漂亮的答案：</p><p><a href="https://stackoverflow.com/questions/12167926/forcing-cuda-to-use-register-for-a-variable">https://stackoverflow.com/questions/12167926/forcing-cuda-to-use-register-for-a-variable</a></p><h3 id="4-2-Programmers’-Behaviors"><a href="#4-2-Programmers’-Behaviors" class="headerlink" title="4.2 Programmers’ Behaviors"></a>4.2 Programmers’ Behaviors</h3><p>上述的架构对于我们编程人员有这些指导意义：</p><p>在 SM 上的 TB 越多越好，让 Thread Block 不停的跑我们的利用率就会高，在一个 thread 进行等待内存换入换出的时候，GPU 有一个叫 latency hiding 的策略，从而将使用效率变高。但是如果 Thread Block 太多，我们每一个 SM 能分配的寄存器就会变少，所以就会发生 Register Spill, 使用更高级的 L1、L2 Cache 去代替 Registers。所以 TB 不能太多，需要减少 Register Spill 的次数。</p><p>简而言之：Thread Block 越多越好，Register 少一些（少一些换入换出）更好。</p><p>下面使用一个例子说明。</p><p><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#launch-bounds">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#launch-bounds</a></p><p><img src="image5.png" width="80%" height="80%"></p><p>基于 modernGPU 项目写了 launchbound mergesort 测试，在 21-目录里对不同的 launch bound 进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::duration_cast;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::milliseconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::seconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::system_clock;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mgpu;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br>  <span class="hljs-keyword">standard_context_t</span> context;<br><br>  cudaDeviceSynchronize(); <br>  <span class="hljs-keyword">auto</span> begin_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>  <span class="hljs-keyword">int</span> count = <span class="hljs-number">1000000</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> it = <span class="hljs-number">1</span>; it &lt;= <span class="hljs-number">50</span>; ++it) &#123;<br>      <span class="hljs-keyword">mem_t</span>&lt;<span class="hljs-keyword">int</span>&gt; data = fill_random(<span class="hljs-number">0</span>, <span class="hljs-number">100000</span>, count, <span class="hljs-literal">false</span>, context);<br>      <br>      mergesort(data.data(), count, <span class="hljs-keyword">less_t</span>&lt;<span class="hljs-keyword">int</span>&gt;(), context);<br><br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ref = from_mem(data);<br>      <span class="hljs-built_in">std</span>::sort(ref.begin(), ref.end());<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sorted = from_mem(data);<br>    &#125;<br>  <span class="hljs-keyword">auto</span> end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>  cudaDeviceSynchronize();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, end_millis - begin_millis);<br><br>  cudaDeviceSynchronize(); <br>  begin_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>  count = <span class="hljs-number">1000000</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> it = <span class="hljs-number">1</span>; it &lt;= <span class="hljs-number">50</span>; ++it) &#123;<br>      <span class="hljs-keyword">mem_t</span>&lt;<span class="hljs-keyword">int</span>&gt; data = fill_random(<span class="hljs-number">0</span>, <span class="hljs-number">100000</span>, count, <span class="hljs-literal">false</span>, context);<br>      <br>      launchboundsort(data.data(), count, <span class="hljs-keyword">less_t</span>&lt;<span class="hljs-keyword">int</span>&gt;(), context);<br><br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ref = from_mem(data);<br>      <span class="hljs-built_in">std</span>::sort(ref.begin(), ref.end());<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sorted = from_mem(data);<br>    &#125;<br>  end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>  cudaDeviceSynchronize();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, end_millis - begin_millis);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-shared-memory"><a href="#4-3-shared-memory" class="headerlink" title="4.3 shared memory"></a>4.3 shared memory</h3><p>这里其实是两个话题的合并，但是我们一般都会把他们一起使用：</p><p>循环分块 + 共享内存预取数据</p><p>这种在 Stencil Computing 中特别常见</p><p>我们这里举一个例子，2D Laplacian 离散算子，这个是一个非常常见的例子了，就是</p><script type="math/tex; mode=display">\begin{aligned}&\Delta f=\frac{\partial^{2} f}{\partial x^{2}}+\frac{\partial^{2} f}{\partial y^{2}} \\&=f(x+1, y)+f(x-1, y)-2 f(x, y)+f(x, y+1)+f(x, y-1)-2 f(x, y) \\&=f(x+1, y)+f(x-1, y)+f(x, y+1)+f(x, y-1)-4 f(x, y)\end{aligned}</script><p>那么我们如何用 cuda 实现呢？<br>这里我写几个版本，22 stencil 里程序作为对比。</p><p>首先无处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::duration_cast;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::milliseconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::seconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::system_clock;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">stencil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row_num, <span class="hljs-keyword">int</span> col_num, <span class="hljs-keyword">int</span> *arr_data, <span class="hljs-keyword">int</span> *result)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> index = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-keyword">auto</span> current_row = index / col_num;<br>    <span class="hljs-keyword">auto</span> current_col = index % col_num;<br>    <span class="hljs-keyword">auto</span> data0 = arr_data[index];<br>    <span class="hljs-comment">// up</span><br>    <span class="hljs-keyword">auto</span> data1 = arr_data[(current_row + row_num - <span class="hljs-number">1</span>) % row_num * col_num + current_col];<br>    <span class="hljs-comment">// down</span><br>    <span class="hljs-keyword">auto</span> data2 = arr_data[(current_row + <span class="hljs-number">1</span>) % row_num * col_num + current_col];<br>    <span class="hljs-comment">// left</span><br>    <span class="hljs-keyword">auto</span> data3 = arr_data[current_row * col_num + (current_col + col_num - <span class="hljs-number">1</span>) % col_num ];<br>    <span class="hljs-comment">// right</span><br>    <span class="hljs-keyword">auto</span> data4 = arr_data[current_row * col_num + (current_col + <span class="hljs-number">1</span>) % col_num];<br><br>    result[index] = data1 + data2 + data3 + data4 - <span class="hljs-number">4</span> * data0;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row_num = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">int</span> col_num = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>;<br><br>    <span class="hljs-keyword">int</span> *arr;<br>    <span class="hljs-keyword">int</span> *result;<br>    cudaMallocManaged(&amp;arr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * row_num * col_num);<br>    cudaMallocManaged(&amp;result, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * row_num * col_num);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; row_num * col_num; ++index) &#123;<br>        arr[index] = rand() % <span class="hljs-number">1024</span> - <span class="hljs-number">512</span>;<br>    &#125;<br><br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">auto</span> begin_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br><br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">int</span> total_numbers = row_num * col_num;<br>    <span class="hljs-keyword">int</span> block_size = <span class="hljs-number">1024</span>;<br>    stencil&lt;&lt;&lt;total_numbers / block_size, block_size&gt;&gt;&gt;(row_num, col_num, arr, result);<br><br>    cudaDeviceSynchronize(); <br>    <span class="hljs-keyword">auto</span> end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, end_millis - begin_millis);<br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后加上分块，效果拔群</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::duration_cast;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::milliseconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::seconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::system_clock;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">stencil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row_num, <span class="hljs-keyword">int</span> col_num, <span class="hljs-keyword">int</span> *arr_data, <span class="hljs-keyword">int</span> *result)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> current_row = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-keyword">auto</span> current_col = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-keyword">auto</span> index = current_row * col_num + current_col;<br>    <span class="hljs-keyword">auto</span> data0 = arr_data[index];<br>    <span class="hljs-comment">// up</span><br>    <span class="hljs-keyword">auto</span> data1 = arr_data[(current_row + row_num - <span class="hljs-number">1</span>) % row_num * col_num + current_col];<br>    <span class="hljs-comment">// down</span><br>    <span class="hljs-keyword">auto</span> data2 = arr_data[(current_row + <span class="hljs-number">1</span>) % row_num * col_num + current_col];<br>    <span class="hljs-comment">// left</span><br>    <span class="hljs-keyword">auto</span> data3 = arr_data[current_row * col_num + (current_col + col_num - <span class="hljs-number">1</span>) % col_num ];<br>    <span class="hljs-comment">// right</span><br>    <span class="hljs-keyword">auto</span> data4 = arr_data[current_row * col_num + (current_col + <span class="hljs-number">1</span>) % col_num];<br><br>    result[index] = data1 + data2 + data3 + data4 - <span class="hljs-number">4</span> * data0;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row_num = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">int</span> col_num = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>;<br><br>    <span class="hljs-keyword">int</span> *arr;<br>    <span class="hljs-keyword">int</span> *result;<br>    cudaMallocManaged(&amp;arr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * row_num * col_num);<br>    cudaMallocManaged(&amp;result, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * row_num * col_num);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; row_num * col_num; ++index) &#123;<br>        arr[index] = rand() % <span class="hljs-number">1024</span> - <span class="hljs-number">512</span>;<br>    &#125;<br><br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">auto</span> begin_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br><br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">int</span> total_numbers = row_num * col_num;<br>    <span class="hljs-keyword">int</span> block_size = <span class="hljs-number">1024</span>;<br>    stencil&lt;&lt;&lt;dim3(row_num / <span class="hljs-number">32</span>, col_num / <span class="hljs-number">32</span>, <span class="hljs-number">1</span>), dim3(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">1</span>)&gt;&gt;&gt;(row_num, col_num, arr, result);<br><br>    cudaDeviceSynchronize(); <br>    <span class="hljs-keyword">auto</span> end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, end_millis - begin_millis);<br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后加上共享内存数据预取，这个工作边际效益递减，作用有限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::duration_cast;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::milliseconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::seconds;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::chrono::system_clock;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">stencil</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row_num, <span class="hljs-keyword">int</span> col_num, <span class="hljs-keyword">int</span> *arr_data, <span class="hljs-keyword">int</span> *result)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> current_row = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-keyword">auto</span> current_col = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-keyword">auto</span> index = current_row * col_num + current_col;<br>    <span class="hljs-keyword">auto</span> data0 = arr_data[index];<br>    <span class="hljs-comment">// up</span><br>    <span class="hljs-keyword">auto</span> data1 = arr_data[(current_row + row_num - <span class="hljs-number">1</span>) % row_num * col_num + current_col];<br>    <span class="hljs-comment">// down</span><br>    <span class="hljs-keyword">auto</span> data2 = arr_data[(current_row + <span class="hljs-number">1</span>) % row_num * col_num + current_col];<br>    <span class="hljs-comment">// left</span><br>    <span class="hljs-keyword">auto</span> data3 = arr_data[current_row * col_num + (current_col + col_num - <span class="hljs-number">1</span>) % col_num ];<br>    <span class="hljs-comment">// right</span><br>    <span class="hljs-keyword">auto</span> data4 = arr_data[current_row * col_num + (current_col + <span class="hljs-number">1</span>) % col_num];<br><br>    result[index] = data1 + data2 + data3 + data4 - <span class="hljs-number">4</span> * data0;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row_num = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">int</span> col_num = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>;<br><br>    <span class="hljs-keyword">int</span> *arr;<br>    <span class="hljs-keyword">int</span> *result;<br>    cudaMallocManaged(&amp;arr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * row_num * col_num);<br>    cudaMallocManaged(&amp;result, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * row_num * col_num);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; row_num * col_num; ++index) &#123;<br>        arr[index] = rand() % <span class="hljs-number">1024</span> - <span class="hljs-number">512</span>;<br>    &#125;<br><br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">auto</span> begin_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br><br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">int</span> total_numbers = row_num * col_num;<br>    <span class="hljs-keyword">int</span> block_size = <span class="hljs-number">1024</span>;<br>    stencil&lt;&lt;&lt;dim3(row_num / <span class="hljs-number">32</span>, col_num / <span class="hljs-number">32</span>, <span class="hljs-number">1</span>), dim3(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">1</span>)&gt;&gt;&gt;(row_num, col_num, arr, result);<br><br>    cudaDeviceSynchronize(); <br>    <span class="hljs-keyword">auto</span> end_millis = duration_cast&lt;milliseconds&gt;(system_clock::now().time_since_epoch()).count();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, end_millis - begin_millis);<br>    cudaDeviceSynchronize();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-unroll"><a href="#5-unroll" class="headerlink" title="5 unroll"></a>5 unroll</h2><p>循环展开，至于目的不做冗余介绍，这里直接展示一下 unroll 用法。<br>在 22 中第三个例子已经使用了，只需要</p><p><code>#pragma unroll</code> 一句即可</p><h2 id="6-zerocopy"><a href="#6-zerocopy" class="headerlink" title="6 zerocopy"></a>6 zerocopy</h2><p>一个非常简单易用的 trick</p><p><a href="https://migocpp.wordpress.com/2018/06/08/cuda-memory-access-global-zero-copy-unified/">https://migocpp.wordpress.com/2018/06/08/cuda-memory-access-global-zero-copy-unified/</a></p><p>简而言之，在 host 使用命令：cudaHostRegisterMapped<br>之后用 cudaHostGetDevicePointer 进行映射<br>最后解除绑定 cudaHostUnregister</p><p>即，如果我们数据只会在 GPU 产生和使用，我们不需要来回进行拷贝。</p><p>例子如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// First, pin the memory (or cudaHostAlloc instead)</span><br>cudaHostRegister(h_a, …, cudaHostRegisterMapped);<br>cudaHostRegister(h_b, …, cudaHostRegisterMapped);<br>cudaHostRegister(h_c, …, cudaHostRegisterMapped);<br><br>cudaHostGetDevicePointer(&amp;a, h_a, <span class="hljs-number">0</span>);<br>cudaHostGetDevicePointer(&amp;b, h_b, <span class="hljs-number">0</span>);<br>cudaHostGetDevicePointer(&amp;c, h_c, <span class="hljs-number">0</span>);<br><br>kernel&lt;&lt;&lt;...&gt;&gt;&gt;(a, b, c);<br>cudaDeviceSynchronize();<br><br><span class="hljs-comment">// unpin/release host memory</span><br>cudaHostUnregister(h_a);<br>cudaHostUnregister(h_b);<br>cudaHostUnregister(h_c);<br></code></pre></td></tr></table></figure></p><h2 id="7-coalesced-acccess"><a href="#7-coalesced-acccess" class="headerlink" title="7 coalesced acccess"></a>7 coalesced acccess</h2><p>和 4.3 小节中的例子一样，但是那个例子因为边界情况，有一些复杂，这里补充说明一下</p><p><img src="https://i.stack.imgur.com/fFhFo.jpg" alt="enter image description here"></p><p>问题的出现在于我们取的数据不是连续数据。</p><p>在图。(a) n 个长度为 m 的向量以线性方式存储。向量 j 的元素 i 用 v j i 表示，GPU 内核中的每个线程都分配给一个 m 长的向量。CUDA 中的线程组成一个块数组，GPU 中的每个线程都有一个唯一的 id，可以定义为 indx = bd * bx + tx，其中 bd 表示块维度，bx 表示块索引，tx 表示每个块中的线程索引。</p><p>垂直箭头表示平行线程访问每个向量的第一个分量，这种情况下，内存访问不是连续的。通过对这些地址之间的间隔进行归零(如上图所示的红色箭头) ，内存访问就得到了合并。</p><h2 id="8-bank-conflict"><a href="#8-bank-conflict" class="headerlink" title="8 bank conflict"></a>8 bank conflict</h2><p><a href="https://blog.csdn.net/weixin_42730667/article/details/106171382">https://blog.csdn.net/weixin_42730667/article/details/106171382</a></p><p>GPU 的共享内存，实际上是 32 块内存条通过并联组成的，每个时钟周期都可以读取一个 int。第 i 块内存，负责 addr % 32 == i 的数据。这样交错存储，可以保证随机访问时，访存能够尽量分摊到 32 个块。</p><p>如果在block内多个线程访问的地址落入到同一个bank内，那么就会访问同一个bank就会产生bank conflict，这些访问将是变成串行，在实际开发调式中非常主要bank conflict.</p><p><img src="https://img-blog.csdn.net/20150724161715938" alt="è¿éåå¾çæè¿°"></p><p>处理方法非常简单，我们不要把 shared memory 开辟的空间设置成 32 的倍数即可（线性同余方程，原理也很好理解）</p><p>也可以采用一个 API 的办法：</p><p>使用 cudaDeviceGetSharedMemConfig 手动修改 GPU 的 shared memory ，少用一点，不过这个办法看起来不如上面的划算，其实性能差不太多。因为上面的办法实际上也会有空间浪费。</p><h1 id="思考和小结"><a href="#思考和小结" class="headerlink" title="思考和小结"></a>思考和小结</h1><p>上述诸多技术都是不断学习总结的成果。我认为之后我们应该更多的关注日常软件的更新里的细节，其中 register spill 和 fast math 的问题其实是在 blender 的 issue 里面学习的，学习在于日常的积累和发现。</p><p>此外，我觉得用好 cuda 需要写更多的程序和例子。</p><h1 id="下一步可以做的工作"><a href="#下一步可以做的工作" class="headerlink" title="下一步可以做的工作"></a>下一步可以做的工作</h1><p>自从 LLVM 中加入了 cuda codegen 之后，我觉得可以考虑加入一些基于编译器前端的自动化的工作。</p><p>例如能否测试一个任务的复杂程度，从而评估一个合适的 launch bound。这个工作其实本来就应该交给编译器去完成，而不是让程序员自己数自己用的寄存器数目，自己考虑自己的 block 数目，这个怎么说都不太人性化。如果做的不好，可能会像 taichi 那样做成 flatten mode，会为了简化编程牺牲很多性能，做的过多可能会像 sycl 一样变得僵硬难用。这里能否建立一些合适的模型去评估可行性是一个值得思考的问题。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://numba.readthedocs.io/en/stable/cuda/fastmath.html">https://numba.readthedocs.io/en/stable/cuda/fastmath.html</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-math-api/group__CUDA__MATH__INTRINSIC__SINGLE.html">https://docs.nvidia.com/cuda/cuda-math-api/group__CUDA__MATH__INTRINSIC__SINGLE.html</a></li><li><a href="https://developer.download.nvidia.com/CUDA/training/register_spilling.pdf">https://developer.download.nvidia.com/CUDA/training/register_spilling.pdf</a></li><li><a href="https://stackoverflow.com/questions/12167926/forcing-cuda-to-use-register-for-a-variable">https://stackoverflow.com/questions/12167926/forcing-cuda-to-use-register-for-a-variable</a></li><li><a href="https://www.carlpearson.net/pdf/2016nuggets.pdf">https://www.carlpearson.net/pdf/2016nuggets.pdf</a></li><li><a href="https://stackoverflow.com/questions/21196685/function-as-argument-of-thrust-iterator-cuda">https://stackoverflow.com/questions/21196685/function-as-argument-of-thrust-iterator-cuda</a></li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S016781911300094X">https://www.sciencedirect.com/science/article/abs/pii/S016781911300094X</a></li><li><a href="https://www.nvidia.com/content/PDF/isc-2011/Brandvik.pdf">https://www.nvidia.com/content/PDF/isc-2011/Brandvik.pdf</a></li><li><a href="https://migocpp.wordpress.com/2018/06/08/cuda-memory-access-global-zero-copy-unified/">https://migocpp.wordpress.com/2018/06/08/cuda-memory-access-global-zero-copy-unified/</a></li><li><a href="https://blog.csdn.net/weixin_42730667/article/details/106171382">https://blog.csdn.net/weixin_42730667/article/details/106171382</a></li><li><a href="https://www.microway.com/hpc-tech-tips/gpu-shared-memory-performance-optimization/">https://www.microway.com/hpc-tech-tips/gpu-shared-memory-performance-optimization/</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Develop</tag>
      
      <tag>Cuda</tag>
      
      <tag>Parallel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2203-收藏夹整理系列1</title>
    <link href="/2022/03/28/2022/2203-%E6%94%B6%E8%97%8F%E5%A4%B9%E6%95%B4%E7%90%86%E7%B3%BB%E5%88%971/"/>
    <url>/2022/03/28/2022/2203-%E6%94%B6%E8%97%8F%E5%A4%B9%E6%95%B4%E7%90%86%E7%B3%BB%E5%88%971/</url>
    
    <content type="html"><![CDATA[<p>这一系列的文章主要记录一下我从 Chrome 迁移到 Edge 的过程。</p><span id="more"></span><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a>1Password</h2><p>密码管理工具，没有它活不下去。之前 Keepass 在 Linux 上总是会奇怪的崩溃，让我非常头疼。</p><h2 id="Plasma-Integration"><a href="#Plasma-Integration" class="headerlink" title="Plasma Integration"></a>Plasma Integration</h2><p>Plasma 桌面环境增强工具</p><h2 id="Automa"><a href="#Automa" class="headerlink" title="Automa"></a>Automa</h2><p>自动化神器</p><h2 id="SingleFile"><a href="#SingleFile" class="headerlink" title="SingleFile"></a>SingleFile</h2><p>网页下载神器</p><h1 id="Latex-Tools"><a href="#Latex-Tools" class="headerlink" title="Latex Tools"></a>Latex Tools</h1><p><a href="https://www.ctan.org/pkg/">https://www.ctan.org/pkg/</a><br>包下载，不多介绍了</p><p><a href="https://www.overleaf.com/project/">https://www.overleaf.com/project/</a><br>Overleaf</p><p><a href="https://tableconvert.com/csv-to-latex">https://tableconvert.com/csv-to-latex</a><br><a href="https://www.tablesgenerator.com/#">https://www.tablesgenerator.com/#</a><br>表格转换，写作神器</p><p><a href="https://www.overleaf.com/latex/templates">https://www.overleaf.com/latex/templates</a><br>模板大全</p><p><a href="https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols">https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols</a><br>符号大全</p><p><a href="https://texample.net/tikz/examples/">https://texample.net/tikz/examples/</a><br>Tikz 做图</p><p><a href="https://www.latexstudio.net/archives/51781.html">https://www.latexstudio.net/archives/51781.html</a><br>好用的模板（算法和伪代码模块）</p><h1 id="Entertainment"><a href="#Entertainment" class="headerlink" title="Entertainment"></a>Entertainment</h1><p><a href="https://store.steampowered.com/">https://store.steampowered.com/</a><br>Steam</p><p><a href="https://skylines.paradoxwikis.com/Beginner%27s_guide">https://skylines.paradoxwikis.com/Beginner%27s_guide</a><br>Skylines Tutorial</p><p><a href="https://docs.screeps.com/introduction.html#Game-world">https://docs.screeps.com/introduction.html#Game-world</a><br>Screeps Tutorial</p><p><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2060888276">https://steamcommunity.com/sharedfiles/filedetails/?id=2060888276</a><br>Selfless Hero Answers</p><p><a href="http://flightgear.sourceforge.net/manual/">http://flightgear.sourceforge.net/manual/</a><br>FilghtGear Manual</p><p><a href="https://www.fanatical.com/en/">https://www.fanatical.com/en/</a><br>Fanatical</p><p><a href="https://www.humblebundle.com/">https://www.humblebundle.com/</a><br>Humble Bundle</p><h1 id="NiceProjects"><a href="#NiceProjects" class="headerlink" title="NiceProjects"></a>NiceProjects</h1><p><a href="https://github.com/danistefanovic/build-your-own-x">https://github.com/danistefanovic/build-your-own-x</a><br>教程合集</p><p><a href="https://github.com/EbookFoundation/free-programming-books">https://github.com/EbookFoundation/free-programming-books</a><br>编程书籍合集</p><p><a href="https://github.com/fengdu78/lihang-code">https://github.com/fengdu78/lihang-code</a><br>统计学习方法代码</p><p><a href="https://www.ioccc.org/">https://www.ioccc.org/</a><br>IOCCC</p><p><a href="http://ai.stanford.edu/~asaxena/reconstruction3d/">http://ai.stanford.edu/~asaxena/reconstruction3d/</a><br>3D 重建</p><p><a href="https://www.openvim.com/">https://www.openvim.com/</a><br>Vim 教程</p><p><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/">https://llvm-tutorial-cn.readthedocs.io/en/latest/</a><br>LLVM 开发新语言</p><p><a href="https://vulkan-tutorial.com/">https://vulkan-tutorial.com/</a><br>Vulkan</p><p><a href="https://gitlab.kitware.com/paraview/paraview">https://gitlab.kitware.com/paraview/paraview</a><br>Paraview</p><p><a href="https://www.agner.org/optimize/">https://www.agner.org/optimize/</a><br>软件优化教程</p><p><a href="https://pbr-book.org/3ed-2018/contents">https://pbr-book.org/3ed-2018/contents</a><br>物理渲染</p><p><a href="https://yangwc.com/2019/07/04/FluidRendering/">https://yangwc.com/2019/07/04/FluidRendering/</a><br>流体渲染</p>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
      <tag>Develop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2203-voronoi朴素开发笔记</title>
    <link href="/2022/03/28/2022/2203-voronoi%E6%9C%B4%E7%B4%A0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/28/2022/2203-voronoi%E6%9C%B4%E7%B4%A0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Version-0-0"><a href="#Version-0-0" class="headerlink" title="Version 0.0"></a>Version 0.0</h1><span id="more"></span><h2 id="voronoi朴素"><a href="#voronoi朴素" class="headerlink" title="voronoi朴素"></a>voronoi朴素</h2><p>2022-03-19 开发测试<br>Intro:<br>测试需要，给出 N 个点，（有一个边界），生成 Voronoi 划分</p><h2 id="设计阶段-1"><a href="#设计阶段-1" class="headerlink" title="设计阶段 1"></a>设计阶段 1</h2><p>class = 点集合 + 边界</p><h1 id="Development-Step-1"><a href="#Development-Step-1" class="headerlink" title="Development Step 1"></a>Development Step 1</h1><p>初步算法为：</p><p>对与每一个点，提取所有中垂面，进行几何交集切割凸包</p><p>距离：半径和极限，下一个中垂面距离超过半径，那么无法切割</p><p>子数据结构：凸包（点集合描述？中垂面描述？）</p><h3 id="点集合描述"><a href="#点集合描述" class="headerlink" title="点集合描述"></a>点集合描述</h3><p>done</p><p><a href="https://github.com/Chivier/votropy">https://github.com/Chivier/votropy</a></p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Develop</tag>
      
      <tag>Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2203-并行体系结构笔记1</title>
    <link href="/2022/03/28/2022/2203-%E5%B9%B6%E8%A1%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/03/28/2022/2203-%E5%B9%B6%E8%A1%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p>A parallel computer is a collection of processing elements that can communicate and cooperate to solve a large problem fast.</p><span id="more"></span><h1 id="当代主流的并行机系统"><a href="#当代主流的并行机系统" class="headerlink" title="当代主流的并行机系统"></a>当代主流的并行机系统</h1><h3 id="并行机器结构纵览"><a href="#并行机器结构纵览" class="headerlink" title="并行机器结构纵览"></a>并行机器结构纵览</h3><h4 id="SIMD-阵列处理机"><a href="#SIMD-阵列处理机" class="headerlink" title="SIMD 阵列处理机"></a>SIMD 阵列处理机</h4><p>SIMD并行机的一种。多台处理器（即处理单元 PE）排成阵列的拓扑结构,利用资源重复的方法开拓并行性。此类<br>机器的程序是单控制线程,按照顺序或并行步执行之。单一的指令运行在大型规则的数据结构（如数组和矩阵等）上，使阵列处理机也常叫做数据并行结构（Data Parallel Architecture）。</p><h4 id="向量处理机"><a href="#向量处理机" class="headerlink" title="向量处理机"></a>向量处理机</h4><p>在向量机中，标量处理器被集成为一组功能单元,它们以流水线方式执行存储器中的向量数据。能够操作于存储器中任何地方的向量就没有必要将应用数据结构映射到不变的互连结构上,从而大大地简化了数据对准的问题。</p><h4 id="共享存储多处理机"><a href="#共享存储多处理机" class="headerlink" title="共享存储多处理机"></a>共享存储多处理机</h4><p>按照 Flynn 分类法，共享存储的多处理机系统，是属于 MIMD 系统。分为紧耦合和松耦合两种。前者共享主存通信；后者借助总线适配器处理数据，各个处理器地位平等。</p><h4 id="分布存储多计算机"><a href="#分布存储多计算机" class="headerlink" title="分布存储多计算机"></a>分布存储多计算机</h4><p>分布存储的多计算机是属于消息传递型并行计算机，其中，每个处理器都是一个独立性较强的节点,系由处理器、本地存储器、I/O设备和消息传递通信接口所组成。由于每个计算节点的本地存储器容量较大,所以运算时所需的绝大部分的指令和数据均可取自本地存储器。当不同计算节点上的进程需要通信时,就可通过接口进行消息交换。由于节点之间耦合程度较低,所以此系统也常称为松散耦合的多机系统。</p><h4 id="共享分布存储的多处理机"><a href="#共享分布存储的多处理机" class="headerlink" title="共享分布存储的多处理机"></a>共享分布存储的多处理机</h4><p>共享存储的多处理机由于受互连网络带宽的限制而扩展性较差,但由于是单一共亨地址空间，所以较易于编程；而分布存储的多计算机，由于是松散性耦合，所以易于扩展,但多地址空间却使编程较困难。共享分布存储的多处理机是将物理上分布的存储系统,通过硬件和软件的办法,向用户提供一个单一的全局地址空间。这样，共享分布存储多处埋机系统既具有分布存储多机系统易于扩展的特性，又具有共享存储多处理机系统易于编程的优点。</p><h3 id="当代流行结构"><a href="#当代流行结构" class="headerlink" title="当代流行结构"></a>当代流行结构</h3><ol><li>单指令流多数据流SIMD计算机；</li><li>并行向量处理机 PVP；</li><li>对称多处理机 SMP；</li><li>大规模并行处理机 MPP；</li><li>工作站机群 COW；</li><li>分布式共享存储DSM 多处理机；</li></ol><h1 id="并行计算机的主要访存模型"><a href="#并行计算机的主要访存模型" class="headerlink" title="并行计算机的主要访存模型"></a>并行计算机的主要访存模型</h1><h2 id="均匀存储访问模型"><a href="#均匀存储访问模型" class="headerlink" title="均匀存储访问模型"></a>均匀存储访问模型</h2><p>UMA（Uniform Memory Access）模型是均匀存储访问模型的简称。</p><p>其特点是：</p><ol><li><p>物理存储器被所有处理器均匀共享；</p></li><li><p>所有处理器访问任何存储字取相同的时间(此即均匀存储访问名称的由来);</p></li><li><p>每台处理器可带私有高速缓存；</p></li><li><p>外围设备也可以一定形式共享。</p></li></ol><p>这种系统由于高度共享资源，而称为紧耦合系统（Tightly Coupled System）。</p><p>当所有的处理器都能等同地访问所有I/O设备,能同样地运行执行程序(如操作系统内核和I/O服务程序等)时,称为对称多处理机SMP；如果只有一台或一组处理器(称为主处理器），它能执行操作系统并能操纵 I/O，而其余的处理器无 I/O 能力(称为从处理器)，只在主处理器的监控之下执行用户代码，这时称为非对称多处理机。一般而言，UMA结构适于通用或分时应用。</p><h2 id="非均匀存储访问模型"><a href="#非均匀存储访问模型" class="headerlink" title="非均匀存储访问模型"></a>非均匀存储访问模型</h2><p>NUMA(Nonuniform Memory Access)模型是非均匀存储访问模型的简称。</p><p>NUMA的特点是：</p><ol><li>被共享的存储器在物理上是分布在所有的处理器中的，其所有本地存储器的集合就组成了全局地址空间；</li><li>处理器访问存储器的时间是不一样的；访问本地存储器 LM 或群内共享存储器CSM 较快，而访问外地的存储器或全局共享存储器GSM ( Global Sbared Memory)较慢(此即非均匀存储访问名称的由来)；</li><li>每台处理器照例可带私有高速缓存,且外设也可以某种形式共享。</li></ol><h2 id="全高速缓存存储访问模型"><a href="#全高速缓存存储访问模型" class="headerlink" title="全高速缓存存储访问模型"></a>全高速缓存存储访问模型</h2><p>COMA(Cache－Only Memory Access)模型是全高速缓存存储访问的简称。它是NUMA的一种特例。</p><p>其特点是：</p><ol><li>各处理器节点中没有存储层次结构，全部高速缓存组成了全局地址空间;</li><li>利用分布的高速缓存目录D进行远程高速缓存的访问；</li><li>COMA中的高速缓存容量一般都大于二级高速缓存容量；</li><li>使用COMA时，数据开始时可任意分配,因为在运行时它最终会被迁移到要用到它们的地方。</li></ol><h2 id="高速缓存一致性非均匀存储访问模型"><a href="#高速缓存一致性非均匀存储访问模型" class="headerlink" title="高速缓存一致性非均匀存储访问模型"></a>高速缓存一致性非均匀存储访问模型</h2><p>它实际上是将一些 SMP 机器作为一个单节点而彼此连接起来所形成的一个较大的系统。其特点是：</p><ol><li>绝大多数商用 CC－NUMA 多处理机系统都使用基于目录的高速缓存一致性协议；</li><li>它在保留 SMP 结构易于编程的优点的同时,也改善了常规SMP的可扩放性问题；</li><li>CC－NUMA实际上是一个分布共享存储的DSM多处理机系统；</li><li>它最显著的优点是程序员无需明确地在节点上分配数据，系统的硬件和软件开始时自动在各节点分配数据,在运行期间,高速缓存一致性硬件会自动地将数据迁移至要用到它的地方。</li></ol><p>总之,CC－NUMA所发明的一些技术在开拓数据局部性和增强系统的可扩性方面很有效。不少商业应用,大多数数据访问都可限制在本地节点内,网络上的主要通信不是传输数据,而是为高速级存的无效性(Invalidation)所用。</p><h2 id="非远程存储访问模型"><a href="#非远程存储访问模型" class="headerlink" title="非远程存储访问模型"></a>非远程存储访问模型</h2><p>NORMA（No－Remote Memory Access）模型是非远程存储访问模型的简称。在一个分布存储的多处理机系统中,如果所有的存储器都是私有的,仅能由其自己的处理器所访问时,就称为NORMA。系统由多个计算节点通过消息传递互连网络连接而成,每个节点都是一台由处理器、本地存储器和(或)I/O外设组成的自治计算机。NORMA的特点是</p><ol><li>所有存储器是私有的；</li><li>绝大数 NUMA 都不支持远程存储器的访问；</li><li>在 DSM 中，NORMA 就消失了。</li></ol><h1 id="CPI-MPIS-CPU-TIME-例子"><a href="#CPI-MPIS-CPU-TIME-例子" class="headerlink" title="CPI MPIS CPU_TIME 例子"></a>CPI MPIS CPU_TIME 例子</h1><p>使用4GHZ主频的标量处理器执行一个典型测试程序，其所执行的指令数及所需的周期数如下表所示。试计算执行该程序的有效CPI、MIPS速率及总的CPU执行时间**</p><table><thead><tr><th>指令类型</th><th>指令数</th><th>时钟周期数</th></tr></thead><tbody><tr><td>整数算术</td><td>45，000</td><td>1</td></tr><tr><td>数据传送</td><td>32，000</td><td>2</td></tr><tr><td>浮    点</td><td>15，000</td><td>2</td></tr><tr><td>控制转移</td><td>8，000</td><td>2</td></tr></tbody></table><h2 id="CPI"><a href="#CPI" class="headerlink" title="CPI"></a>CPI</h2><p>= cycles per instruction</p><p>= $\dfrac{45000 * 1 + 32000 * 2 + 15000 * 2 + 8000 * 2}{45000 + 32000 + 15000 + 8000}$</p><p>=$\dfrac{155000}{100000}$</p><p>= 1.55</p><h2 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h2><p>= million instructions per second</p><p>= $\dfrac{4 * 10^9}{1.55 * 10^6}$</p><p>= 2580.6</p><h2 id="CPU-Time"><a href="#CPU-Time" class="headerlink" title="CPU Time"></a>CPU Time</h2><p>= $\dfrac{155000}{4 * 10^9}$</p><p>= 0.00003875 s</p><h1 id="为什么增加问题规模可以在一定程度提高加速比"><a href="#为什么增加问题规模可以在一定程度提高加速比" class="headerlink" title="为什么增加问题规模可以在一定程度提高加速比?"></a>为什么增加问题规模可以在一定程度提高加速比?</h1><p>Gustafson定律的基本出发点是：</p><ol><li>对于很多大型计算,精度要求很高，即在此类应用中精度是个关键因素，而计算时间是固定不变的。此时为了提高精度,必须加大计算量,相应地亦必须增多处理器数,才能维持时间不变；</li><li>除非学术研究,在实际应用中,没有必要固定工作负载,而计算程序运行在不同数目的处理器上,增多处理器必须相应地增大问题规模,才有实际意义。</li></ol><p>$$<br>S^{\prime}=\frac{W_{\mathrm{s}}+P W_{\mathrm{p}}}{W_{\mathrm{s}}+P \cdot W_{\mathrm{p}} / P}=\frac{W_{\mathrm{s}}+P W_{P}}{W_{\mathrm{s}}+W_{\mathrm{p}}}<br>$$<br>归一化后可得<br>$$<br>S^{\prime}=f+P\left(1-f^{\prime}\right)=P+f(1-P)=P-f(P-1)<br>$$<br>当 $P$ 充分大时, $S^{\prime}$ 与 $P$ 儿乎成线性关系, 其斜率为 $1-f$。它意昩着随着处理器数目的增多, 加速几羊与处理器数成比例地线性增加, 串行比例 $f$ 不再是程序的瓶颈。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Architechture</tag>
      
      <tag>Parallel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2203-浮点数问题</title>
    <link href="/2022/03/23/2022/2203-%E6%B5%AE%E7%82%B9%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/23/2022/2203-%E6%B5%AE%E7%82%B9%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近重读计算机体系结构，对于浮点数进行一些整理和复习。</p><span id="more"></span><h1 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h1><blockquote><p>The <strong>IEEE Standard for Floating-Point Arithmetic</strong> (<strong>IEEE 754</strong>) is a <a href="https://en.wikipedia.org/wiki/Technical_standard" title="Technical standard">technical standard</a> for <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" title="Floating-point arithmetic">floating-point arithmetic</a> established in 1985 by the <a href="https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers" title="Institute of Electrical and Electronics Engineers">Institute of Electrical and Electronics Engineers</a> (IEEE). The standard <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#IEEE_754_design_rationale" title="Floating-point arithmetic">addressed many problems</a> found in the diverse floating-point implementations that made them difficult to use reliably and <a href="https://en.wikipedia.org/wiki/Software_portability" title="Software portability">portably</a>. Many hardware <a href="https://en.wikipedia.org/wiki/Floating-point_unit" title="Floating-point unit">floating-point units</a> use the IEEE 754 standard.<br>– From Wikipedia IEEE754</p></blockquote><p><a href="http://evanw.github.io/float-toy/">http://evanw.github.io/float-toy/</a></p><p>IEEE 754 是一类标准，主要包含：</p><ul><li>arithmetic formats: sets of binary and decimal floating-point data, which consist of finite numbers (including signed zeros and subnormal numbers), infinities, and special “not a number” values (NaNs)</li><li>interchange formats: encodings (bit strings) that may be used to exchange floating-point data in an efficient and compact form</li><li>rounding rules: properties to be satisfied when rounding numbers during arithmetic and conversions</li><li>operations: arithmetic and other operations (such as trigonometric functions) on arithmetic formats</li><li>exception handling: indications of exceptional conditions (such as division by zero, overflow, etc.)</li></ul><p>一般的浮点数表示形式如：</p><img src="image1.png" width="80%" height="80%"><p>采用 :<br>Sign(Blue) + Biased Exponet(Green) + Fraction(Red)</p><p>对于我们编程来说有如下需要注意的问题：</p><h2 id="Rounding-Rule"><a href="#Rounding-Rule" class="headerlink" title="Rounding Rule"></a>Rounding Rule</h2><p>Round to nearest, ties to even<br>Round to nearest, ties away from zero<br>Round toward 0<br>Round toward +∞<br>Round toward −∞</p><img src="image2.png" width="80%" height="80%"><p>(Since C++11)<br>    std::round, std::roundf<br>    std::roundl, std::lround<br>    std::lroundf, std::lroundl<br>    std::llround, std::llroundf</p><h2 id="NAN"><a href="#NAN" class="headerlink" title="NAN"></a>NAN</h2><p>NAN 有两种：</p><ul><li>QNAN</li><li>SNAN</li></ul><p>其中 QNAN 是可以利用计算构造的，SNAN 则是内置标注的<br><img src="image3.png" width="80%" height="80%"></p><p>下面用几个例子说明如何使用：</p><img src="image4.png" width="80%" height="80%"><img src="image5.png" width="80%" height="80%"><p>常见的比较方式有：<br><img src="image6.png" width="80%" height="80%"><br>Most operations with at least one NaN operand.</p><ul><li>Indeterminate forms:<ul><li>The divisions (±0) / (±0) and (±∞) / (±∞).</li><li>The multiplications (±0) × (±∞) and (±∞) × (±0).</li><li>Remainder x % y when x is an infinity or y is zero.</li><li>The additions (+∞) + (−∞), (−∞) + (+∞) and equivalent subtractions (+∞) − (+∞) and (−∞) − (−∞).</li><li>The standard has alternative functions for powers:<ul><li>The standard pow function and the integer exponent pown function define 00, 1∞, and ∞0 as 1.</li><li>The powr function defines all three indeterminate forms as invalid operations and so returns NaN.</li></ul></li></ul></li><li>Real operations with complex results, for example:<ul><li>The square root of a negative number.</li><li>The logarithm of a negative number.</li><li>The inverse sine or inverse cosine of a number that is less than −1 or greater than 1.</li></ul></li></ul><img src="image7.png" width="80%" height="80%"><img src="image8.png" width="80%" height="80%"><img src="image9.png" width="80%" height="80%"><p>如果需要 trace NAN 的时候，可以这样：<br><img src="image10.png" width="80%" height="80%"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://en.wikipedia.org/wiki/IEEE_754">https://en.wikipedia.org/wiki/IEEE_754</a></li><li><a href="https://stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number">https://stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number</a></li><li><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a></li><li><a href="https://en.cppreference.com/w/cpp/types/numeric_limits/has_quiet_NaN">https://en.cppreference.com/w/cpp/types/numeric_limits/has_quiet_NaN</a></li><li><a href="https://en.cppreference.com/w/cpp/types/numeric_limits/has_signaling_NaN">https://en.cppreference.com/w/cpp/types/numeric_limits/has_signaling_NaN</a></li><li><a href="https://stackoverflow.com/questions/18118408/what-is-the-difference-between-quiet-nan-and-signaling-nan">https://stackoverflow.com/questions/18118408/what-is-the-difference-between-quiet-nan-and-signaling-nan</a></li><li><a href="https://ieeexplore.ieee.org/document/8766229">https://ieeexplore.ieee.org/document/8766229</a></li><li><a href="https://docs.python.org/3/library/fractions.html">https://docs.python.org/3/library/fractions.html</a></li><li><a href="https://www.boost.org/doc/libs/1_57_0/libs/rational/rational.html">https://www.boost.org/doc/libs/1_57_0/libs/rational/rational.html</a></li><li><a href="http://h5cpp.org/">http://h5cpp.org/</a></li><li><a href="https://docs.h5py.org/en/stable/mpi.html">https://docs.h5py.org/en/stable/mpi.html</a></li><li><a href="http://www.netlib.org/scalapack/">http://www.netlib.org/scalapack/</a></li><li><a href="https://www.openblas.net/">https://www.openblas.net/</a></li><li><a href="https://github.com/jerryz123/riscv-OpenBLAS">https://github.com/jerryz123/riscv-OpenBLAS</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
      <tag>Architechture</tag>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2203-TFcustom</title>
    <link href="/2022/03/09/2022/2203-TFcustom/"/>
    <url>/2022/03/09/2022/2203-TFcustom/</url>
    
    <content type="html"><![CDATA[<p>实验记录：如何在 Tensorflow 中用 cuda 实现一个自定义的层的环境搭建（好吧我坦白我比较菜，环境就搞了好几天）</p><span id="more"></span><h1 id="Docker-配置"><a href="#Docker-配置" class="headerlink" title="Docker 配置"></a>Docker 配置</h1><p>首先我们最好在一个 docker 环境中进行测试，因为这个问题涉及到 cuda 版本、tf 版本和系统版本的多方调节，在 docker 中便于维护一个稳定独立的实验环境。</p><p>参考的安装文档是：<br><a href="https://github.com/NVIDIA/nvidia-docker">https://github.com/NVIDIA/nvidia-docker</a></p><p>需要使用 Nivdia-Docker, 因为需要在 docker 中调用 GPU。</p><p>详细的安装方式参考了： <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker</a></p><p>参考 <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#installing-on-ubuntu-and-debian">Installing on Ubuntu and Debian</a> 小节。</p><p>完成了这一步之后我们开始参考 TF 的 custom-op 的具体实现方案。</p><h1 id="Custom-OP"><a href="#Custom-OP" class="headerlink" title="Custom OP"></a>Custom OP</h1><p><a href="https://github.com/tensorflow/custom-op">https://github.com/tensorflow/custom-op</a></p><p>Tensorflow 的官方给予了一个模版，不过这个模版的下载花费了不少力气，因为 docker proxy 配置花了不少时间。这里采用实验的 docker 镜像是：custom-op-gpu-ubuntu16</p><p>此外，为了方便对 docker 内的代码进行修改，这里采用将本地的一个仓库目录直接挂载到 docker 里，例如我用如下的操作方式：</p><h2 id="建立模板仓库"><a href="#建立模板仓库" class="headerlink" title="建立模板仓库"></a>建立模板仓库</h2><img src="image1.png" width="80%" height="80%"><p>此处设置模板，之后 clone 到一个 <code>$CUSTOMOP</code> 目录下。</p><h2 id="Docker-准备"><a href="#Docker-准备" class="headerlink" title="Docker 准备"></a>Docker 准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -it -v <span class="hljs-variable">$CUSTOMOP</span>:/custom-op --rm --gpus all chivier-tensorop /bin/bash<br></code></pre></td></tr></table></figure><p>之后文件被复制到了 /custom-op 目录下</p><p>但是这个时候官方的操作指令不能成功，在 GPU 版本的 custom-op 编译的时候会报关于 <code>cuda_helper.h</code> 找不到的错误，这个时候刷要借助一些特殊操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/lib/python3.6/dist-packages/tensorflow/include/<br>mkdir -p third_party/gpus/cuda<br><span class="hljs-built_in">cd</span> third_party/gpus/cuda<br>ln -s /usr/<span class="hljs-built_in">local</span>/cuda/* .<br></code></pre></td></tr></table></figure><p>之后 Makefile 才可以正常工作，在配置完成之后我发现可能 pytorch 可以更好的解决问题。这一部分的 docker 在此封存。</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cuda</tag>
      
      <tag>Tensorflow</tag>
      
      <tag>Deeplearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2202-CudaProgramming</title>
    <link href="/2022/02/20/2022/2202-CudaProgramming/"/>
    <url>/2022/02/20/2022/2202-CudaProgramming/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Requirements"><a href="#1-Requirements" class="headerlink" title="1 Requirements"></a>1 Requirements</h1><span id="more"></span><p>在开始教程之前，简单说明一下下面步骤的需求和测试方法：</p><ol><li>Git: 之后的范例使用 git 作为拉取</li><li>Cuda 11+：使用 11 以上的 cuda 版本确保之后的步骤可以正常使用</li><li>CMake：项目构建采用 cmake 确保多平台可以进行测试和实验</li></ol><p>官方文档的学习曲线比较陡峭，下面整理一些例子帮助快速上手。<br>参考官方手册：Cuda Programming Guide，见附件。此后简称它“手册”。</p><h1 id="2-设备和主机"><a href="#2-设备和主机" class="headerlink" title="2 设备和主机"></a>2 设备和主机</h1><p>首先在这里，我个人想赞美一下 Nvidia 作为国际一流大厂的开源精神和优秀兼容性。现在的 Cuda 支持跨平台、语法兼容。这里语法兼容是指：cuda 是包含 C++17 语法的。直接写的 C++ 代码是可以在机器上直接运行的。</p><p>官方也有一个例子，说明 cuda 和 g++的编译内容可以混合使用：<br><img src="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/graphics/nvcc-options-for-separate-compilation.png" alt="Flow diagram of nvcc options for separate compilation"><br>这一设计大大节约了程序移植的时间。</p><p>在开始编程之前，需要分离我们的传统思维，程序可以不只在 CPU 上运行，还可以在 GPU 上面运行。因此，这里诞生两个概念：Host &amp; Device。<br>实际上，对于大部分的异构计算框架，例如：OpenCL、UPC 等等，都是可以指定 Host &amp; Device 的。这里的 Host 一般代指我们的 CPU, 而 Device 代指我们的 GPU。<br>下面是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__device__ <span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hello</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;gpu hello!\n&quot;</span>);  <br>&#125;  <br>  <br><span class="hljs-function">__host__ <span class="hljs-keyword">void</span> <span class="hljs-title">cpu_hello</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cpu hello!\n&quot;</span>);  <br>&#125;  <br>  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">()</span> </span>&#123;  <br>   gpu_hello();  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&gt;&gt;&gt;();  <br>   cudaDeviceSynchronize();  <br>   cpu_hello();  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>其中我们可以看到三类不同的函数修饰：<br>_<em>device_<em>，__host__，和 __global\</em></em></p><p>在手册 4.2.1 函数类型限定词一节中进行了详细介绍。</p><h2 id="2-1-设备定义"><a href="#2-1-设备定义" class="headerlink" title="2.1 设备定义"></a>2.1 设备定义</h2><ul><li>_<em>device_</em> 是在设备上跑的，<strong>只可以</strong>从设备上调用</li><li>_<em>host_</em> 是在 CPU 上跑的，<strong>只可以</strong>从主机上调用</li><li>_<em>global_</em> 是在设备商跑的，<strong>只可以</strong>从主机上调用</li></ul><img src="image1.png" width="80%" height="80%"><p>如果一个函数不加修饰，默认他是 _<em>device_</em> 函数，正如上面的 main 一样。</p><p>如果一个函数需要同时在 CPU 和 GPU 上都能执行，那么可以同时加上 host 和 device 两个关键字。<br>需要判断具体在那个设备上，可以使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// cuda</span><br><span class="hljs-comment">// cpu</span><br></code></pre></td></tr></table></figure><h2 id="2-2-函数调用"><a href="#2-2-函数调用" class="headerlink" title="2.2 函数调用"></a>2.2 函数调用</h2><p>如果是 device 或者 host 函数，我们可以在恰当的位置直接调用。<br>如果是 global 调用的时候，我们需要用&lt;&lt;&lt;arg1, arg2&gt;&gt;&gt;，去声明我们申请的资源。这个我们在[下一节](#\ 3\ Block\ 和\ Thread) 会说明。</p><h2 id="2-3-函数限制"><a href="#2-3-函数限制" class="headerlink" title="2.3 函数限制"></a>2.3 函数限制</h2><p>由于计算的行为限制，一些特殊的程序行为在 cuda 代码中是被严格禁止的，例如：</p><ol><li>_<em>host_</em> 和 _<em>global_</em> 不支持递归</li><li>_<em>global_</em> 返回值要求是 void</li><li>调用 GPU 的函数声明和定义不要分离，写在同一个文件里</li></ol><p>更多限制见手册，不过上述两条基本包含了日常开发的需要。</p><p>这里额外补充一点，是因为特殊的需要说明一下。<br>关于上述的第三点，我们尽管可以使用特殊的方法，例如CUDA_SEPARABLE_COMPILATION等方法可以分离定义，但是会有无法内联等问题对性能产生巨大影响。处于这些原因，我个人建议<strong>global__和__device</strong> <strong><u>声明和调用他们的地方</u></strong> 最好写到同一个文件里。</p><h2 id="2-4-Cuda-Version-amp-GPU-Version"><a href="#2-4-Cuda-Version-amp-GPU-Version" class="headerlink" title="2.4 Cuda Version &amp; GPU Version"></a>2.4 Cuda Version &amp; GPU Version</h2><p><a href="https://en.wikipedia.org/wiki/CUDA">https://en.wikipedia.org/wiki/CUDA</a></p><p>这个部分一般来说不太需要关心，但是上面给出一个链接用来说明各个版本的 GPU 的 compute capacity 的问题，每张 GPU 都有一个属于自己的版本号，版本号是向下兼容的，即高版本号的卡可以跑任何版本号低于自己卡上编译出来的程序。用尽可能高版本的卡的特性去编译程序有利于充分发挥程序的性能。</p><p>在 <code>CMakeLists.txt</code> 中设置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span> (CMAKE_CUDA_ARCHITECTURES <span class="hljs-number">61</span>)<br></code></pre></td></tr></table></figure><p>其中 61 是 1080 的版本号，在表格中有写出，也可以使用程序输出：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmake">  <br>__device__ void gpu_hello() &#123;  <br>   <span class="hljs-comment">#ifdef __CUDA_ARCH__  </span><br>       printf(<span class="hljs-string">&quot;%d\n&quot;</span>, __CUDA_ARCH__);  <br>   <span class="hljs-comment">#endif  </span><br>&#125;  <br>  <br>__global__ void kernel() &#123;  <br>   gpu_hello();  <br>&#125;  <br>  <br>int main() &#123;  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&gt;&gt;&gt;();  <br>   cudaDeviceSynchronize();  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>用来检测当前的版本是否正确，因为如果在 <code>CMakeLists.txt</code> 中不指明，那么机器会默认使用最低版本的驱动，也就是 520 版本的进行编译和后续优化。这显然不是我们希望的。</p><p>这里有一个我之前收藏的小文，介绍了更多的硬件细节：</p><p><a href="https://zhuanlan.zhihu.com/p/394352476">https://zhuanlan.zhihu.com/p/394352476</a></p><h2 id="2-5-关于设备上的输出问题"><a href="#2-5-关于设备上的输出问题" class="headerlink" title="2.5 关于设备上的输出问题"></a>2.5 关于设备上的输出问题</h2><p>如果我们在 device 或者 global 的代码里调用了 printf 等输出函数，这个时候需要使用前面已经多次使用过的 <code>cudaDeviceSynchronize()</code> 才能生效。因为处于高性能的需求，我们的 CPU 代码执行和 GPU 代码执行是异步执行的。所以我们调用 GPU 代码之后，CPU 程序实际上是会继续执行的。如果要等上面的 GPU 代码执行完成，需要在此处同步等待一下。<br>（可以尝试把之前程序的 <code>cudaDeviceSynchronize()</code> 删除进行一个小小的测试）<br>此外 cout 等流输出在 cuda 中是禁止的，因为流输出里包含了过多的函数行为和复杂特性，Nvidia 的工程师暂时还没有实现这些特性。</p><h1 id="3-Block-和-Thread"><a href="#3-Block-和-Thread" class="headerlink" title="3 Block 和 Thread"></a>3 Block 和 Thread</h1><p>上面一节我们提到，如果我们调用 global 声明的函数的时候需要说明计算资源。这里我们解释一下 &lt;&lt;&lt;arg1, arg2&gt;&gt;&gt; 中两个参数的含义。</p><h2 id="3-1-从例子开始"><a href="#3-1-从例子开始" class="headerlink" title="3.1 从例子开始"></a>3.1 从例子开始</h2><p>首先先从下面这个例子说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Block %d of %d, Thread %d of %d\n&quot;</span>, blockIdx.x, gridDim.x, threadIdx.x, blockDim.x);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>&gt;&gt;&gt;();  <br>   cudaDeviceSynchronize();  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">Block 0 of 4, Thread 0 of 3  <br>Block 0 of 4, Thread 1 of 3  <br>Block 0 of 4, Thread 2 of 3  <br>Block 2 of 4, Thread 0 of 3  <br>Block 2 of 4, Thread 1 of 3  <br>Block 2 of 4, Thread 2 of 3  <br>Block 1 of 4, Thread 0 of 3  <br>Block 1 of 4, Thread 1 of 3  <br>Block 1 of 4, Thread 2 of 3  <br>Block 3 of 4, Thread 0 of 3  <br>Block 3 of 4, Thread 1 of 3  <br>Block 3 of 4, Thread 2 of 3<br></code></pre></td></tr></table></figure><p>Cuda 有两个层级的并行，一个是 block 级别，一个是 thread 级别。<br>&lt;&lt;&lt;arg1, arg2&gt;&gt;&gt; 中：</p><ul><li>Arg1 = block 数目 = <code>gridDim.x</code></li><li>Arg2 = 每个 block 中 thread 的数目 = <code>blockDim.x</code><br>（我曾经反对首字母小写的驼峰命名，后来被 Nvidia 教育了）</li></ul><h2 id="3-2-Block-和-Thread-的设计意义"><a href="#3-2-Block-和-Thread-的设计意义" class="headerlink" title="3.2 Block 和 Thread 的设计意义"></a>3.2 Block 和 Thread 的设计意义</h2><p>为什么需要进行这两级的设计呢？<br>其实这个和 GPU 的硬件设计方式有关系。我们的代码直接和硬件设计相关。</p><p>首先从命名上不难看出，GPU 的设计是为了进行 2D 和 3D 的网格类型计算。对应的应用就是：图形图像处理、粒子引擎模拟、网格算法计算。我们在计算是经常需要 “切分大数据，进行分发计算，最后再进行收集”。也就是常说的 Scatter-and-Gather, 或者 Fork-and-Merge。</p><p>现在的 GPU 架构中：</p><ul><li>一个 GPU = 多个 Streaming Multiprocessor (SM) + cache 组成</li><li>一个 SM = Streaming Processor（SP）+ cache 组成</li><li>SM 用于处理 block</li><li>SP 用于处理 thread</li></ul><p>很大一方面理由就是为了更加充分利用多级缓存的优势。</p><h2 id="3-3-Flatten-Mode-和-Dimension-Mode"><a href="#3-3-Flatten-Mode-和-Dimension-Mode" class="headerlink" title="3.3 Flatten Mode 和 Dimension Mode"></a>3.3 Flatten Mode 和 Dimension Mode</h2><p>由于 Block 和 Thread 的两级设计导致我们的划分可能存在一定的困难，有一个简单粗暴的方法可以直接把他们压平。直接把上面那个例子进行压平改写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d of %d\n&quot;</span>, blockIdx.x * blockDim.x + threadIdx.x, blockDim.x * gridDim.x);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>&gt;&gt;&gt;();  <br>   cudaDeviceSynchronize();  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">Thread 0 of 12  <br>Thread 1 of 12  <br>Thread 2 of 12  <br>Thread 6 of 12  <br>Thread 7 of 12  <br>Thread 8 of 12  <br>Thread 3 of 12  <br>Thread 4 of 12  <br>Thread 5 of 12  <br>Thread 9 of 12  <br>Thread 10 of 12  <br>Thread 11 of 12<br></code></pre></td></tr></table></figure><p>由于 cuda 的适用范围，还有另外一种模式的其实在 HPC 应用中更加受到欢迎和广泛使用，一般称为 Dimension Mode。</p><p>首先展示一下结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Block (%d,%d,%d) of (%d,%d,%d), Thread (%d,%d,%d) of (%d,%d,%d)\n&quot;</span>,  <br>          blockIdx.x, blockIdx.y, blockIdx.z,  <br>          gridDim.x, gridDim.y, gridDim.z,  <br>          threadIdx.x, threadIdx.y, threadIdx.z,  <br>          blockDim.x, blockDim.y, blockDim.z);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   kernel&lt;&lt;&lt;dim3(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), dim3(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)&gt;&gt;&gt;();  <br>   cudaDeviceSynchronize();  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>首先看三维的例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">Block (0,0,0) of (2,1,1), Thread (0,0,0) of (2,2,2)  <br>Block (0,0,0) of (2,1,1), Thread (1,0,0) of (2,2,2)  <br>Block (0,0,0) of (2,1,1), Thread (0,1,0) of (2,2,2)  <br>Block (0,0,0) of (2,1,1), Thread (1,1,0) of (2,2,2)  <br>Block (0,0,0) of (2,1,1), Thread (0,0,1) of (2,2,2)  <br>Block (0,0,0) of (2,1,1), Thread (1,0,1) of (2,2,2)  <br>Block (0,0,0) of (2,1,1), Thread (0,1,1) of (2,2,2)  <br>Block (0,0,0) of (2,1,1), Thread (1,1,1) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (0,0,0) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (1,0,0) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (0,1,0) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (1,1,0) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (0,0,1) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (1,0,1) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (0,1,1) of (2,2,2)  <br>Block (1,0,0) of (2,1,1), Thread (1,1,1) of (2,2,2)<br></code></pre></td></tr></table></figure><p>再来给出一个二维的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Block (%d,%d,%d) of (%d,%d,%d), Thread (%d,%d,%d) of (%d,%d,%d)\n&quot;</span>,  <br>          blockIdx.x, blockIdx.y, blockIdx.z,  <br>          gridDim.x, gridDim.y, gridDim.z,  <br>          threadIdx.x, threadIdx.y, threadIdx.z,  <br>          blockDim.x, blockDim.y, blockDim.z);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   kernel&lt;&lt;&lt;dim3(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>), dim3(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)&gt;&gt;&gt;();  <br>   cudaDeviceSynchronize();  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>结果最后一个维度都是 0, 我们使用结果的时候不使用 z 维度即可</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">Block (1,2,0) of (2,3,1), Thread (0,0,0) of (2,1,1)  <br>Block (1,2,0) of (2,3,1), Thread (1,0,0) of (2,1,1)  <br>Block (0,2,0) of (2,3,1), Thread (0,0,0) of (2,1,1)  <br>Block (0,2,0) of (2,3,1), Thread (1,0,0) of (2,1,1)  <br>Block (0,1,0) of (2,3,1), Thread (0,0,0) of (2,1,1)  <br>Block (0,1,0) of (2,3,1), Thread (1,0,0) of (2,1,1)  <br>Block (1,0,0) of (2,3,1), Thread (0,0,0) of (2,1,1)  <br>Block (1,0,0) of (2,3,1), Thread (1,0,0) of (2,1,1)  <br>Block (0,0,0) of (2,3,1), Thread (0,0,0) of (2,1,1)  <br>Block (0,0,0) of (2,3,1), Thread (1,0,0) of (2,1,1)  <br>Block (1,1,0) of (2,3,1), Thread (0,0,0) of (2,1,1)  <br>Block (1,1,0) of (2,3,1), Thread (1,0,0) of (2,1,1)<br></code></pre></td></tr></table></figure><h2 id="3-4-如何设置计算资源？"><a href="#3-4-如何设置计算资源？" class="headerlink" title="3.4 如何设置计算资源？"></a>3.4 如何设置计算资源？</h2><p>上面说了我们 GPU 并行的时候有两个层级，第一个是 Block 级别，第二个是 Thread 级别。为此我们需要设置两个级别的数目。</p><p>首先我们先看我们最多可以用多少资源。使用 cuda samples 中的 <a href="https://github.com/nvidia/cuda-samples">deviceQuery</a> （Make 直接编译整个 cuda-samples 项目可以找到）</p><img src="image2.png" width="80%" height="80%"><p>此程序会列举机器上的所有设备，列举设备之后可以展示出机器的所有详细信息。这里我们看到了关键的几行信息：</p><p>Maximum number of threads per block<br>以及<br>Maximum dimension size of a thread block</p><p>前者比较好理解，我们看看后一个 dimension 的含义，首先先列举一下<a href="https://forums.developer.nvidia.com/t/maximum-number-of-threads-on-thread-block/46392/2">官方论坛</a>的说辞：</p><blockquote><p>There are multiple limits. All must be satisfied.</p><ol><li> The maximum number of threads in the block is limited to 1024. This is the product of whatever your threadblock dimensions are (x_y_z). For example (32,32,1) creates a block of 1024 threads. (33,32,1) is not legal, since <code>33*32*1</code> &gt; 1024.</li><li> The maximum x-dimension is 1024. (1024, 1, 1) is legal. (1025, 1, 1) is not legal.</li><li> The maximum y-dimension is 1024. (1, 1024, 1) is legal. (1, 1025, 1) is not legal.</li><li> The maximum z-dimension is 64. (1, 1, 64) is legal. (2, 2, 64) is also legal. (1, 1, 65) is not legal.</li></ol></blockquote><p>配合论坛中的内容，这里也很好理解了。</p><p>结合了上面的例子，cuda 的变成已经变得相对直观，用来优化一些简单的循环已经可以实现了。这里可以概括一下：</p><ol><li>cuda Block 级别相当于 C++ 线程，数目可以设置比较大，调度依靠 GPU ，方式类似于 CPU 调度 threads</li><li>cuda Thread 级别相当于 SIMD，有数目上限，受限于 cuda core 的数目和一些维度参数</li></ol><h1 id="4-变量行为"><a href="#4-变量行为" class="headerlink" title="4 变量行为"></a>4 变量行为</h1><p>简单的例子说明完成，下面开始介绍每一个具体的函数内部，我们程序的行为。</p><h2 id="4-1-显存和内存"><a href="#4-1-显存和内存" class="headerlink" title="4.1 显存和内存"></a>4.1 显存和内存</h2><p>在使用 GPU 编程（也有可能在玩游戏）的时候，有一个词时常出现：显存。<br>这个词已经暗示我们 GPU 的内存分布和 CPU 的内存分布实际上是不一样的。我们在设备上的内容、和主机上的内容直接需要一些同步机制去同步。</p><p>首先一图概览接下来的内容：</p><img src="image3.png" width="80%" height="80%"><p>简述一下：</p><ol><li>显存和内存独立管理各自的 DRAM</li><li>互相调用树枝需要使用 cudaMemcpy</li><li>Unified 统一管理模式可以解决管理问题，但是代价是需要额外的时间开销</li></ol><p>下面配合具体的例子说明。</p><h2 id="4-2-显存内存不能互相调用"><a href="#4-2-显存内存不能互相调用" class="headerlink" title="4.2 显存内存不能互相调用"></a>4.2 显存内存不能互相调用</h2><h3 id="4-2-1-设备调用内存失败"><a href="#4-2-1-设备调用内存失败" class="headerlink" title="4.2.1 设备调用内存失败"></a>4.2.1 设备调用内存失败</h3><p>我们复习一下在内存中如何申请空间，在 C/C++ 中，我们一般会使用一对函数： malloc &amp; free 用于一块内存的申请与释放。</p><p>下面给出一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;  <br>   arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">while</span> (arr[index] != <span class="hljs-number">0</span>) &#123;  <br>       arr[<span class="hljs-number">0</span>] += arr[index];  <br>       index++;  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> *a;  <br>   a = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>);  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">for</span> (index = <span class="hljs-number">1</span>; index &lt;= <span class="hljs-number">10</span>; ++index) &#123;  <br>       a[index] = index;  <br>   &#125;  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&gt;&gt;&gt;(a);  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a[<span class="hljs-number">0</span>]);  <br>   cudaDeviceSynchronize();  <br>   <span class="hljs-built_in">free</span>(a);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-主机调用显存失败"><a href="#4-2-2-主机调用显存失败" class="headerlink" title="4.2.2 主机调用显存失败"></a>4.2.2 主机调用显存失败</h3><p>这里首先说明一下 cuda 是如何展示显存的。<br>在介绍之前，先需要介绍一下两个函数接口：cudaMalloc &amp; cudaFree</p><p>这里需要说明的是 cudaMalloc 的用法和 malloc 差异极大：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">cudaError_t <span class="hljs-title">cudaMalloc</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>** ptr, <span class="hljs-keyword">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>配合下图理解：</p><img src="image4.png" width="80%" height="80%"><p>我们申请的是一个 “指向 GPU 数据指针的指针”。</p><p>我们申请到的空间是在一个二级指针上存储，下面举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;  <br>   arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">while</span> (arr[index] != <span class="hljs-number">0</span>) &#123;  <br>       arr[<span class="hljs-number">0</span>] += arr[index];  <br>       index++;  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> *a;  <br>   cudaMalloc(&amp;a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>);  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">for</span> (index = <span class="hljs-number">1</span>; index &lt;= <span class="hljs-number">10</span>; ++index) &#123;  <br>       a[index] = index;  <br>   &#125;  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&gt;&gt;&gt;(a);  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a[<span class="hljs-number">0</span>]);  <br>   cudaDeviceSynchronize();  <br>   cudaFree(a);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-cuda-Error-Handling"><a href="#4-2-3-cuda-Error-Handling" class="headerlink" title="4.2.3 cuda Error Handling"></a>4.2.3 cuda Error Handling</h3><p>上面两个失败的例子再次说明了内存和显存不能“直接”混合使用。（下面会说一种支持混合使用的技术）<br>前者结果是 0, 后者结果是段错误。导致的原因是因为内存地址和显存地址不是直接统一的。</p><p>为了方便调试，cuda 提供了一系列的纠错调试机制，在前面的程序中，用到的：<code>cudaMalloc</code>，<code>cudaFree</code>，<code>cudaDeviceSynchronize</code> 都有返回类型便于我们调试，返回类型是一个 <code>cudaError_t</code> 的没枚举类型，可以被 printf 直接输出。</p><p>但是输出了我们是不能理解函数的具体含义的，也不方便我们进行 debug。这里 cuda samples 里面提供了一个非常好的例子，我们可以直接引用 <code>helper_cuda.h</code> 头文件解决问题。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)  <br>  <br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)  <br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)  <br><span class="hljs-keyword">set</span>(CMAKE_CUDA_ARCHITECTURES <span class="hljs-number">61</span>)  <br>  <br><span class="hljs-keyword">project</span>(devices LANGUAGES CXX CUDA)  <br>  <br><span class="hljs-keyword">add_executable</span>(hello hello.cu)  <br><span class="hljs-keyword">target_include_directories</span>(hello PUBLIC /usr/local/cuda/samples/common/inc)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;  <br>   arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">while</span> (arr[index] != <span class="hljs-number">0</span>) &#123;  <br>       arr[<span class="hljs-number">0</span>] += arr[index];  <br>       index++;  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> *a;  <br>   a = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>);  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">for</span> (index = <span class="hljs-number">1</span>; index &lt;= <span class="hljs-number">10</span>; ++index) &#123;  <br>       a[index] = index;  <br>   &#125;  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&gt;&gt;&gt;(a);  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>]);  <br>   <span class="hljs-built_in">free</span>(a);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了我们的 debug 工作，此时输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">0<br>CUDA error at /home/chivier/Projects/cudatest/08-errhandle/hello.cu:23 code=700(cudaErrorIllegalAddress) &quot;cudaDeviceSynchronize()&quot;<br></code></pre></td></tr></table></figure><p>这里的 IllegalAddress 就说明了地址无法正常使用。</p><h3 id="4-2-5-cudaMemcpy"><a href="#4-2-5-cudaMemcpy" class="headerlink" title="4.2.5 cudaMemcpy"></a>4.2.5 cudaMemcpy</h3><p>那么正确的做法是什么呢？我们如果需要通信两个地方的内存，需要借助 cudaMemcpy 函数。</p><p>下面是正确的改正方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;  <br>   arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">while</span> (arr[index] != <span class="hljs-number">0</span>) &#123;  <br>       arr[<span class="hljs-number">0</span>] += arr[index];  <br>       index++;  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> *a;  <br>   a = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>);  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">for</span> (index = <span class="hljs-number">1</span>; index &lt;= <span class="hljs-number">10</span>; ++index) &#123;  <br>       a[index] = index;  <br>   &#125;  <br>  <br>   <span class="hljs-keyword">int</span> *cuda_a;  <br>   cudaMalloc(&amp;cuda_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>);  <br>   cudaMemcpy(cuda_a, a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>, cudaMemcpyHostToDevice);  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&gt;&gt;&gt;(cuda_a);  <br>   cudaMemcpy(a, cuda_a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>, cudaMemcpyDeviceToHost);  <br>  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>]);  <br>   <span class="hljs-built_in">free</span>(a);  <br>   cudaFree(cuda_a);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">55<br></code></pre></td></tr></table></figure><p>这个时候我们可以总结一般的 cuda 变成行为方法：</p><ol><li>Generate Data/Read Data</li><li>Copy: Host-&gt;Device</li><li>Calculate</li><li>Copy: Device-&gt;Host</li><li>Print out</li></ol><p>这里说明一下：<br>cudaMemcpy可以自动实现同步工作，可以省去cudaDeviceSynchronize。</p><h3 id="4-2-4-Unified-Memory"><a href="#4-2-4-Unified-Memory" class="headerlink" title="4.2.4 Unified Memory"></a>4.2.4 Unified Memory</h3><p>首先先给出官方的一份博客：<a href="https://developer.nvidia.com/blog/unified-memory-in-cuda-6/">Unified Memory</a></p><p>我们把上面的例子直接改写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span> </span>&#123;  <br>   arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">while</span> (arr[index] != <span class="hljs-number">0</span>) &#123;  <br>       arr[<span class="hljs-number">0</span>] += arr[index];  <br>       index++;  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> *a;  <br>   checkCudaErrors(cudaMallocManaged(&amp;a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">12</span>));  <br>   <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <br>   <span class="hljs-keyword">for</span> (index = <span class="hljs-number">1</span>; index &lt;= <span class="hljs-number">10</span>; ++index) &#123;  <br>       a[index] = index;  <br>   &#125;  <br>  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&gt;&gt;&gt;(a);  <br>      <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>]);  <br>   cudaFree(a);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>Unified Memory 申请的空间在 Host 和 Device 上都直接可以正常使用。节省代码，但是代价也是随之而来的，我们需要使用一定的性能作为代价。这个有时是劣势，但有些时候这种方法反而可以达到优化的效果。</p><h2 id="4-3-变量传输和计算"><a href="#4-3-变量传输和计算" class="headerlink" title="4.3 变量传输和计算"></a>4.3 变量传输和计算</h2><p>这里我们简单介绍一下一般的循环模式。</p><h3 id="4-3-1-grid-stride-loop"><a href="#4-3-1-grid-stride-loop" class="headerlink" title="4.3.1 grid-stride loop"></a>4.3.1 grid-stride loop</h3><p>在 cuda 中，并行的模式有一点特殊，我们称为 grid-stride loop。</p><p>简单解释一下：</p><p>如果我们希望对一个循环进行并行，直观的想法就是分配足够多的线程执行他。如果循环次数少于 1024, 我们完全可以使用一个 block, 里面分配 <u>循环次数对应的线程数</u> 从而达到目的。但是这里不是我们希望看到的结果，因为我们不能保证我们的循环次数一定小于 1024。我们用下面的例子说明我们是如何用 cuda 执行循环的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = threadIdx.x; i &lt; n; i += blockDim.x) &#123;  <br>       arr[i] = i;  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> n = <span class="hljs-number">114</span>;  <br>   <span class="hljs-keyword">int</span> *arr;  <br>   checkCudaErrors(cudaMallocManaged(&amp;arr, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)));  <br>  <br>   kernel&lt;&lt;&lt;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&gt;&gt;&gt;(arr, n);  <br>  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arr[%d]: %d\n&quot;</span>, i, arr[i]);  <br>   &#125;  <br>  <br>   cudaFree(arr);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>由于 cuda 的大显存设计，我们大可以将一个数组很大一块连续块装入，而且 cuda 的计算机制保证了 blockDim 不会太大（1024）。所以这里尽管是跳步加，也不会过多的伤害到空间局部性。在不同的设备上，我们可以通过直接调整 blockDim 进行性能的测试，从而调优。Debug 的时候也可以直接把 gridDim 改成 1 从而进行便捷的调试。此外，这种写法的逻辑非常好整理，也方便进行记忆。为此这种方法被人们广泛使用。</p><p>如果我们需要启用多个 Block, 那么我们面临一个新的问题，如果循环次数不是 blockDim 的整数倍我们如何处理？<br>这里的办法是非常国际通用的，大家广泛的使用如下写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> loopCount = .....;<br><br>....<br><br><span class="hljs-keyword">int</span> block_dim = ...;<br><span class="hljs-keyword">int</span> grid_dim = (loopCount - <span class="hljs-number">1</span>) / block_dim + <span class="hljs-number">1</span>;<br><br>...<br><br>call_kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;();<br></code></pre></td></tr></table></figure><p>好文推荐（示意图很好）： <a href="http://alexminnaar.com/2019/08/02/grid-stride-loops.html">http://alexminnaar.com/2019/08/02/grid-stride-loops.html</a></p><p>官方博客中还推荐了另外一种非常灵活的写法：<br><a href="https://developer.nvidia.com/blog/cuda-pro-tip-write-flexible-kernels-grid-stride-loops/">https://developer.nvidia.com/blog/cuda-pro-tip-write-flexible-kernels-grid-stride-loops/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">saxpy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span> a, <span class="hljs-keyword">float</span> *x, <span class="hljs-keyword">float</span> *y)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; i &lt; n; i += blockDim.x * gridDim.x) &#123;<br>y[i] = a * x[i] + y[i];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相当与我们的 Flatten Mode 的编程方法，确保我们不会落下数据没有循环。</p><p>虽说大部分 C++17 的代码 cuda 可以跑起来，但是 STL 容器 cuda 并没有很好的适配和实现，如果需要用容器，我们需要自己定义 allocator。这里推荐一个 gist： <a href="https://gist.github.com/CommitThis/1666517de32893e5dc4c441269f1029a">https://gist.github.com/CommitThis/1666517de32893e5dc4c441269f1029a</a></p><p>其中定义了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unified_alloc</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-keyword">using</span> pointer = value_type*;<br>    <span class="hljs-keyword">using</span> size_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>;<br><br>    unified_alloc() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    unified_alloc(unified_alloc&lt;U&gt; <span class="hljs-keyword">const</span>&amp;) <span class="hljs-keyword">noexcept</span> &#123;&#125;<br><br>    auto allocate(size_type n, const void* = 0) -&gt; value_type* &#123;<br>        value_type * tmp;<br>        <span class="hljs-keyword">auto</span> error = cudaMallocManaged((<span class="hljs-keyword">void</span>**)&amp;tmp, n * <span class="hljs-keyword">sizeof</span>(T));<br>        <span class="hljs-keyword">if</span> (error != cudaSuccess) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error &#123; cudaGetErrorString(error) &#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    auto deallocate(pointer p, size_type n) -&gt; void &#123;<br>        <span class="hljs-keyword">if</span> (p) &#123;<br>            <span class="hljs-keyword">auto</span> error = cudaFree(p);<br>            <span class="hljs-keyword">if</span> (error != cudaSuccess) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error &#123; cudaGetErrorString(error) &#125;;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果此时我们需要定义 vector, 只需要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>, unified_alloc&lt;<span class="hljs-keyword">int</span>&gt;&gt; arr(length);<br></code></pre></td></tr></table></figure><p>即可。</p><p>这里vector即使定义成功了，我们使用的时候还是会有一些问题，因为__global__函数的参数限制问题，我们只能传递 arr.data() 从而获取类似数组地址的方法传递参数。综上所属，楞写 STL 不是一个好办法，下面的 thrust 中会介绍一些靠谱的办法。</p><h3 id="4-3-2-算子传输"><a href="#4-3-2-算子传输" class="headerlink" title="4.3.2 算子传输"></a>4.3.2 算子传输</h3><p>在 cuda 编程的时候，经常遇到下面这个问题：</p><p>对于很多类似的函数，我们只需要更换其中的一个小函数即可，例如计算</p><p>$$<br>\sum_{i=0}^n Sin(a_i),;\sum_{i=0}^n Cos(a_i),;\sum_{i=0}^n Tan(a_i),;…<br>$$</p><p>很多时候只需要换一个算子，我们不需要重复构造很多个函数（减少函数数量其实是有一定好处的，对于模式类似的函数，如果适当利用 lambda 算子，我们可以减少编译器的编译负担）</p><p>这种时候我们可以采用两种方法。</p><p>第一种就是 lambda 算子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>&gt;</span>  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func func)</span> </span>&#123;  <br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;  <br>        i &lt; n; i += blockDim.x * gridDim.x) &#123;  <br>       func(i);  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;  <br>   <span class="hljs-keyword">int</span> *arr;  <br>  <br>   cudaMallocManaged(&amp;arr, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));  <br>  <br>   <span class="hljs-keyword">int</span> block_dim = <span class="hljs-number">128</span>;  <br>   <span class="hljs-keyword">int</span> grid_dim = (n - <span class="hljs-number">1</span>) / block_dim + <span class="hljs-number">1</span>;  <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;  <br>       arr[i] = i;  <br>   &#125;);  <br>      <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %f\n&quot;</span>, i, sinf(arr[i]));  <br>   &#125;);  <br>  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>  <br>   <span class="hljs-comment">// Compare  </span><br>   <span class="hljs-comment">// for(int index = 0; index &lt; n; ++index) &#123;  </span><br>   <span class="hljs-comment">//    printf(&quot;%d, %f\n&quot;, index, sinf(index));  </span><br>   <span class="hljs-comment">//&#125;  </span><br>  <br>   cudaFree(arr);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>注意 lambda 算子也是要在 GPU 上执行的，所以需要加上 _<em>device_</em> 进行修饰。</p><p>第二种方法就是使用类似于函数指针的方式。不过 cuda 中函数指针的定义非常严格：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>&gt;</span>  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> n, Func func)</span> </span>&#123;  <br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;  <br>        i &lt; n; i += blockDim.x * gridDim.x) &#123;  <br>       func(arr, i);  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">funcop1</span> &#123;</span>  <br>   <span class="hljs-function">__device__ <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> i)</span> </span>&#123;  <br>       arr[i] = i;  <br>   &#125;  <br>&#125;;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">funcop2</span> &#123;</span>  <br>   <span class="hljs-function">__device__ <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> i)</span> </span>&#123;  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %f\n&quot;</span>, arr[i], sinf(arr[i]));  <br>   &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;  <br>   <span class="hljs-keyword">int</span> *arr;  <br>  <br>   cudaMallocManaged(&amp;arr, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));  <br>  <br>   <span class="hljs-keyword">int</span> block_dim = <span class="hljs-number">128</span>;  <br>   <span class="hljs-keyword">int</span> grid_dim = (n - <span class="hljs-number">1</span>) / block_dim + <span class="hljs-number">1</span>;  <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(arr, n, funcop1&#123;&#125;);  <br>      <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(arr, n, funcop2&#123;&#125;);  <br>  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>  <br>   <span class="hljs-comment">// Compare  </span><br>   <span class="hljs-comment">// for(int index = 0; index &lt; n; ++index) &#123;  </span><br>   <span class="hljs-comment">//    printf(&quot;%d, %f\n&quot;, index, sinf(index));  </span><br>   <span class="hljs-comment">//&#125;  </span><br>  <br>   cudaFree(arr);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>由于地址类型在传递时，CPU 和 GPU 不一致，所以需要用结构体封装一层</li><li>结构体中的函数是在 GPU 上计算，需要用 device 修饰</li><li>结构体中函数需要用 operator () 修饰</li></ol><p>到这里，基础部分已经基本结束。</p><h2 id="4-4-高级计算行为"><a href="#4-4-高级计算行为" class="headerlink" title="4.4 高级计算行为"></a>4.4 高级计算行为</h2><h3 id="4-4-1-thrust"><a href="#4-4-1-thrust" class="headerlink" title="4.4.1 thrust"></a>4.4.1 thrust</h3><p>之前我们提及过，在 cuda 中无法使用 C++ STL 进行编程，为此我们需要使用 Nviida 提供的黑科技： thrust。</p><p>首先简单介绍一下，thrust 库被称为： Template library for CUDA，自从 cuda 4.0 就开始有了（甚至比 unified Memory 还早是我没想到的）。主要目的是对标 C++ STL。简化 HPC 编程。</p><h4 id="4-4-1-1-vector-对标"><a href="#4-4-1-1-vector-对标" class="headerlink" title="4.4.1.1 vector 对标"></a>4.4.1.1 vector 对标</h4><p>C++ STL 中 vector 容器属实是一个使用主力了，在 thrust 中我们也有对应的实现，分别为：<code>universal_vector</code>，<code>host_vector</code>，<code>device_vector</code>。他们的用途根据名字应该已经可以猜到了。使用 thrust 之后，我们可以直接使用 <code>=</code> 进行数值拷贝。Cuda 中已经完成了这一部分的重载工作。</p><p>下面列举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>&gt;</span>  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func func)</span> </span>&#123;  <br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;  <br>        i &lt; n; i += blockDim.x * gridDim.x) &#123;  <br>       func(i);  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> n = <span class="hljs-number">65536</span>;  <br>  <br>   <span class="hljs-keyword">int</span> block_dim = <span class="hljs-number">128</span>;  <br>   <span class="hljs-keyword">int</span> grid_dim = (n - <span class="hljs-number">1</span>) / block_dim;  <br>      <br>   <span class="hljs-function">thrust::host_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">x_host</span><span class="hljs-params">(n)</span></span>;  <br>   <span class="hljs-function">thrust::host_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">y_host</span><span class="hljs-params">(n)</span></span>;  <br>  <br>   thrust::generate(x_host.begin(), x_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">3.0</span>;&#125;);  <br>   thrust::generate(y_host.begin(), y_host.end(), []&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::rand() / <span class="hljs-number">11.0</span>;&#125;);  <br>  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f + %f = \n&quot;</span>, x_host[<span class="hljs-number">0</span>], y_host[<span class="hljs-number">0</span>]);  <br>  <br>   <span class="hljs-function">thrust::device_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">x_dev</span><span class="hljs-params">(n)</span></span>;  <br>   <span class="hljs-function">thrust::device_vector&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">y_dev</span><span class="hljs-params">(n)</span></span>;  <br>   x_dev = x_host;  <br>   y_dev = y_host;  <br>  <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [x = x_dev.data(), y = y_dev.data()] __device__ (<span class="hljs-keyword">int</span> index)&#123;  <br>       x[index] = x[index] + y[index];  <br>   &#125;);  <br>  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>   x_host = x_dev;  <br>  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, x_host[<span class="hljs-number">0</span>]);  <br>  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">601429824.000000 + 151421216.000000 =   <br>752851072.000000<br></code></pre></td></tr></table></figure><p>本程序成功的展示了 thrust_vector 之间互相 copy 的行为，这里辅助使用了一下 thrust :: generate 用于生成随机序列。（这就是前一节花篇幅辅助介绍算子传递的原因，lambda 算子在 thrust 中会有广泛的应用，尽管这是 C++20 才应该有的特性，但是很多编译器早早的提供了支持「赞美 LLVM」。）</p><h4 id="4-4-1-2-other-thrusts"><a href="#4-4-1-2-other-thrusts" class="headerlink" title="4.4.1.2 other thrusts"></a>4.4.1.2 other thrusts</h4><p>Thrust 中还有很多和 STL 对标的内容，例如 For_each、sort、count_if 这些都是非常常用的 thrust 函数，使用方法和 generate 几乎一致，没有过多差别。</p><p><a href="https://thrust.github.io/doc/namespacethrust.html">https://thrust.github.io/doc/namespacethrust.html</a></p><p>这里个人推荐在上面的网页中查找 thrust 的 API。Doxygen 提供了详细的文档管理。我们可以查到具体的使用方法和相对应的例子。</p><h3 id="4-4-2-atomic"><a href="#4-4-2-atomic" class="headerlink" title="4.4.2 atomic"></a>4.4.2 atomic</h3><p>说道这个问题，很容易会和生产-消费的问题联系到一起。这里先列举一个翻车的例子：</p><p>(下面这个例子中顺便引入了一个 trick, 在 cuda 中我们是可以使用全局变量的，但是和我们管理内存的方式是一样的，一个全局变量也是有“位置”的，我们在 GPU 和 CPU 上的全局变量需要使用 cudaMemcpyFromSymbol 进行拷贝)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>__device__ <span class="hljs-keyword">float</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>&gt;</span><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func func)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;<br>         i &lt; n; i += blockDim.x * gridDim.x) &#123;<br>        func(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">65536</span>;<br>    <span class="hljs-keyword">int</span> *arr;<br>    <span class="hljs-keyword">float</span> result = <span class="hljs-number">0</span>;<br><br>    cudaMallocManaged(&amp;arr, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br><br>    <span class="hljs-keyword">int</span> block_dim = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">int</span> grid_dim = (n - <span class="hljs-number">1</span>) / block_dim;<br>    kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;<br>        arr[i] = i;<br>    &#125;);<br>    <br>    <br>    kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;<br>        sum += sinf(arr[i]);<br>    &#125;);<br><br>    cudaMemcpyFromSymbol(&amp;result, sum, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">0</span>, cudaMemcpyDeviceToHost);<br>    checkCudaErrors(cudaDeviceSynchronize());<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, result);<br><br>    <span class="hljs-comment">// Compare</span><br>    result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; n; ++index) &#123;<br>        result += sinf(index);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, result);<br><br>    cudaFree(arr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子非常好理解，是我们之前一个 lambda 例子的微微改进，我们之所以说明这个例子是因为这个程序行为非常“鬼畜”。每次执行结果都可能不同。那么问题在哪里呢？</p><p>在于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sum += sinf (arr[i])<br></code></pre></td></tr></table></figure><p>操作实际上不是原子的。我们的不同的 i 会抢占对于 sum 的使用。</p><p>修正方法也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br>__device__ <span class="hljs-keyword">float</span> sum = <span class="hljs-number">0</span>;  <br>  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>&gt;</span>  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func func)</span> </span>&#123;  <br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;  <br>        i &lt; n; i += blockDim.x * gridDim.x) &#123;  <br>       func(i);  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> n = <span class="hljs-number">65536</span>;  <br>   <span class="hljs-keyword">int</span> *arr;  <br>   <span class="hljs-keyword">float</span> result = <span class="hljs-number">0</span>;  <br>  <br>   cudaMallocManaged(&amp;arr, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));  <br>  <br>   <span class="hljs-keyword">int</span> block_dim = <span class="hljs-number">128</span>;  <br>   <span class="hljs-keyword">int</span> grid_dim = (n - <span class="hljs-number">1</span>) / block_dim;  <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;  <br>       arr[i] = i;  <br>   &#125;);  <br>      <br>      <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;  <br>       atomicAdd(&amp;sum, sinf(arr[i]));  <br>   &#125;);  <br>  <br>   cudaMemcpyFromSymbol(&amp;result, sum, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">0</span>, cudaMemcpyDeviceToHost);  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>      <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, result);  <br>  <br>   <span class="hljs-comment">// Compare  </span><br>   result = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; n; ++index) &#123;  <br>       result += sinf(index);  <br>   &#125;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, result);  <br>  <br>   cudaFree(arr);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>即改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">atomicAdd(&amp;sum, sinf(arr[i]));  <br></code></pre></td></tr></table></figure><p>此时就只有一点点由于加法顺序不同导致的精度误差了。这一些误差是可以被接受的。</p><p>那么我们继续分析一下这个问题，在 cuda 内部我们是如何实现原子的。这个问题在“编译原理”课程中可能有过类似的解答。<br>为了实现一个操作的原子性，我们需要“盯着他的数值”，只有我们“计算完成”“原始值也没变化”的时候，我们才能成功的优化。</p><p>换而言之，类似 atomicAdd, 我们又如下的步骤：</p><ul><li>Value_prev = Target</li><li>Target += …</li><li>Return Value_prev</li></ul><p>如果此时 Value_prev 和现在的状态一致的，就可以进行更新。</p><p>Cuda 中还有这些原子函数：</p><p>atomicAdd (dst, src)<br>atomicSub(dst, src)<br>atomicOr(dst, src)<br>atomicAnd(dst, src)<br>atomicXor(dst, src)<br>atomicMax(dst, src)<br>atomicMin(dst, src)</p><p>他们都有返回值，返回违背更改前的数值。</p><p>更加一般的，我们可以自己定义一个属于自己的原子操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <br>__device__ <span class="hljs-keyword">float</span> sum = <span class="hljs-number">0</span>;  <br>  <br><span class="hljs-function">__device__ <span class="hljs-keyword">float</span> <span class="hljs-title">my_atom_add</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *dst, <span class="hljs-keyword">float</span> src)</span></span>&#123;  <br>   <span class="hljs-keyword">int</span> old = __float_as_int(*dst);  <br>   <span class="hljs-keyword">int</span> expect;  <br>   <span class="hljs-keyword">do</span> &#123;  <br>       expect = old;  <br>       old = atomicCAS((<span class="hljs-keyword">int</span> *)dst, expect,  <br>               __float_as_int(__int_as_float(expect) + sinf(src)));  <br>   &#125; <span class="hljs-keyword">while</span>(expect != old);  <br>   <span class="hljs-keyword">return</span> old;  <br>&#125;  <br>  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Func</span>&gt;</span>  <br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">kernel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Func func)</span> </span>&#123;  <br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;  <br>        i &lt; n; i += blockDim.x * gridDim.x) &#123;  <br>       func(i);  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>   <span class="hljs-keyword">int</span> n = <span class="hljs-number">65536</span>;  <br>   <span class="hljs-keyword">int</span> *arr;  <br>   <span class="hljs-keyword">float</span> result = <span class="hljs-number">0</span>;  <br>  <br>   cudaMallocManaged(&amp;arr, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));  <br>  <br>   <span class="hljs-keyword">int</span> block_dim = <span class="hljs-number">128</span>;  <br>   <span class="hljs-keyword">int</span> grid_dim = (n - <span class="hljs-number">1</span>) / block_dim;  <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;  <br>       arr[i] = i;  <br>   &#125;);  <br>      <br>      <br>   kernel&lt;&lt;&lt;grid_dim, block_dim&gt;&gt;&gt;(n, [=] __device__ (<span class="hljs-keyword">int</span> i) &#123;  <br>       my_atom_add(&amp;sum, arr[i]);  <br>   &#125;);  <br>  <br>   cudaMemcpyFromSymbol(&amp;result, sum, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">0</span>, cudaMemcpyDeviceToHost);  <br>   checkCudaErrors(cudaDeviceSynchronize());  <br>      <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, result);  <br>  <br>   <span class="hljs-comment">// Compare  </span><br>   result = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; n; ++index) &#123;  <br>       result += sinf(index);  <br>   &#125;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, result);  <br>  <br>   cudaFree(arr);  <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用 atomoicCAS 按照类似的逻辑步骤：</p><ul><li>记录维护原始值</li><li>试图 CAS 更改</li><li>成功改动之后可以停下</li></ul><p>这里使用了一些技巧，结合下面的官网借口解释：</p><p><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#atomiccas">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#atomiccas</a></p><img src="image5.png" width="80%" height="80%"><p>AtomicCAS 是一个只支持整数的借口，如果需要浮点支持，需要进行 as float 进行转换。</p><p>这里不难看出另一个问题，如果我们的原子操作被严格执行，那么原子操作会成为一个严重的瓶颈。相当于所有的数据都要过一遍着一个原子操作。但是实际上GPU跑起来还是非常快的，这是因为GPU根据blockDim和gridDim进行了操作，部分串行。以求和为例，我们会将数据分成几个大块，分别计算部分和，最后再进行规约。利用这种方法保证了此处不会成为瓶颈。<br>因此也不难看出：原子操作都是可以 Fork-And-Merge 的操作。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cuda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2202-QemuTest</title>
    <link href="/2022/02/04/2022/2202-QemuTest/"/>
    <url>/2022/02/04/2022/2202-QemuTest/</url>
    
    <content type="html"><![CDATA[<p>由于重装系统之后，我的本地实验环境一直没有找时间去重新配置。在这里总结一下关于 riscv 测试环境的一些配置方法。</p><span id="more"></span><p>主要参考为：</p><ul><li><a href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html">Running 64- and 32-bit RISC-V Linux on QEMU</a></li><li><a href="https://zhuanlan.zhihu.com/p/258394849">在 QEMU 上运行 RISC-V 64 位版本的 Linux</a></li></ul><h1 id="本地配置环境"><a href="#本地配置环境" class="headerlink" title="本地配置环境"></a>本地配置环境</h1><p>本地系统环境如下：</p><img src="image1.png" width="80%" height="80%"><img src="image2.png" width="80%" height="80%"><p>内核有点更新过头，不过不碍事，可以继续正常使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \<br>                 gawk build-essential bison flex texinfo gperf libtool patchutils bc \<br>                 zlib1g-dev libexpat-dev git \<br>                 libglib2.0-dev libfdt-dev libpixman-1-dev \<br>                 libncurses5-dev libncursesw5-dev<br></code></pre></td></tr></table></figure><p>就完成了准备环境的安装。<br>我们之后的工作单独建立一个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ....[Anything you like]<br>mkdir riscv<br><span class="hljs-built_in">cd</span> riscv<br><span class="hljs-built_in">export</span> RISCV_EXP_HOME=<span class="hljs-variable">$PWD</span><br></code></pre></td></tr></table></figure><h1 id="Riscv-gnu-toolchains"><a href="#Riscv-gnu-toolchains" class="headerlink" title="Riscv-gnu-toolchains"></a>Riscv-gnu-toolchains</h1><h2 id="使用软件源"><a href="#使用软件源" class="headerlink" title="使用软件源"></a>使用软件源</h2><p>一个偷懒的方法是使用软件源里已经编译完成的 riscv 软件工具链。使用 apt 可以看到如下的包可以选择进行安装：</p><img src="image3.png" width="80%" height="80%"><h2 id="编译安装（推荐）"><a href="#编译安装（推荐）" class="headerlink" title="编译安装（推荐）"></a>编译安装（推荐）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$RISCV_EXP_HOME</span><br>git <span class="hljs-built_in">clone</span> https://gitee.com/mirrors/riscv-gnu-toolchain<br></code></pre></td></tr></table></figure><p>直接下载 gitee 上的镜像，速度更快。</p><p>之后我们需要对一个模块进行切除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> riscv-gnu-toolchain<br>git rm qemu<br></code></pre></td></tr></table></figure><p>Qemu 我们之后自己进行安装。</p><p>接着复制子模块内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git submodule update --init --recursive<br></code></pre></td></tr></table></figure><p>然后进行 autoconf 工具链的编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/opt/riscv64<br>sudo make linux -j 4<br></code></pre></td></tr></table></figure><p>最后测试安装是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">riscv64-unknown-linux-gnu-gcc -v<br></code></pre></td></tr></table></figure><img src="image4.png" width="80%" height="80%"><p>其实如果是为了测试编译的话，我们到这一步已经完成了。如果需要检验我们是否有可靠的 riscv 环境下的可用二进制可执行文件，我们需要使用 Qemu 进行测试。</p><h1 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h1><p>首先下载解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$RISCV_EXP_HOME</span><br>wget https://download.qemu.org/qemu-5.1.0.tar.xz<br>tar xf qemu-5.1.0.tar.xz<br><span class="hljs-built_in">cd</span> qemu-5.1.0.tar.xz<br></code></pre></td></tr></table></figure><p>Autoconf 软件，老样子直接安装，注意需要指定一下这里是 riscv 的工作环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --target-list=riscv64-softmmu,riscv64-linux-user --prefix=/opt/qemu<br>make -j 4<br>sudo make install<br></code></pre></td></tr></table></figure><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>再完成上面两个步骤之后，我们最重要的工具链已经基本完成了。可以把下面的这句写到环境变量里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/opt/riscv64/bin:/opt/qemu/bin<br></code></pre></td></tr></table></figure><p>下载内核，可以从镜像下载，这里选择一个特定的内核版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@gitee.com:mirrors/linux_old1.git<br>git checkout v5.4<br></code></pre></td></tr></table></figure><p>内核编译就是沿用如下方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig<br>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j 4<br></code></pre></td></tr></table></figure><h1 id="制作文件系统"><a href="#制作文件系统" class="headerlink" title="制作文件系统"></a>制作文件系统</h1><p>这里使用 busybox 制作，首先下载源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://gitee.com/mirrors/busyboxsource.git<br><span class="hljs-built_in">cd</span> busyboxsource<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CROSS_COMPILE=riscv64-unknown-linux-gnu- make menuconfig<br></code></pre></td></tr></table></figure><p>打开配置菜单后进入第一行的 “Settings”，在”Build Options”节中，选中 “Build static binary (no shared libs)”，设置好后退出保存配置。</p><p>之后再次配置和编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">CROSS_COMPILE=riscv64-unknown-linux-gnu- make -j 4<br>CROSS_COMPILE=riscv64-unknown-linux-gnu- make install<br></code></pre></td></tr></table></figure><p>完成之后我们回到实验目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-img create rootfs.img  4g<br></code></pre></td></tr></table></figure><p>安排 4g 的实验空间。将它文件格式定为 ext4：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext4 rootfs.img<br></code></pre></td></tr></table></figure><p>之后把刚刚在 busybox 中生成的内容移动过来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$RISCV_EXP_HOME</span><br>mkdir rootfs<br>sudo mount -o loop rootfs.img  rootfs<br><span class="hljs-built_in">cd</span> rootfs<br>sudo cp -r ../busyboxsource/_install/* .<br>sudo mkdir proc sys dev etc etc/init.d<br><span class="hljs-built_in">cd</span> etc/init.d/<br>sudo touch rcS<br></code></pre></td></tr></table></figure><p>在 RC 文件中写入一些基本信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">mount -t proc none /proc<br>mount -t sysfs none /sys<br>/sbin/mdev -s<br></code></pre></td></tr></table></figure><p>修改 RC 权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo chmod +x rcS<br></code></pre></td></tr></table></figure><p>安全期间，退文件环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo umount rootfs<br></code></pre></td></tr></table></figure><p>至此，我们已经完成了所有的操作。</p><h1 id="使用-Qemu-启动"><a href="#使用-Qemu-启动" class="headerlink" title="使用 Qemu 启动"></a>使用 Qemu 启动</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-riscv64 -M virt -m 256M -nographic -kernel linux/arch/riscv/boot/Image -drive file=rootfs.img,format=raw,id=hd0  -device virtio-blk-device,drive=hd0 -append <span class="hljs-string">&quot;root=/dev/vda rw console=ttyS0&quot;</span><br></code></pre></td></tr></table></figure><p>我们就可以启动了。我个人使用 alias 将上面命名为 rsicvexp 方便自己进行测试。</p><p>之后测试的时候在外部交叉编译生成 riscv 的可执行文件，复制到 rootfs 里面，然后就可以进行运行和测试了。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Compiler</tag>
      
      <tag>Qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2202-制作alternative</title>
    <link href="/2022/02/04/2022/2202-%E5%88%B6%E4%BD%9Calternative/"/>
    <url>/2022/02/04/2022/2202-%E5%88%B6%E4%BD%9Calternative/</url>
    
    <content type="html"><![CDATA[<p>在做各种编译环境的时候，我们经常遇到这么一个问题: 我们的编译器需要调整到特定的版本，例如 gcc-4 或者 g++-8。</p><span id="more"></span><p>但是我们使用的时候往往不会去刻意用额外的 CC=xxx CXX=xxx 之类的前缀，在网上 copy 命令的时候也非常容易忘记这件事情。</p><p>为此，Linux 中有一个 alternative 机制可以保证这一点从容灵活。这里做一个简单的介绍。</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>本次实验在 ACSA-snode6 机器上进行：<br><img src="image1.png" width="80%" height="80%"><br>机器环境由于不小心作大死变成了过高版本的 ubuntu 。不过问题不大，内核新一点也不算是坏事。</p><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls /usr/bin/gcc-*<br></code></pre></td></tr></table></figure><p>检查一下我们有哪些版本<br><img src="image2.png" width="80%" height="80%"></p><p>如果是没有使用过的组，会有下面的这种情况：</p><img src="image3.png" width="80%" height="80%"><p>但是这个不重要，使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 8<br>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 8<br></code></pre></td></tr></table></figure><p>其中最后一个数字代表 alternative 的优先级，我个人建议直接和版本好进行相关的对应联系起来，方便记忆。</p><p>类似的方法，把各个版本的 gcc 和 g++ 依次安装上来。之后再去使用 update-alternative 就可以看到如下的效果：</p><img src="image4.png" width="80%" height="80%"><p>选择需要的版本即可。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2202-没有指纹好气哦</title>
    <link href="/2022/02/03/2022/2202-%E6%B2%A1%E6%9C%89%E6%8C%87%E7%BA%B9%E5%A5%BD%E6%B0%94%E5%93%A6/"/>
    <url>/2022/02/03/2022/2202-%E6%B2%A1%E6%9C%89%E6%8C%87%E7%BA%B9%E5%A5%BD%E6%B0%94%E5%93%A6/</url>
    
    <content type="html"><![CDATA[<p>今天是没有指纹的第X天，自从我更新到 Ubuntu 22.04 之后，我深刻意识到这个系统相比 Debian 的落伍之处，虽然大家都是 Debian 系的，但是近两年来 Ubuntu 开发者开始不做人事。和 Gnome 开发组进行摆烂竞赛。对于此事我不做过多评价，只是：</p><span id="more"></span><ol><li>Ubuntu 升级之后大量的硬件驱动失去了支持，例如指纹、触控板等</li><li>Gnome 升级后和 GTK-3 系列软件发生快捷键冲突</li></ol><p>有人问我 GTK-3 系列的软件多不多，我只能说 Gnome 的原生文件管理器就是基于 GTK-3 的。</p><p>吐槽太多了，下面记录我今天忍无可忍，发誓修复指纹的过程：</p><h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><p>首先我先在 Google 上面进行了一番查询，发现了 Stack Overflow 上有人遇到了类似的情况：</p><p><a href="https://askubuntu.com/questions/1231185/fingerprint-login-in-20-04">类似状况链接</a></p><p>但是下面的解决方案不太管用。这个时候我开始怀疑自己的电脑是不是因为之前进水导致指纹传感坏了。</p><h1 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h1><img src="image1.png" width="80%" height="80%"><p>在 lsusb 的界面里，发现了一个我感到陌生的模块，这个模块我之前并未过多在意，仔细一查：</p><p><a href="https://www.dell.com/community/Linux-General/No-driver-for-fingerprint-reader-Goodix-27c6-5381-on-Linux/td-p/8018706">https://www.dell.com/community/Linux-General/No-driver-for-fingerprint-reader-Goodix-27c6-5381-on-Linux/td-p/8018706</a></p><p>好家伙，就是你做坏事了。</p><p>紧急查阅驱动，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -E ./hw-probe -all -upload<br></code></pre></td></tr></table></figure><p>检测配件看看：</p><p><a href="https://linux-hardware.org/?probe=30ddfbc611">https://linux-hardware.org/?probe=30ddfbc611</a></p><p>寄，这下裂开了，所有的发行版后面都跟着大大的 Fail</p><p>那么问题又来了，我之前在 Ubuntu2004 的时候是怎么使用指纹的呢？也就是说这个驱动其实是可以用的，但是需要和特定版本的库以及其他库进行配合。那么我们再想想办法。</p><h1 id="单独录入"><a href="#单独录入" class="headerlink" title="单独录入"></a>单独录入</h1><p>如果我需要单独录入指纹，那么我们会用到 fprintd-enroll 命令。但是新的问题诞生了：</p><p>fprintd-enroll 无法使用</p><p>这个时候发现，我用的 libfprintd 版本是 0.4。而一个可用的版本是 0.6。</p><p>在一番搜索之后，在 Dell 驱动支持的一个民间网站上找到了一个版本，用下面的命令下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O ~/Downloads/libp.deb http://dell.archive.canonical.com/updates/pool/public/libf/libfprint-2-tod1-goodix/libfprint-2-tod1-goodix_0.0.6-0ubuntu1\~somer  <br>ville1_amd64.deb<br></code></pre></td></tr></table></figure><p>好吧，折腾一圈心力憔悴。</p><p>终于可以读入我的指纹信息了，我开开心心录完指纹之后发现：</p><img src="image2.png" width="80%" height="80%"><p>KDE 不支持，但是具体的原因是什么呢？这个时候我再次进行探究。</p><h1 id="登录系统"><a href="#登录系统" class="headerlink" title="登录系统"></a>登录系统</h1><p>我们在登录的时候，我们不能使用指纹录入。Ubuntu 的登录使用的是 gdm 系统，而 KDE 用的是 sddm。Sddm 的最新方面还没有支持上，Plasma 也没支持……那我只能寄了。</p><h1 id="题外话（关于差点吧电脑搞没）"><a href="#题外话（关于差点吧电脑搞没）" class="headerlink" title="题外话（关于差点吧电脑搞没）"></a>题外话（关于差点吧电脑搞没）</h1><p>我今天的一次测试差点把我电脑直接搞死。</p><p>如果我想把指纹应用到登录和 sudo 权限的时候，我们就要在 <code>/etc/pam.d/sudo</code> 和 <code>/etc/pam.d/sdmm</code> 进行修改。</p><p><a href="https://wiki.archlinux.org/title/KDE_Wallet#Unlock_KDE_Wallet_automatically_on_login">https://wiki.archlinux.org/title/KDE_Wallet#Unlock_KDE_Wallet_automatically_on_login</a></p><p>我改完之后彻底没了……</p><p>所有用到 sudo 的地方都开始报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo: PAM account management error: Permission denied<br></code></pre></td></tr></table></figure><p>最终我找到了一丝生机：</p><p>我们使用 Dolphin 调用编辑器的时候，我可以用用户密码去获取 root 权限，而 Shell 中不可能得到。<br>这次事件之后我把我的 root 密码写到了我的笔记本（纸质）上面。终于活下来了。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Trick</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2201-环境变量编辑器</title>
    <link href="/2022/01/31/2022/2201-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2022/01/31/2022/2201-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><span id="more"></span><p>最近遇到了这么一个问题：我们在编辑环境变量的时候，往往会有一些定制化的需求，如何方便的编辑环境变量是一个比较难的问题。</p><p>变量类别：</p><ol><li>路径变量</li><li>路径组变量</li><li>IP地址变量</li><li>字符串变量</li></ol><p>分类别进行“检测分类”和“编辑”</p><p>检测：字符串检测<br>编辑：整合操作序列，软件退出并且确认保存之后才会被执行一系列的export指令</p><p>需要解决的问题：</p><ul><li><input disabled="" type="checkbox"> 操作流程</li><li><input disabled="" type="checkbox"> cli用户界面设计</li><li><input disabled="" type="checkbox"> ranger读取器（todo？）</li><li><input disabled="" type="checkbox"> env的编辑逻辑</li></ul><h1 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h1><h2 id="实现变量类型的识别"><a href="#实现变量类型的识别" class="headerlink" title="实现变量类型的识别"></a>实现变量类型的识别</h2><p>首先 ipv4 和 ipv6 的形式非常简单，有特定的识别方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_ipv6</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>) -&gt; bool:</span>  <br>    <span class="hljs-keyword">try</span>:  <br>        socket.inet_pton(socket.AF_INET6, address)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br> <span class="hljs-keyword">except</span> socket.error:  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <br>  <br>  <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_ipv4</span>(<span class="hljs-params">address</span>):</span>  <br>    <span class="hljs-keyword">try</span>:  <br>        socket.inet_aton(address)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br> <span class="hljs-keyword">except</span> socket.error:  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>下一步思考路径。路径有两种可能：</p><ol><li>合法路径</li><li>不合法路径（可能因为某种原因被删除了）</li></ol><p>那么如何设计合法的路径名呢？</p><img src="image1.png" width="80%" height="80%"><p>这里我考虑了一些情况：</p><ol><li>路径名中可能包含其他环境变量，但是根据<a href="https://stackoverflow.com/questions/2821043/allowed-characters-in-linux-environment-variable-names">规范</a> 环境变量名只能是大小写字母、数字、下划线构成</li><li>路径名可能会有多个/重复，但是这个不影响他作为一个合法路径</li></ol><p>这样就构成了一个简单的路径名称合法判断正则（顺便得到了一个可以用来检测环境变量名称是否合法的正则）</p><p>01/29/2022 21:35<br>我想骂人<br>问题的性质已经变了。对于环境变量的解读其实工作应该是shell处理的，而不是我自己去复现一个parse工具<br>因为Linux的文件命名过于随意，文件名可以有：<code> </code>、<code>$</code> 所以路径名没法很好的解析出来<br>不过我也受够了，不管别的了，直接开搞吧，姑且认为这个美好的世界上还是人类居多吧</p><p>01/31/2022 20:43<br>好吧，莫名其妙就做完了</p><p>github.com/Chivier/enview</p><p>功能不做过多赘述啦，我们直接在github里面看效果啦</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Develop</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2110-数据流加速处理器</title>
    <link href="/2022/01/22/2022/2110-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A0%E9%80%9F%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/01/22/2022/2110-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A0%E9%80%9F%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><span id="more"></span><p>近年来数据流处理器需求增长，传统冯诺依曼架构不再够用。</p><p>FPGA项目：<br>Microsoft Catapult FPGA 加速器项目</p><p>特征：</p><ol><li>计算强度高，阶段长</li><li>具有简单控制流的小指令占用空间</li><li>直接的内存访问和重用模式</li></ol><p>原因很简单：通过利用并发性，这些属性有助于非常高效的硬件实现。</p><p>现有的数据并行硬件解决方案在这些工作负载上表现良好，但为了更通用，为了取代特定领域的硬件，牺牲了太多的效率。</p><p>例如，短向量 SIMD 依赖于低效的通用流水来进行控制和地址生成，但加速代码通常没有复杂的控制和内存访问。 GPU 使用硬件来隐藏内存延迟以实现大规模多线程，但加速代码的内存访问模式通常可以在没有多线程的情况下轻松解耦。</p><img src="image1.png" width="80%" height="80%"><p>可重构的粗粒组成架构（CGRA）和专用的地址空间（Scratchpad）</p><p>图1：<br><img src="image2.png" width="80%" height="80%"><br>图2：<br><img src="image3.png" width="80%" height="80%"><br>图3：<br><img src="image4.png" width="80%" height="80%"></p><p>红色箭头表面着之间存在依赖关系，这里不能同时执行。</p><p>当端口A和端口B可用，则计算开始。同时，最后两个命令生成并排队。一旦计算的一个实例完成，所计算的数据就开始流传输到内存。</p><p>适应数据流的特征：<br><strong>1. 应该保证DFG图应该保证足够大<br>2. 数据流的流动应该尽可能的“长”<br>3. 重用的数据应该保证被scratchpad记录，以保证减少访存</strong></p><p>理解：scratchpad = Cache，可以根据应用定制大小</p><p>应该设计的接口范例：</p><img src="image5.png" width="80%" height="80%"><p>例子：</p><img src="image6.png" width="80%" height="80%"><p>重新回到 Scoreboard 设计</p><img src="image7.png" width="80%" height="80%"><p>这个图非常关键，应该就是OneAPI的设计逻辑，因为OneAPI引用了ISCA09和ISCA17的文章和此文均有关联。</p><p>在之前的文章中，不止一次提到了数据流处理器这个“古老”的设计理念。根据我所掌握的历史来看，数据流思想的诞生应该从1974年，在ISCA上由Dennis 和Misunas在“A Preliminary Architecture for a Basic Data Flow Processor”中提及。在之后的若干年里，Treleaven （ACM Computing Surveys1982） ，Veen （ACM Computing Surveys1986）,Gurd （CACM 1985 ），Arvind and Nikhil （IEEE TC 1990）,Lee （IEEE Computer 1994 ）中也数次提及这个概念。但是由于控制流结构在通用处理器中的商业模式已经较为稳定，数据流的研究一直以来被视为非主流的设计方案。直到深度学习处理器这类逐渐向火以来，数据流的概念又被当下的研究者重新研究。本文主要对于ISCA_2017中的一文写些文中的精髓部分的理解。</p><p>数据流设计的起源思想是：具有长时间的高计算强度，简单的控制模式和依赖关系，简单的流式存储访问和重用结构。本文中定义了一个通用的架构（硬-软件接口），该架构可以提供更有效的数据流式表达程序。</p><p>流式数据流架构的三点基本抽象原则：</p><ul><li>  <strong>用于重复的流水线计算的数据流图</strong></li><li>  <strong>基于流的命令，以促进数据在组件之间以及到内存的高效移动</strong></li><li>  <strong>专用（便签本）地址空间，可以有效地重复使用数据</strong></li></ul><p>基于以上的三点抽象原则：</p><p><img src="https://pic1.zhimg.com/80/v2-23f61f9b313817e6db1b0586a6bf27a4_720w.jpg"></p><p>上图描述了流数据流的程序员视图，包括数据流图本身，以及用于内存访问，读取重用和递归的显式流通信。抽象的表达了直观的硬件实现；</p><p><img src="https://pic2.zhimg.com/80/v2-9d1391a4b130c2b09865bcea0d7fd439_720w.jpg"></p><p>上图表示的是本文中的high-level的设计。它由可重构的粗粒组成架构（CGRA）和专用的地址空间（Scratchpad），通过宽总线连接至内存。它由一个简单的控制核心进行控制，该控制核心发送流命令由内存控制引擎，暂存器控制引擎和CGRA同时执行。这个基于流的接口的粗颗粒性质使内核相当简单而不牺牲高度并行的执行。流访问模式和受限的内存语义也使高效地址生成和协调硬件。相对于特定领域的体系结构，流数据流处理器可以重新配置其数据路径和内存流，因此更普遍和适应性强。</p><ul><li>  <strong>初探Stream-Dataflow架构</strong></li></ul><p>本文提出的流式数据流的架构主要由Stream组件和dataflow组件构成。其中Stream组件提供类似于vertor运算的与内存交互的接口（这是vertor架构的优势，下图b），dataflow组件提供空间上的计算规范（这是dataflow的优势，下图a）。</p><p><img src="https://pic2.zhimg.com/80/v2-92918df12ab536c8461623e3b9c4b115_720w.jpg"></p><p>Stream-Dataflow 流式数据流的抽象架构</p><p>上图主要设计思想是stream接口提供对一组有序的stream命令的支持，该命令嵌入在现有的Von Neu mann ISA中。流命令指定长和并发的内存访问模式。可表达的模式包括连续的，跨步的和间接的。我们添加了一个单独的“Scratch”地址空间，该地址空间可用于有效收集和访问重复使用的数据。最后，数据流接口通过数据流图（DFG）公开指令及其相关性。 DFG的输入和输出接口被命名为具有可配置宽度的端口，它们是流命令的源和目的地。</p><p><strong>Micro-architecture设计思想</strong></p><p>一种标准的硬件实现包括：用于计算的粗粒度可重配置体系结构（CGRA），可编程暂存器，用于处理存储器或暂存器访问命令的流引擎以及用于生成流命令的控制核心。流分派器强制流之间的体系结构相关性。控制核心可以执行任意程序，但可以编程为将尽可能多的工作分流到流数据流硬件。<strong>（结合第二张图分析）</strong></p><ul><li>  <strong>Stream-Dataflow的详细设计方案</strong></li></ul><p>这部分主要从抽象，执行模型和ISA来描述数据流的体系结构。</p><ul><li>  <strong>抽象</strong></li></ul><p>再次观察架构图的图a，数据流的架构中，通过将控制计算的顺序，映射城数据流图。通过数据的流向和barrier来控制数据流向的有序正确进行。在数据流图中，存在着指令数据计算的先后的依赖关系，一条中间指令的执行，必须等到符合满足它的数据已经ready时，才可以开始进行计算。将传统的PC指令控制的顺序，转换成数据之间的依赖关系。在数据流图当中，用户显示命令数据的起点节点和终止节点来确保一次数据的迭代的开始与终止。在架构设计中，用户还可以自定义barrier用以确保程序的序列正确执行。如果没有barrier的控制，那么只要等到数据的ready，所有的数据流都可以同时执行各自的任务。</p><ul><li>  <strong>编程与执行模型</strong></li></ul><p>Stream-Dataflow由配置信息，数据流动，以及barrier命令组成。在通用的程序当中，可以通过转换变为数据流的代码，实例如下：</p><p><img src="https://pic3.zhimg.com/80/v2-8f58bf4abfa55fdb918e4d4b47dc84fe_720w.jpg"></p><p>在图a中，内存访问了a，b和r。根据架构a的乘加运算关系可将左侧的代码转换为右侧的代码。在下面的b图中，是上述程序的执行过程。程序均以命令开始启动数据开始计算，红色箭头表面着之间存在依赖关系，这里不能同时执行。当端口A和端口B可用（端口宽度为3），则计算开始。同时，最后两个命令生成并排队。一旦计算的一个实例完成，所计算的数据就开始流传输到内存。当所有数据都释放到内存系统中时，屏障命令的条件得到满足，控制核心也将恢复。为了获得更好的性能，应该保证DFG图应该保证足够大，这样可以满足尽可能多的指令并行运算。第二，数据流的流动应该尽可能的“长”。第三，重用的数据应该保证被scratchpad记录，以保证减少访存。</p><ul><li>  <strong>ISA指令集</strong></li></ul><p>指令集的设计代表了体系结构设计的灵魂。下图是Stream-Dataflow支持的指令集。</p><p><img src="https://pic1.zhimg.com/80/v2-6e53efc23e1de480e98c5c59c9ae2888_720w.jpg"></p><p>在上面的表格中，访存的地址的格式文中作者进行了特别的设计使得更符合数据流思想。</p><p><img src="https://pic2.zhimg.com/80/v2-2afcff086137920e15c5625aefe3e54d_720w.jpg"></p><p>这样的模式是二维的仿射访问，由访问大小access size（最低级别访问的大小），跨步stride size（连续访问之间的大小）和前进的步数number of strides。对于不同情况下的（linear，Strided等）可以映射成下面图那种形式。</p><ul><li>  <strong>微架构的设计</strong></li></ul><p>设计有着两个原则：</p><ol><li> 避免使用大型的或者耗电量大的结构，特别如多端口存储器</li><li> 充分利用ISA提供的并发性。</li></ol><p>根据以上的两个原则，可以设计出：</p><p><img src="https://pic2.zhimg.com/80/v2-691fe204b4dceb95ae415d2f56c485f9_720w.jpg"></p><p>在整体上看来，该设计在生成流命令的时候考虑了低功耗控制内核，一组与引擎有效连接并移动数据的流引擎，以及用于高效并行计算的深层管道可重配置数据流基板。</p><p>详细来说，主要由以下五种组件构成：</p><ol><li> 控制核：一种低功耗的单发有序控制核，目的是生成数据流命令用以调度程序</li><li> Stream Dispatcher：该单元通过跟踪流资源分配和向流引擎发出命令来管理流引擎的并发执行。</li><li> 流引擎：进行数据访问和移动，通过三个“流引擎”，其中一个用于存储（便于广泛访问内存），一个用于暂存器（高效数据）重用，和一个用于DFG重复（用于在没有内存存储的情况下立即重用）。流引擎对各自的内存和暂存器资源分配给他们的流进行仲裁。</li><li> 向量端口：向量端口是两个端口之间的接口。CGRA执行的计算以及传入/传出数据的流。另外，一组矢量端口不连接到CGRA的设备用于存储间接加载/存储的流地址。</li><li> CGRA：粗粒度可重配置架构支持数据流图的流水线计算，CGRA避免了重复访问寄存器文件或近期内存数据。</li></ol><p>在此过程中，由数据流引擎负责控制该流的生命周期，该引擎负责调度相关程序，发布新的流命令等。</p><ul><li>  <strong>流调度与控制核心</strong></li></ul><p>流分派器的作用是增强对流（和屏障命令）的资源依赖性，并通过向它们发送命令来协调流引擎的执行。这部分的内部架构设计如下：</p><p><img src="https://pic2.zhimg.com/80/v2-58dd48b623358ac9139822ce26585ead_720w.jpg"></p><p>从图中可以看出，来自控制核心的流请求被排队<strong>（Stream Cmd Queue）</strong>，直到它们可以被命令解码器处理为止。该单元与资源状态检查逻辑进行协商，以确定是否可以发出命令，如果可以，则将其出队。屏障命令阻止核心发出进一步的流命令，直到解决屏障条件为止。</p><ul><li>  <strong>资源管理</strong></li></ul><p>具有相同源或目标端口的后续流必须按程序顺序发布，即控制核心上流的动态顺序。流分配单元负责维护此顺序，并通过在记分板上跟踪矢量端口和流引擎状态来实现。在发布流之前，它会检查这些记分板的状态。</p><p>引导程序端口的状态为“已占用”，“空闲”或“所有请求”。端口在发布时（由资源分配器）从空闲状态变为占用状态，并且该流在飞行中逻辑上拥有该资源。当该流结束时，关联的流引擎会通知调度程序将向量端口的记分板条目更新为自由状态。飞行中的所有请求状态指示所有对内存流的请求已完全发送到内存系统（但尚未到达）。此状态作为一种优化存在，以使使用同一端口的两个内存流能够同时在存储系统中拥有它们的请求。</p><ul><li>  <strong>流引擎</strong></li></ul><p>流引擎管理组件通过被许多激活流对各种资源的并发访问（内存接口，暂存器，输出向量端口）。通过从流分配器接收命令来启动流引擎。然后，它们在流的生命周期内协调地址生成和数据传输，并最终在释放相应的向量端口时通知调度程序（当流完成的时候）。流分配器确保并发流对其向量端口具有专用访问权限。未连接到CGRA的矢量端口促进了间接访问，该端口可缓冲运行中的地址。</p><p>整体上来说，该架构的设计就大致如此。他的效果评估如下：</p><p><img src="https://pic3.zhimg.com/80/v2-2cac1ba2f30995f0e77333a817347ec6_720w.jpg"></p><p>55nm下的仿真结果，对比功耗与面积。</p><p><img src="https://pic4.zhimg.com/80/v2-64503393c16ff8911e3114a34bf3310f_720w.jpg"></p><p>运行DNN时候与GPU,Diannao的性能比较。</p><p><strong>总结：</strong></p><p>本文提出了一种新的执行模型和架构，流式数据流架构，它提供了抽象，可以平衡矢量和空间体系结构之间的折衷，并在重要的一类数据处理工作负载上获得二者的专业化能力。</p><p>我们设想，这种架构的范式可以具有根本性通过减少专用模块的数量来简化对未来芯片的影响。相反，流数据流类型的结构可以与CPU和GPU处理器并排放置，并具有综合功能当程序遇到适当的阶段以进行高效加载时，就可以快速运行。这不仅减少了面积和复杂性大量的专用加速器，还可以减轻不断增长的设计和验证成本。在如此广阔的环境中，开发有效的编译工具以平衡这些架构所提供的并行性和数据重用之间的复杂权衡至关重要。为流数据流体系结构提供动态编译支持可以提高特定架构的能效。</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Architechture</tag>
      
      <tag>Dataflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2110-OP DSL</title>
    <link href="/2022/01/22/2022/2110-OP-DSL/"/>
    <url>/2022/01/22/2022/2110-OP-DSL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://op-dsl.github.io/papers.html">https://op-dsl.github.io/papers.html</a></p><span id="more"></span><h1 id="OP2-设计"><a href="#OP2-设计" class="headerlink" title="OP2 设计"></a>OP2 设计</h1><h2 id="OP2-API"><a href="#OP2-API" class="headerlink" title="OP2 API"></a>OP2 API</h2><img src="image1.png" width="80%" height="80%"><p>对于非结构网格的联系往往需要用复杂的拓扑序列维护关系，但是不同的网格具有不同的性质，例如四边形网格，每一个网格只会有上下左右四个联系单元。<br>对于一般的拓扑关系，我们维护：</p><ol><li>sets</li><li>data on sets</li><li>connectivity between sets (mapping)</li><li>operation over sets</li></ol><p>用四边形网格为例，我们关心的集合有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nedges = <span class="hljs-number">12</span>; <span class="hljs-keyword">int</span> ncells = <span class="hljs-number">9</span>; <span class="hljs-keyword">int</span> nbedges = <span class="hljs-number">12</span>;  <br>op_set edges = op_decl_set(nedges, <span class="hljs-string">&quot;edges&quot;</span>);  <br>op_set cells = op_decl_set(ncells, <span class="hljs-string">&quot;cells&quot;</span>); <br>op_set bedges = op_decl_set(nbedges, <span class="hljs-string">&quot;bedges&quot;</span>);<br></code></pre></td></tr></table></figure><p>数据维护</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> cell_data[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0.12B</span>, <span class="hljs-number">0.345</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.11B</span>, <span class="hljs-number">0.246</span>,  <br><span class="hljs-number">0.324</span>, <span class="hljs-number">0.112</span>, <span class="hljs-number">0.92B</span>, <span class="hljs-number">0.237</span>&#125;;  <br><span class="hljs-keyword">double</span> edge_data[<span class="hljs-number">12</span>] = &#123;<span class="hljs-number">3.3</span>, <span class="hljs-number">2.1</span>, <span class="hljs-number">7.4</span>, <span class="hljs-number">5.5</span>, <span class="hljs-number">7.6</span>, <span class="hljs-number">3.4</span>,  <br><span class="hljs-number">10.5</span>, <span class="hljs-number">9.9</span>, B<span class="hljs-number">.9</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">4.4</span>, <span class="hljs-number">3.6</span>&#125;;  <br><span class="hljs-function">op_dat dcells <span class="hljs-title">op_decl_dat</span><span class="hljs-params">(cells, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;double&quot;</span>,  </span></span><br><span class="hljs-function"><span class="hljs-params">cell_data, <span class="hljs-string">&quot;data_on_cells&quot;</span>)</span></span>;  <br>op_decl_set(edges, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;double&quot;</span>,  <br>edge_data, <span class="hljs-string">&quot;data_on_edges&quot;</span>);<br></code></pre></td></tr></table></figure><p>连接性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> edge_to_cell[<span class="hljs-number">24</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-number">0</span>,<span class="hljs-number">3</span>, <span class="hljs-number">1</span>,<span class="hljs-number">4</span>, <span class="hljs-number">2</span>,<span class="hljs-number">5</span>, <span class="hljs-number">3</span>,<span class="hljs-number">4</span>,  <br><span class="hljs-number">4</span>,<span class="hljs-number">5</span>, <span class="hljs-number">3</span>,<span class="hljs-number">6</span>, <span class="hljs-number">4</span>,<span class="hljs-number">7</span>, <span class="hljs-number">5</span>,B, <span class="hljs-number">6</span>,<span class="hljs-number">7</span>, <span class="hljs-number">7</span>,B &#125;;  <br>op_map pecell = op_decl_map(edges, cells, <span class="hljs-number">2</span>, <br>edge_to_cell, <span class="hljs-string">&quot;edge_to_cell_map&quot;</span>);<br></code></pre></td></tr></table></figure><p>操作 kernel function：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* edge, <span class="hljs-keyword">double</span>* cellO, <span class="hljs-keyword">double</span>* cel11)</span></span>&#123;  <br>*cellO += *edge;  <br>*cell1 += *edge;  <br>&#125;  <br>op_par_loop (res, <span class="hljs-string">&quot;residual_calculation&quot;</span>, edges,  <br>op_arg(dedges, <span class="hljs-number">-1</span>, Op_ID, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;double&quot;</span>, OP_READ),  <br>op_arg(dcells, <span class="hljs-number">0</span>, pecell, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;double&quot;</span>, oP_INC),  <br>op_arg(dcells, <span class="hljs-number">1</span>, pecell, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;double&quot;</span>, OP_INC));<br></code></pre></td></tr></table></figure><p>核函数需额外的说明：<br><img src="image2.png" width="80%" height="80%"></p><p>其中涉及了关于潜在数据依赖的处理，这一部分机制之后也会考虑。</p><h2 id="并行策略"><a href="#并行策略" class="headerlink" title="并行策略"></a>并行策略</h2><p><strong>网格分区方案还是依赖了ParMetis</strong></p><p>两个大的并行级别：</p><ul><li>distributed memory</li><li>single-node/shared-memory</li></ul><p>就是节点间并行和节点内并行。节点内并行的重要性高于节点间并行。因为节点之间并行其实只能通过MPI做Message Passing，我们更加 care 的是节点内的情况。设计遵循3条关键假设：</p><ol><li>each compute node will have GBs of memory</li><li>memory bandwidth is a major limitation</li><li>there is very little local shared memory</li></ol><h3 id="Cuda-策略"><a href="#Cuda-策略" class="headerlink" title="Cuda 策略"></a>Cuda 策略</h3><p>由于关键假设2，所以需要最小化主存和进程的通讯量。对于间接循环（涉及间接引用数据集的循环），这导致了使用小分区的想法，这些小分区足够小，以便每个小分区的所有间接数据集都能够适应有限的共享内存 在 NVIDIA GPU 中的每个 SM 上。对于数据冲突的问题，会有其他策略，这部分之后介绍。基于来自 FFTW 的想法，我们为每个并行循环构建了一个执行“计划”，该计划是该循环在 GPU 上的执行的自定义阻塞，从而优化使用每个多处理器上的本地共享内存，并详细考虑了循环计算。</p><h3 id="MPI-策略"><a href="#MPI-策略" class="headerlink" title="MPI 策略"></a>MPI 策略</h3><img src="image3.png" width="80%" height="80%"><p>暴力全部拷贝同步。</p><p>计算策略和 Cuda 类似，也使用了类似于 FFTW 的 execution plan</p><h3 id="Plan-construction"><a href="#Plan-construction" class="headerlink" title="Plan construction"></a>Plan construction</h3><p>这一部分在代码 <code>c/core/op_lib_core</code> 中有详细说明。</p><p>是并行循环在其上执行的抽象“元素”的集合。 “数据集”是与集合相关的数据，例如流变量或边权重，它们是并行循环函数的参数。 在特定的并行循环中，<strong>“间接数据集”是使用来自另一组的映射间接引用的数据集。</strong> 预处理器 op2.m 为每个并行循环识别参数 nargs 的数量、间接数据集 ninds 的数量以及从参数到间接数据集 inds[] 的映射。 最后一个对每个参数都有一个条目；如果它等于 -1，则该参数不引用间接数据集。</p><p>执行计划将执行集划分为小分区。 这些在代码中被称为“块”，因为它是一个较短的词。 与 CUDA 线程块相比，“块”一词的用法略有不同，但每个计划块都由单个 CUDA 块处理，因此希望不会太混乱。</p><p>计划块的大小使得间接数据集适合每个 SM 可用的有限共享内存量（“流式多处理器”，NVIDIA 用于描述其 GPU 中的每个执行单元的首选术语）。 这个想法是将间接数据集保存在共享内存中，以最大限度地重用数据并避免全局内存流量。 然而，这需要对用于引用这些数据集的映射重新编号。</p><p>算法执行步骤为：</p><ol><li>通过简单地附加到列表来构建对数据集的所有引用的列表</li><li>对列表进行排序并消除重复项——然后定义从本地索引到全局索引的映射</li><li>使用一个大的工作数组来反转映射，给出从全局索引到局部索引的映射</li><li>创建使用新本地索引的映射表的新副本</li></ol><p>请注意，每个间接数据集最终都有自己的重复映射表。<br>在这种情况下，我们目前通过复制重新编号的映射表会浪费内存和内存带宽。将来应该通过识别此类重复项、取消分配重复项并将指向重复表的指针更改为指向主表来消除这种情况。</p><p>为了避免数据依赖，这里使用染色策略。目标是为每个元素分配一个颜色，没有两个相同颜色的元素引用相同的间接数据集元素</p><p>对于每个间接数据集元素，我们维护一个引用它的元素的颜色列表。 从这个初始化为空的列表开始：</p><ol><li>循环遍历 set 元素引用的所有间接数据集元素，以找到尚未引用它们的最低索引颜色</li><li>将此设置为元素的颜色</li><li>再次循环所有间接数据集，将此颜色添加到它们的列表中</li></ol><h3 id="核间策略"><a href="#核间策略" class="headerlink" title="核间策略"></a>核间策略</h3><img src="image4.png" width="80%" height="80%"><p>维护边界</p><img src="image5.png" width="80%" height="80%">]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSL</tag>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2111-数据流语言设计-version1</title>
    <link href="/2022/01/22/2022/2111-%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1-version1/"/>
    <url>/2022/01/22/2022/2111-%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1-version1/</url>
    
    <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><span id="more"></span><p>为了研究为什么需要做数据流，什么应用需要数据流这个问题，我个人经历了一段时间的思考。<br>参考学习了COStream项目： 流程序，即有序处理数据序列的程序<br>COStream编程语言是一种面向并行体系结构的高性能流编程语言，采用同步数据流图的计算模式，即程序实现了一些独立的结点(为独立计算单元，COStream中称为actor)，这些结点通过输入和输出通道进行数据传递(即actor的输出边和输出边)，这些节点一起组成了代表整体运算的流图。</p><p>COStream语言的主要目的是:</p><ul><li>  在多核架构下揭露并利用流程序固有的并行性</li><li>  自动实现特定域中流应用专家进行的优化</li><li>  提高程序员在流域中的工作效率</li></ul><p>COStream如何实现程序的并行:</p><ol><li>任务划分<br> 给数据流图中的各结点分配处理器核（核的总个数由后台程序员确定），一个结点对应一个核，一个核可对应多结点，使各核的计算量大致相同，总通信开销尽量小。</li><li>阶段赋值<br> 给数据流图中各结点分配阶段号（总的阶段号由编译器决定），使每一阶段的总工作量大致相同，前一阶段的结点所需数据不依赖后一阶段中结点的输出。</li><li>软件流水<br> 采用软件流水技术，实现并行。其中，软件流水中第n阶段执行阶段号为n的结点。</li></ol><p>适用于数据流的应用：</p><ul><li><p>大的数据流<br>适合COStream应用的最根本特征体现在其在一个大数据序列(甚至是无穷的)，即数据流上进行操作，数据流中的每一个数据项在有限的时间内被处理，然后被丢弃。</p></li><li><p>独立的数据流结点<br>从概念上说，一个流的计算体现在该程序中数据流的转换。我们定义数据流的基本计算单元为actor：在每次执行阶段中，从输入流中读一个或多个数据项，对其进行计算，然后将一个或多个计算结果写入到输出流中。Actor通常都是独立和自足的，即没有包含对全局变量和其他actor的引用。一个流程序就是由一系列的actor组成的数据流图，其中一些actor的输出将是另外一些actor的输入。</p></li><li><p>一个稳定的计算模式<br>在程序稳态执行的过程中，数据流图的结构通常是不变的。即，一系列确定的actor将按照一个有序的顺序反复执行，给定一个输入数据流，将产生一个输出数据流。</p></li><li><p>滑动窗口的计算<br>数据流中的每一个值通常都会被同一个actor在连续的执行中所检测，也被称为滑动窗口。滑动窗口的例子包括生物序列分析、自然语言的处理、图像的处理（锐化、模糊化等）、网络数据包的检测等。</p></li><li><p>偶尔的流外通信<br>除了大容量的数据流将从一个actor流向另一个actor，actor也将通信一些少量的控制信息在一些罕见的不规则的基础上。例如：改变手机的音量，在屏幕中打印错误信息，或者改变自适应FIR actor中的系数。 这些信息通常和数据流中的数据相同步，例如调频电台在数据流中的某个特定点的传输时改变其频率。</p></li><li><p>高性能的期望<br>通常一些数据流程序需要满足实时性的限制，因此效率（延迟和吞吐量反面）是主要的考虑因素。另外有一些嵌入式的流程序将用于手机环境中，因此电量消耗，存储限制，代码大小限制等也很重要。</p></li></ul><h1 id="一个粗糙的设计"><a href="#一个粗糙的设计" class="headerlink" title="一个粗糙的设计"></a>一个粗糙的设计</h1><p>我们研究数据流有3个主要问题需要解决：</p><ol><li>问题的描述和设计模式（数据描述方法）</li><li>任务划分和分配方法（数据流动方法）</li><li>任务执行需要的数据传输问题（数据依赖分析）</li></ol><p>个人选择对应的三项研究分别为：</p><ol><li>OP2 ： 数据描述</li><li>SVF ： 数据依赖分析</li><li>COStream ：数据流动方法</li></ol><p>这种时候必要的时候需要设计多级编译：</p><ol><li>第一级编译 (Data Compiler) ： 原有程序不需要改动，将他编程更“规范”的数据描述模式</li><li>第二级编译（Dependencies Compiler）：如果程序需要流动，涉及依赖的部分需要复用数据和资源，这一部分需要通过旁路(Bypassing)处理</li><li>第三级编译（Flow Compiler）：将已经处理好依赖的部分编程更加适合计算的数据流，交付给具体的runtime</li></ol><p>我们暂时借用OP2的基本数据设计模式：<br>OP2 详情参考 [[2110-OP DSL]]</p><h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="数据编译设计"><a href="#数据编译设计" class="headerlink" title="数据编译设计"></a>数据编译设计</h2><p>个人认为，数据编译设计最基本的单元是：数据元素、数据块</p><p>元素顾名思义，即为单个的item，从简设计，目前只提供：16/32/64 bits integer</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Architechture</tag>
      
      <tag>Dataflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2111-数据流经典论文整理</title>
    <link href="/2022/01/22/2022/2111-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/"/>
    <url>/2022/01/22/2022/2111-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数据流发展综述"><a href="#数据流发展综述" class="headerlink" title="数据流发展综述"></a>数据流发展综述</h1><span id="more"></span><p>自计算机诞生以来, 计算机系统研究人员为提升计算速度, 一直百折不挠、不懈努力. 几十年间学  术界、产业界开展了多种多样的计算机体系结构探索, 产生了很多令人耳目一新的成果, 人们熟知的冯诺依曼结构瓶颈被反复诟病, 但是冯诺依曼计算机结构依然是当前计算机系统的主流架构. 在  谈及非冯计算机体系结构时, 数据流计算机无疑是被提及最多的.</p><p>控制流计算思想在表达计算任务方面比较符合人类的思考习惯.首先通过指令序列描述计算任务执行过程. 其中, 指令用操作码表示功能, 操作数表示被处理的数据. 控制流计算任务被描述为一串指令序列. 经典计算机体系结构中, 设计了以程序计数器 (program counter, PC) 为核心的控制器实现控制流计算思想.在执行时首先需要将待执行的指令取出, 经过译码后执行指令, 并通过地址访问内存, 获取需要的数据, 最后将结果数据写回到存储器中. 完成该条指令后, 程序计数器自动加一, 获取下一条指令继续上述流程. 在计算机系统发展初期,研究人员逐渐发现控制流计算思想中存在的性能瓶颈问题, 即指令执行是串行的, 而且取指令、取操作数、存结果等动作都需要访问存储器。</p><p>在基于数据流的计算任务中, 一项运算操作在获得了所有需要的操作数时即可执行, 所产生的结果数据不会被存储器保存, 而是直接作为操作数发送给后续的操作, 直到产生最终的输出结果. 与控制流计算思想中的指令序列串相比, 数据流图以图的形式描述了计算任务的并发执行全过程, 同时数据可以按照数据流图中边的指向直接传递到运算操作, 不需要缓存到存储器中.</p><p>静态数据流机是根据数据流计算思想, 具体实现出来的一种执行机构, 其基本结构主要由取指令部件、指令存储部件、处理部件、更新部件等组成. 在静态数据流机中运行程序时, 操作数不通过 “寻址” 被访问, 而是通过 “令牌 (token)” 或 “值” 的形式进行传递. 数据流计算机中的信息项由数据令牌和操作包组成, 其中, 数据令牌由结果值和目的地组成, 操作包由操作码、操作数和后继指令位置等组成. 待执行的数据流程序存放在指令存储部件中, 当某条指令所需的所有数据令牌都到达后, 取指令部件将相应的指令取出, 发送到可执行指令队列. 当物理计算资源有空闲时, 队列中的指令将依次被分配给处理部件进行并发执行. 这种等待结点所有输入弧中都获取到令牌后触发该结点执行的行为被称为“点火(firing)”, 是数据流计算模型的重要特点之一. 所产生结果形成新的令牌发送到更新部件中, 更新部件按令牌中的目标地址将令牌发送到指令存储部件内的相应指令位置.如果有指令已经获取到了所有需要的令牌, 更新部件会将该指令的地址发送给取指令部件, 进行下一次的数据流执行.</p><p>动态数据流机重点解决数据流图的边存在多次执行的问题. 静态数据流机虽然具备基本的数据流执行能力, 但它不仅依赖于数据, 也需要配合带有简单控制信号的 “控制令牌” 来确认指令间的数据传送, 且无法保证并发的重复性调用 (例如递归)对于这个问题, 动态数据流机通过 “标号令牌(tagged-token)” 的方式, 使单条弧上可以同时存在多个不同的令牌. 相比于静态数据流机, 动态数据流机在执行机构上增加了一个 “匹配部件”, 该部件负责添加标号和匹配标号的工作, 使数据令牌的传送不再依赖于控制令牌. 更新/取值部件通过标号的配对, 从指令存储部件中获取指令, 结合收到的数据令牌组, 合并出可执行的指令, 送至可执行指令队列. 这样一来, 数据流程序的并行性得到了更大限度的开发, 也具备了更完善的功能.</p><h1 id="Dennis-的-数据流"><a href="#Dennis-的-数据流" class="headerlink" title="Dennis 的 数据流"></a>Dennis 的 数据流</h1><p>文章：<a href="https://dl.acm.org/doi/10.1145/642089.642111">https://dl.acm.org/doi/10.1145/642089.642111</a></p><p>这篇文章可以说是诸多数据流研究的开端。有人称，这种数据流叫做 Static Data Flow，也有人叫 Pure Data Flow。</p><p>其核心思想可以用：<strong>A data flow node fires (fetched and executed) when all its inputs are ready</strong> 进行概括。</p><p>Dennis老师对数据流处理器进行了四种基本模块的设计：</p><ol><li>Fork</li><li>Primitive Ops</li><li>Switch</li><li>Merge</li></ol><p>图示：</p><img src="image1.png" width="80%" height="80%"><p>数据流图中，所有的值可以表示为 token 的形式，一般来说，token 采用一个三元组的形式：&lt;ip, p, v&gt;， 其中，ip为指令指针，指向对应的数据流元件，p为端口，表示对应的数据流接口，v为指令值，表示传递过去的数据。</p><p>举个例子：<br>$x = (a + b) * (b * 7)$</p><p>流图形式为：</p><img src="image2.png" width="80%" height="80%"><p>其中 (a + b) 的结果 姑且称为 c，c可以记录为：&lt;Mul-2, Left, (a + b)&gt;, Mul-2 是因为他传入第二层的乘号，Left 是传入左侧 Port</p><p>一个非常经典的例子可以说明控制流和数据流的区别：</p><img src="image3.png" width="80%" height="80%"><p>其中所有的弧线表示数据依赖，如果采用数据流，那么每一个格子，即我们使用到数据的地方，是不可能有重复弧边的，这说明数据流方法可以有效规避数据依赖导致的冒险等问题。</p><p>为了使得程序正常运作，需要一些“协议”保证，论文原文如下：</p><img src="image4.png" width="80%" height="80%"><p>即输入就绪、输出弧无数据阻塞。但是静态数据流依旧。此外还有一条，但是是在static的定义中被补充：<br>每个计算节点只有一个指令实例可以被fire。</p><p>即每一条指令同一时间只能被一次执行。对于高度复用类型的程序，static数据流就不再合适，例如：循环程序和复杂数据结构。</p><h1 id="Monsoon-处理器"><a href="#Monsoon-处理器" class="headerlink" title="Monsoon 处理器"></a>Monsoon 处理器</h1><p> 文章： Executing a Program on the MIT TaggedToken Dataflow Architecture</p><p>上述所说，为了处理类似循环，我们需要将token放在unbounded queue的结构中。这就诞生了 dynamic dataflow。</p><p>dynamic dataflow 中引入了一个新的结构，有人称为 context， 有人称为 frame pointer，有人称为 instruction template。总之就是对 token 的一个拓展。</p><p>现在的形式为：<br>token &lt;fp, ip, port, data&gt;</p><p>fp 即为 frame pointer，用于记录此条token将被哪个指令实例所接收。如果Frame里面已经有buffer记录了，那么可以流动起来并且计算结果，否则就将此token记录存储在frame列表中。</p><img src="image5.png" width="80%" height="80%"><p>此设计被发表于 ISCA 1990</p><p>动态数据流的思路可以简单的用这张图概括：</p><img src="image6.png" width="80%" height="80%"><p>更多关于 Tag 的处理在论文中有所介绍，不过这一部分和我们的需求不尽相同，这里不做过多探究。</p><h1 id="传统数据流方法的优劣"><a href="#传统数据流方法的优劣" class="headerlink" title="传统数据流方法的优劣"></a>传统数据流方法的优劣</h1><p>上述的两种方法其实都是传统数据流方法。作为经典的数据流方法，他们的优势是非常明显的：</p><ul><li>可以最大程度上激发并行度，即使对于不规整的程序行为（不简单直接的控制人跳转，复杂的依赖关系等等）也有极好的并行效果</li><li>只有“实际依赖”才会阻塞程序（写后读依赖）</li></ul><p>缺点同样明显：</p><ul><li>数据流编程模式缺乏固定统一的方法和接口，同时debug非常困难，因为程序原有的逻辑行为已经被破坏，也没有固定的状态表示方法</li><li>中断行为描述起来异常困难，没有很好的控制方法把程序终止</li><li>过于依赖查表（tag表、数据表等等），对内存不友好，对计分板设计提出极高的需求</li><li>指令周期不固定，阻塞时间不定长，关键节点的流速会影响全局流速</li></ul><h1 id="发展设想：数据流和控制流的结合"><a href="#发展设想：数据流和控制流的结合" class="headerlink" title="发展设想：数据流和控制流的结合"></a>发展设想：数据流和控制流的结合</h1><h2 id="设想1-ISA级别优化"><a href="#设想1-ISA级别优化" class="headerlink" title="设想1: ISA级别优化"></a>设想1: ISA级别优化</h2><p>对于大体框架我们保持不变，但是我们的数据流针对ISA级别进行处理，编译器不改动，对后端的架构进行更新和修改。<br>即：   Keep control flow at the ISA level, do dataflow   underneath, preserving sequential semantics</p><h2 id="设想2：整合模式"><a href="#设想2：整合模式" class="headerlink" title="设想2：整合模式"></a>设想2：整合模式</h2><p>保留数据流模型，但在 ISA 级别合并控制流以提高效率、利用局部性并简化资源管理（计分板）。同时将线程合并到数据流中：先静态方法排指令；当第一条指令被触发时，剩余的指令会不间断地执行。</p><p>Keep dataflow model, but incorporate control flow at the ISA level to improve efficiency, exploit locality, and ease resource management<br>Incorporate threads into dataflow: statically ordered instructions; when the first instruction is fired, the remaining instructions execute without interruption</p><p>其实这种模式方案更贴切，如果需要实现这种方案，直观的思路有二：</p><ol><li>用编译器处理</li><li>提高用户门槛，让用户使用指导语句、编程接口去自己控制数据流图</li></ol><p>如何更好的将两者整合实现时我们的目标。</p><h1 id="UPC"><a href="#UPC" class="headerlink" title="UPC++"></a>UPC++</h1><p>UPC++是一个支持分区全局地址空间（PGAS）编程的C++库。它是设计用于在分布式内存并行计算机上编写高效、可扩展的并行程序的一个工具。UPC++的关键通信设施是单边远程内存访问（RMA）和远程过程调用（RPC）。UPC++的控制模型是单程序、多数据（SPMD），每个独立的组成程序进程可以像在C++中那样访问本地内存。PGAS内存模型另外还提供 全局地址空间的单边RMA通信，它被分配在共享段中，分布在各个进程中。分布在各个进程中。</p><p>UPC++还具有远程程序调用（RPC）的功能。通信，使其很容易将计算转移到驻留在远程进程的数据上进行操作。UPC++的设计是为了支持超大规模的高性能计算，库的接口和 实施的重点是最大限度地提高可扩展性。在UPC++中，所有的通信操作都是 语法上是明确的，这鼓励程序员考虑与通信和数据移动相关的成本。和数据移动相关的成本。此外，所有的通信操作在默认情况下都是异步的，鼓励程序员寻求重叠的机会。程序员寻找机会将通信延迟与其他有用的工作重叠起来。UPC++ 提供了富有表现力和可组合的抽象，旨在有效地管理程序中异步的积极使用。在程序中的积极使用。这些设计原则的目的是使程序员能够使用UPC++编写应用程序，即使是性能良好的程序。使用UPC++编写应用程序，甚至在几十万个内核上也能表现良好。</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Architechture</tag>
      
      <tag>Dataflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2112-Docker笔记</title>
    <link href="/2022/01/22/2022/2112-Docker%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/22/2022/2112-Docker%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><span id="more"></span><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p><p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://yeasy.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-M5xTVjmK7ax94c8ZQcm%2F-M5xT_hHX2g5ldlyp9nm%2F-M5xTdXNYDmRWNH-Lqez%2Fvirtualization.png?generation=1588021947568736&alt=media"></p><p><img src="https://yeasy.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-M5xTVjmK7ax94c8ZQcm%2F-M5xT_hHX2g5ldlyp9nm%2F-M5xTdXP2scg0hxytUHA%2Fdocker.png?generation=1588021947474061&alt=media"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>root 文件系统<br>比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体</p><h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]<br></code></pre></td></tr></table></figure><p>一般情况下 docker 的镜像下载如果是教育网，那么速度非常高效。如果需要使用镜像，那么可以使用：</p><p><a href="https://yeasy.gitbook.io/docker_practice/install/mirror">https://yeasy.gitbook.io/docker_practice/install/mirror</a></p><p>的教程进行安排。</p><h2 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image ls<br></code></pre></td></tr></table></figure><img src="image1.png" width="80%" height="80%"><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image rm ...<br></code></pre></td></tr></table></figure><h1 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h1><h2 id="创建容器实例"><a href="#创建容器实例" class="headerlink" title="创建容器实例"></a>创建容器实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --rm ubuntu:18.04 bash<br></code></pre></td></tr></table></figure><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li>  <code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>这里是交互式和镜像互动的方法。</p><p>更多操作在<a href="https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf">Docker Cheatsheet</a>中学习</p><h1 id="使用实例：-Overleaf-docker-安装"><a href="#使用实例：-Overleaf-docker-安装" class="headerlink" title="使用实例： Overleaf docker 安装"></a>使用实例： Overleaf docker 安装</h1><p>这里介绍一下在node6上配置overleaf的过程。</p><p>由于overleaf已经开源，所以可以使用他们的docker直接进行配置。</p><h2 id="镜像拉取"><a href="#镜像拉取" class="headerlink" title="镜像拉取"></a>镜像拉取</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull sharelatex/sharelatex<br></code></pre></td></tr></table></figure><h2 id="配置文件拉取"><a href="#配置文件拉取" class="headerlink" title="配置文件拉取"></a>配置文件拉取</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://raw.githubusercontent.com/sharelatex/sharelatex/master/docker-compose.yml<br>sudo vim docker-compose.yml<br></code></pre></td></tr></table></figure><p>需要修改的就是<code>ports: - 80:80</code>,一般80端口都被apache或nginx占用了，改用其他端口如：<code>ports: - 9000:80</code></p><h2 id="启动sharelatex"><a href="#启动sharelatex" class="headerlink" title="启动sharelatex"></a>启动sharelatex</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="安装latex包"><a href="#安装latex包" class="headerlink" title="安装latex包"></a>安装latex包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it sharelatex bash<br>tlmgr update --self --all<br>tlmgr install scheme-full<br></code></pre></td></tr></table></figure><h2 id="创建admin"><a href="#创建admin" class="headerlink" title="创建admin"></a>创建admin</h2><p>打开： <a href="http://hostname:9000/launchpad">http://hostname:9000/launchpad</a><br>创建admin即可</p><h2 id="配置高亮"><a href="#配置高亮" class="headerlink" title="配置高亮"></a>配置高亮</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install python3<br>apt install python-pygments<br></code></pre></td></tr></table></figure><p>参考：<br>【1】<a href="https://www.jianshu.com/p/408a3b7a40b0">https://www.jianshu.com/p/408a3b7a40b0</a><br>【2】<a href="https://yxnchen.github.io/technique/Docker%E9%83%A8%E7%BD%B2ShareLaTeX%E5%B9%B6%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/#%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEShareLaTeX">https://yxnchen.github.io/technique/Docker%E9%83%A8%E7%BD%B2ShareLaTeX%E5%B9%B6%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/#%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEShareLaTeX</a><br>【3】<a href="https://sparktour.me/2021/04/02/self-host-overleaf/">https://sparktour.me/2021/04/02/self-host-overleaf/</a></p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2112-Obsidian2Hexo</title>
    <link href="/2022/01/22/2022/2112-Obsidian2Hexo/"/>
    <url>/2022/01/22/2022/2112-Obsidian2Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h1><span id="more"></span><p>方便将自己的 Obsidian Markdown 转换成 Hexo Markdown。</p><p>对于转换的时候，有一些需求：</p><h2 id="语法层面"><a href="#语法层面" class="headerlink" title="语法层面"></a>语法层面</h2><p>主要是：图形标签的转换<br>工作：检索path</p><h2 id="标签层面"><a href="#标签层面" class="headerlink" title="标签层面"></a>标签层面</h2><ol><li>时间，自动更新成当前日期</li><li>标签，自动提炼文档前的tag</li><li>链接，暂时不处理（懒，能用就行了，别管那么多）</li></ol><p>已经完成，代码位置：</p><p><a href="https://github.com/Chivier/H2O2H">https://github.com/Chivier/H2O2H</a></p><p>反向翻译之后有时间再做吧</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
      <tag>Translator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2112-系统重装</title>
    <link href="/2022/01/22/2022/2112-%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/"/>
    <url>/2022/01/22/2022/2112-%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="系统重装笔记"><a href="#系统重装笔记" class="headerlink" title="系统重装笔记"></a>系统重装笔记</h1><span id="more"></span><p>自从更换了新电脑之后，用了接近一年的windows11，但是在工作的时候发现了诸多问题。首先，从回顾我的工作流程开始：</p><ol><li>开机</li><li>打开wsl</li><li>进入Projects目录，使用vscode编程</li></ol><p>除此之外，windows对于我所有的用途为：</p><ol><li>浏览器看网页</li><li>outlook查看邮件</li><li>Office做ppt</li></ol><p>那么问题又来了，一般的展示我不会使用ppt，在使用obsidian之后我就更不用Office系列了，唯一需要Office的功能是Publisher。而且长期使用wsl给我的16G内存带来了巨大负担。此外还有WSL GUI的UI风格不统一、Windows11的宋体任务栏等诸多问题让我最终还是回归了熟悉的Linux系统。</p><p>在这一次装机的大部分流程和之前的<a href="https://chivier.github.io/2020/02/11/Rebuild-My-Home-01-Get-ready/">Rebuild My Home</a>基本一致，但是部分由于系统更新导致了一些可能存在的问题，在这里予以记录。</p><h2 id="1-输入法"><a href="#1-输入法" class="headerlink" title="1. 输入法"></a>1. 输入法</h2><p>现在的Linux下，输入法名称不再是 SogouPinyin， 搜狗官方予以的支持也非常不完善。要不是因为我长期使用小鹤双拼，我已经专用百度输入法了。</p><p>这里使用麒麟Ubuntu的源，直接安装里面配置好的sogou pinyin即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sL <span class="hljs-string">&#x27;https://keyserver.ubuntu.com/pks/lookup?&amp;op=get&amp;search=0x73BC8FBCF5DE40C6ADFCFFFA9C949F2093F565FF&#x27;</span> | sudo apt-key add<br>sudo apt-add-repository <span class="hljs-string">&#x27;deb http://archive.ubuntukylin.com/ukui focal main&#x27;</span><br>sudo apt upgrade<br></code></pre></td></tr></table></figure><p>之后直接安装即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install sogouimebs<br></code></pre></td></tr></table></figure><p>最后在语言选项中，和之前一样的方法修改成<code>fcitx</code><br>如果输入经常卡主，可能使ibus和fcitx5的冲突导致，可以用<strong>卸载ibus</strong>的方式解决。不过方法比较激进，慎重操作。</p><h2 id="2-Wechat-amp-TIM"><a href="#2-Wechat-amp-TIM" class="headerlink" title="2. Wechat &amp; TIM"></a>2. Wechat &amp; TIM</h2><p>这里使用一种偷懒的方法进行安装。直接使用deepin-wine的源进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O- https://deepin-wine.i-m.dev/setup.sh | sh<br></code></pre></td></tr></table></figure><p>之后使用命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install com.qq.weixin.deepin<br></code></pre></td></tr></table></figure><p>即可。</p><p>顺带一提，这种方法还可以安装一些其他软件：</p><table><thead><tr><th>Software</th><th>Package Name</th></tr></thead><tbody><tr><td>Wechat</td><td>com.qq.weicin.deepin</td></tr><tr><td>QQ</td><td>com.qq.im.deepin</td></tr><tr><td>TIM</td><td>com.qq.office.deepin</td></tr><tr><td>QQ Music</td><td>com.qq.music.deepin</td></tr><tr><td>爱奇艺</td><td>com.iqiyi.deepin</td></tr></tbody></table><p>此外，Wine Tray 的处理方法是使用Gnome Extensions的Topicon</p><h2 id="3-Utools"><a href="#3-Utools" class="headerlink" title="3. Utools"></a>3. Utools</h2><p>Utools可以替代部分Albert之前的内容。随软件发展，尽管Utools没有和Linux适配的检索软件，但是大量好用的插件可以弥补不足。主要的常用功能有：</p><ol><li>软件启动器</li><li>剪贴板</li><li>取色器</li><li>翻译</li></ol><p>因为Linux没有和Windows一样好用的检索软件，这里提供一个参考，使用<code>catfish</code>进行GUI检索，<code>locate</code> 和 <code>fzf</code> 配合使用完成命令行检索。</p><h2 id="4-Neovim"><a href="#4-Neovim" class="headerlink" title="4. Neovim"></a>4. Neovim</h2><p>Neovim中配置Coc.nvim，之后安装插件会比之前vim更简单。这里仅作为参考，不是所有人都能很好的适应vim。<br>此外我个人vim也并未进行过多配置。核心插件只有tabnine。</p><h2 id="5-触控板"><a href="#5-触控板" class="headerlink" title="5. 触控板"></a>5. 触控板</h2><p>这里在LG gram 16的笔记本上翻车了，触控板驱动可以使用，但是和系统并未配置好。手势和操作不能很好的使用。</p><p>这里使用<code>fusuma</code>进行触控板改写。损失了一定的流畅度，但是总体而言，效果还是可用的。特别是定制了4指工作区切换之后，系统变得更加舒适。</p><h2 id="6-字体和colorls"><a href="#6-字体和colorls" class="headerlink" title="6. 字体和colorls"></a>6. 字体和colorls</h2><p>为了更舒适的写程序和文档，一个好的字体是必不可少的一个部分。这里我使用两款字体：<br>Source Code Pro 和 Sauce Code Pro</p><p>其中，后者是在前者的基础上添加了一些符号。主要用途是配合colorls使用。这样命令行的观感更舒适，而且可以更清楚的识别文件的类型。</p><p>例如：<br><img src="image1.png" width="80%" height="80%"></p><h2 id="7-工作同步"><a href="#7-工作同步" class="headerlink" title="7. 工作同步"></a>7. 工作同步</h2><p>这里的工作同步使用了两套系统共同进行维护，一套是Microsoft Onedrive，另一套是自己的群辉smb+ftp双接口。</p><p>首先说说Onedrive，Onedrive在Windows下确实是非常完美的解决方案。但是在Linux下没有很好的适配版本。有一个貌似可用的软件叫Onedriver，但是性能堪忧。最终选择微软为Linux适配的命令行Onedrive工具进行调试。</p><p>教程： <a href="https://github.com/abraunegg/onedrive">https://github.com/abraunegg/onedrive</a></p><p>项目配套了SharePoint的教程。</p><p>如果资金尚可，Insync其实也是一个非常好的选择。</p><h2 id="8-需要额外注意的小Tip"><a href="#8-需要额外注意的小Tip" class="headerlink" title="8. 需要额外注意的小Tip"></a>8. 需要额外注意的小Tip</h2><p>这里需要提醒一下使用snap安装软件的局限性。snap安装的软件非常类似wine或者说是docker的模式，将足够多的包和基础设施进行独立封装。这就导致了snap安装的软件是一种类似虚拟机的模式运行的，能够访问的目录和软件权限都有和wine一样的问题。这也就是为什么snap中软件浏览文件的模式非常奇特，和系统默认软件安装的效果截然不同。</p><p>所以snap只适合安装：</p><ul><li>游戏</li><li>小工具</li><li>使用方法非常独立的软件</li><li>网络工具</li></ul><p>这里我只有这些软件使用snap安装：</p><ul><li>telegram 聊天软件怎么装都差不多</li><li>ao 给予electron的Microsoft Todo</li><li>lepton Gist的管理工具</li><li>p7zip 7zip的桌面端</li><li>drawio 简单的画图工具</li></ul><p>这些工具使用snap安装非常便捷，而且使用相对独立，和其他编程工具、办公软件交互其实不太多。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2201-ICS课程总结</title>
    <link href="/2022/01/22/2022/2201-ICS%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/22/2022/2201-ICS%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS课程总结"><a href="#ICS课程总结" class="headerlink" title="ICS课程总结"></a>ICS课程总结</h1><span id="more"></span><p>在2021年的最后，我对之前的所有实验给出一份参考。</p><p>首先先介绍各个实验的设计思路：</p><ol><li>Lab0：学习git的使用，方便我们进行之后的实验</li><li>Lab1：使用LC3实现乘法，加深对补码的理解；拓展实现思路是竖式乘法，其中蕴含了“对数复杂度求解问题”的思想，以此拓展介绍其他算法。</li><li>Lab2：递推方法的实现，让大家熟悉如何分配寄存器。这个流程在之后的工作中也会经常使用。例如使用尽量少的变量达到减少空间的目的，或者合理设计数据拷贝传递，达到减少复制数据的效果。</li><li>Lab3：实现代码的优化，这里实现方案有三种：<ul><li>找规律，数列有周期性</li><li>循环展开</li><li>打表，预先求值</li></ul></li><li>Lab4：类似于逆向的过程，第一个题可以读代码，理解递归，也可以使用枚举暴力尝试。第二个题是一个数学题，一个脑筋急转弯。</li><li>Lab5：复现代码，同奇怪的方法进行实验，这里只要求功能上实现。由于只是功能上实现，大家自由发挥。当然，最适合LC3实现素数判定的算法是筛法。</li><li>Lab6：想让大家秀一秀，“甚至可以有诡异的方法实现编程”（我们之前的习题课学习过Makefile，你甚至可以用Make和CMake实现）。</li><li>LabA：实现汇编器，学习Makefile的使用。学习使用C++的STL。</li><li>LabS：实现模拟器，学习CMake的使用，LibBoost的使用。学习下载、安装、和使用第三方库。面向对象编程的入门。</li></ol><p>在下面的讲义中将给出所有实验原始执行方案，<strong>因为各种原因没有被执行，仅供学习试用</strong>。</p><h2 id="Lab-0"><a href="#Lab-0" class="headerlink" title="Lab 0"></a>Lab 0</h2><p>使用git进行工作管理其实是非常方便的。在日常工作管理的时候，使用git可以带来很多便利。因为日常经常有如下需求：</p><ul><li>我想把这个程序改一下接口，给另一给程序使用。</li><li>程序有一部分功能是完善的，但是有另一部分功能不可用，需要进行大规模debug。</li><li>我要和同学开黑写代码。</li></ul><p>这种需求不可避免要用git。这里补充一些其他工具，在这里只列一些我常用的工具。</p><p>gitg：一个便捷的可视化工具，轻量免费</p><img src="image1.png" width="80%" height="80%"><img src="image2.png" width="80%" height="80%"><p>在vscode里安装git插件也是非常好的选择，我日常都是这么使用的以至于我对很多git操作其实并不熟练。</p><h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h2><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>这是一个使用 LC3 指令复现乘法的实验，首先理解问题非常重要：什么是乘法</p><blockquote><p>The multiplication of <a href="https://en.wikipedia.org/wiki/Natural_number">whole numbers</a> may be thought of as <a href="https://en.wikipedia.org/wiki/Multiplication_and_repeated_addition">repeated addition</a>; that is, the multiplication of two numbers is equivalent to adding as many copies of one of them, the <em>multiplicand</em>, as the quantity of the other one, the <em>multiplier</em>. Both numbers can be referred to as <em>factors</em>.</p></blockquote><p>这句话看起来像是一个废话，但是包含了本次试验最基本的算法：使用加法累加完成。但是如果是负数次或者0次，改定义需要拓展。对应的，程序可能需要写分支进行处理。但是这个不是这次试验的本意。</p><p>但是众所周知，LC3的机器使用补码对数字进行存储。这里需要对补码进行更加深入的认识（下面为了方便使用8位补码举例）：</p><p>$$<br>-2 = (11111110)_2<br>$$</p><p>但是如果换一种理解，我们可以认为：</p><p>$$<br>(11111110)<em>2 = (100000000)_2 - (10)_2 = 256</em>{10} - 2_{10}<br>$$</p><p>那么一个数字Num的补码等价于：</p><p>$$<br>2^{totalbits} + Num<br>$$</p><p>LC3中我们使用的是16位二进制，这里我们使用 $M$ 表示 $2^{totalbits}$ 。</p><p>如果使用乘法计算 $(a \times b) ; mod ; M$ ，相当于：</p><p>$$<br>a \times b ; mod ; M = (M + a) \times (M + b) ; mod ; M<br>$$</p><p>也就是说：</p><ol><li>我们可以无视补码条件，直接暴力进行加法</li><li>即使其中一个数$x$是负数，我们也可以将它视作$(M+x)$的形式，暴力处理</li></ol><p>那么 L 版本的代码就得到了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0001 111 111 0 00 000<br>0001 001 001 1 11111<br>0000 101 111111101<br></code></pre></td></tr></table></figure><p>那么如果需要考虑性能呢？</p><p>我们会用另一种我们在小学三年级的时候用过的算法进行实现，下面举一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">         1 0 1 1 1<br><br>       * 1 1 0 1 0<br>      ──────────────<br>       1 0 1 1 1<br><br>   1 0 1 1 1<br><br> 1 0 1 1 1<br>─────────────────────<br>...<br></code></pre></td></tr></table></figure><p>在列出结果之前，相比大家已经知道做法了，就是采用位移和加法的形式对数值进行相加。</p><p>下面是一个参考程序，为了方便阅读，先给出了实验的汇编形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ADD R3, R3, #1<br>ADD R5, R5, #8<br>ADD R5, R5, #8<br>LOOP    AND R6, R3, R1<br>        BRZ NEXT<br>        ADD R7, R7, R0<br>NEXT    ADD R3, R3, R3   ; R3 &lt;&lt;&#x3D; 1<br>        ADD R0, R0, R0   ; R0 &lt;&lt;&#x3D; 1<br>        ADD R5, R5, #-1  ; R5 -&#x3D; 1<br>        BRP LOOP<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0001011011100001<br>0001101101101000<br>0001101101101000<br>0101110011000000<br>0000010000000001<br>0001111111000001<br>0001011011000011<br>0001001001000001<br>0001101101111111<br>0000001111111001<br></code></pre></td></tr></table></figure><p>但是这依旧不是最好的方案，显然，可以采用“<strong>循环展开</strong>”再次优化。在Lab3的分析中我将给出详细介绍。</p><p>第一次试验看似非常简单，但是蕴含了一个重要的思想：如果操作$2^x$次操作$A$可以被操作$B$替代，那么我们可以将算法进行指数级别化简。下面介绍两个类似的应用。</p><h3 id="应用1：快速幂算法"><a href="#应用1：快速幂算法" class="headerlink" title="应用1：快速幂算法"></a>应用1：快速幂算法</h3><p>计算$a^b ; mod ; c$。</p><p>一个简单的思路是采用我们上面L版本程序的思路：循环进行乘法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; b; ++i) &#123;<br>        ans = ans * a % c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>而一个优化版本的方法和P版本程序思路一致：</p><ul><li><p>我们计算并且记录 $a^1,a^2,a^4,a^8…$</p></li><li><p>选出上述对应的指数相加，因为$a^p \times a^q = a ^ {p + q}$。所以这里求幂的方法和之前求加法的思路一致</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> t = a;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) &#123;<br>            ans = ans * t % c;<br>        &#125;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        t = t * t % c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用2：递推公式求解"><a href="#应用2：递推公式求解" class="headerlink" title="应用2：递推公式求解"></a>应用2：递推公式求解</h3><p>对于递推公式，例如：</p><p>$$<br>f(n) = a_{n-1}f(n-1) + a_{n-2}f(n-2) + a_{n-3}f(n-3) + … + a_{n-k}f(n-k)<br>$$</p><p>我们可以采用求解特征方程（组）的方法对其进行求解，得到一个时间复杂度为$O(1)$的算法。但是这样会有精度问题，举一个最简单的例子，对于一般的Fibonacci数列进行求解。</p><p>$$<br>f(1) = 1 \<br>f(2) = 1 \<br>f(n) = f(n-1) + f(n-2)<br>$$</p><p>容易得到通项公式为：</p><p>$$<br>f(n) = \frac{1}{\sqrt{5}} ((\frac{1+\sqrt{5}}{2})^{n} - (\frac{1-\sqrt{5}}{2})^{n})<br>$$</p><p>但是求数值的时候一定会有精度损失，特别是当n特别大的时候精度会被放大，具体原理大家学习浮点数表示方法的时候应该有所体会。所以大部分时候，我们都不会用这种方法进行计算，而是采用一个类似于应用一的方法。</p><p>$$<br>{\displaystyle {f(n+2) \choose f(n+1)}={\begin{pmatrix}1&amp;1\1&amp;0\end{pmatrix}}{f(n+1) \choose f(n)}}<br>$$</p><p>我们将递推公式写成矩阵形式，这样不难看出我们求下一项的方法其实是以此乘法计算。那么我们复用上一个应用的算法，得到：</p><p>$$<br>{\displaystyle {f(n) \choose f(n-1)}={\begin{pmatrix}1&amp;1\1&amp;0\end{pmatrix}}^n{f(1) \choose f(0)}}<br>$$</p><p>计算一个矩阵的幂我们采用类似的方法进行计算即可。</p><h3 id="原始方案"><a href="#原始方案" class="headerlink" title="原始方案"></a>原始方案</h3><p>采用和平均代码指令数，平均执行指令数的比值作为成绩。而且仅有本次实验占比的20%。这种评分方法参考清华大学的并行编程课程，我个人也非常赞同这种方案，可以看出同学之间水平的差异，也方便评分，不至于到期末的时候大家都被教务处把分数弄得一团糟。既然这一部分<strong>因为某些原因</strong>被取消，那么大家基本都是满分了，这次实验就变得异常简单。大家都快乐的完成了实验。</p><h2 id="Lab-2-amp-3"><a href="#Lab-2-amp-3" class="headerlink" title="Lab 2 &amp; 3"></a>Lab 2 &amp; 3</h2><h3 id="实验思路-1"><a href="#实验思路-1" class="headerlink" title="实验思路"></a>实验思路</h3><p>这两次的实验是计算一个递推关系：</p><ul><li>F(0) = 1</li><li>F(1) = 1</li><li>F(2) = 2</li><li>F(n) = (F(n-1) + 2 * F(n-3)) mod 1024 (1 &lt;= n &lt;= 16384)</li></ul><p>这里如果我们使用递归方法进行编程，那么将会耗费大量的时间，所以我们采用递推方法进行编程。同时采用类似于流水的设计方案。</p><p>参考代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.ORIG x3000<br>LD R5, MODNUMBER<br>ADD R1, R1, #1<br>ADD R2, R2, #1 ;F[1] &#x3D; 1<br>ADD R3, R3, #2 ;F[2] &#x3D; 2<br>ADD R4, R3, #0<br>LOOP ADD R4, R4, R1 ;F[N] &#x3D; F[N - 1] + F[N - 3]<br>     ADD R4, R4, R1 ;F[N] &#x3D; 2 * F[N - 1] + F[N - 3]<br>     AND R4, R4, R5 ;F[N] &#x3D; (2 * F[N - 1] + F[N - 3]) mod 1024<br>     ADD R1, R2, #0<br>     ADD R2, R3, #0<br>     ADD R3, R4, #0<br>     ADD R0, R0, #-1 ;N--<br>BRNP LOOP<br>ADD R7, R1, #0<br>HALT<br>MODNUMBER .FILL #1023<br>NUMBERA .FILL #0<br>NUMBERB .FILL #0<br>NUMBERC .FILL #0<br>NUMBERD .FILL #0<br>.END<br></code></pre></td></tr></table></figure><p>程序性能的评估方法在这里为大家进行介绍，很多同学不会统计自己程序的时间。但是这一个部分的工作其实非常简单，而且方法非常多样，这里只介绍一种作为参考。例如上面的程序如果我要进行评测指令条数，最简单的方法是用一个“同构的程序”进行计算。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>r5 = <span class="hljs-number">1023</span>;<br>count++;<br>r1 = <span class="hljs-number">1</span>;<br>count++;<br>r2 = <span class="hljs-number">1</span>;<br>count++;<br>r3 = <span class="hljs-number">2</span>;<br>count++;<br>r4 = <span class="hljs-number">0</span>;<br>count++;<br>loop: r4 = r4 + r1;<br>count++;<br>...<br></code></pre></td></tr></table></figure><p>每一条指令之后我都进行一个count自增操作，最后输出count即可。（所以建议使用有goto语句的语言进行同构程序评测，否则需要手动转换成while/for循环）</p><p>对于实验3的优化其实也非常简单，一个直观的思路是采取循环展开进行优化。我们举一个具体的例子进行理解。</p><p>下面有两个循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// Loop A</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    f[i] = g[i] * <span class="hljs-number">2</span>;<br>    g[i] = h[i] - <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">/// Loop B</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i += <span class="hljs-number">2</span>) &#123;<br>    f[i] = g[i] * <span class="hljs-number">2</span>;<br>    g[i] = h[i] - <span class="hljs-number">2</span>;<br>    f[i + <span class="hljs-number">1</span>] = g[i + <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;<br>    g[i + <span class="hljs-number">1</span>] = h[i + <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个循环是否一样呢？他们看起来都计算了f的10项和g数组的10项，但是两个循环的指令数目不同。原因在于对于i的操作的数目不同。我们将两个循环完整的展开：</p><p>Loop A:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">f[i] = g[i] * <span class="hljs-number">2</span>;<br>g[i] = h[i] - <span class="hljs-number">2</span>;<br>i++;<br>f[i] = g[i] * <span class="hljs-number">2</span>;<br>g[i] = h[i] - <span class="hljs-number">2</span>;<br>i++;<br>...<br></code></pre></td></tr></table></figure><p>Loop B:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">f[i] = g[i] * <span class="hljs-number">2</span>;<br>g[i] = h[i] - <span class="hljs-number">2</span>;<br>f[i + <span class="hljs-number">1</span>] = g[i + <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;<br>g[i + <span class="hljs-number">1</span>] = h[i + <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>;<br>i += <span class="hljs-number">2</span>;<br>...<br></code></pre></td></tr></table></figure><p>同样计算两项，前者用了6条指令，后者只有5条。</p><p>对于lab3的数据的设计我也采用了一个直观的方法：只评测10项，这10项我都是4的倍数，那么可以使用四次展开的方法进行优化。</p><p>但是这是否达到最优了呢？</p><p>对于特定的数据，这显然不是最优的，我们可以打表得到答案。对于一般数据，我们不难发现，这个数列其实是周期性的。所以一个能得到正常运行结果的方案是：</p><p>对于一个周期内的数据打表，周期之外的利用减法，然后输出。</p><h3 id="原始设计方案"><a href="#原始设计方案" class="headerlink" title="原始设计方案"></a>原始设计方案</h3><p>Lab2：使用最少寄存器进行编程（R0和R7作为输入和输出不算在内），使用5个寄存器，如果超出限制则会扣除10%的分数。使用最少指令数进行编程进行评分。</p><p>Lab3：递推的范围，公式变为</p><ul><li>F(n) = (F(n-1) + 2 * F(n-3)) mod 1024 (1 &lt;= n &lt;= <strong>65536</strong>)</li></ul><p>但是出于<strong>某种原因</strong>，此部分评分被移除，大家都非常愉快的完成了这两次实验。</p><h2 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab 4"></a>Lab 4</h2><h3 id="实验思路-2"><a href="#实验思路-2" class="headerlink" title="实验思路"></a>实验思路</h3><p>对于这次实验，其实是一个娱乐性质的游戏。我们先从第一个部分分析。</p><p>第一个部分的代码，我们给出的分析模式非常简单，只有4位需要补充。最简单的方法是进行16次枚举，配合LC3 Tool完成实验。其实希望通过这一个部分的实验收取大家的脚本，看看大家都用了什么自动化的方法和工具。</p><p>这一个部分希望借助这个代码帮大家理解递归程序的思想，原始汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.ORIG x3000<br>LEA R2,Stack ; R2 is Stack<br>AND R0,R0,#0 ; Foo called?<br>Main JSR Foo<br>HALT<br>Foo STR R7,R2,#0 ; Store R7 to stack<br>ADD R2,R2,#1 ; Increment stack<br>ADD R0,R0,#1 ; Called Foo!<br>LD R1,Counter ; Decrement Counter<br>ADD R1,R1,#-1<br>ST R1,Counter<br>BRz After ; After N times,RET<br>JSR Foo ; Otherwise, recur<br>After ADD R2,R2,#-1 ; Decrement stack<br>LDR R7,R2,#0<br>RET<br>Stack .BLKW #10<br>Counter .FILL #5<br>.END<br></code></pre></td></tr></table></figure><p>机器码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plain">1110010000001110<br>0101000000100000<br>0100100000000001<br>1111000000100101<br>0111111010000000<br>0001010010100001<br>0001000000100001<br>0010001000010001<br>0001001001111111<br>0011001000001111<br>0000010000000001<br>0100111111111000<br>0001010010111111<br>0110111010000000<br>1100000111000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000000<br>0000000000000101<br></code></pre></td></tr></table></figure><p>第二个部分的程序我这边进行了一些提示，程序是希望对7计算余数，但是有一个部分是对8计算除法，我们计算$x$对7的余数时，不妨换一个表达方法，让$x = 8k + r$其中$0 \le r &lt; 8$<br>$$<br>x ; mod ; 7 = (8k + r) ; mod ; 7 = (k + r) ; mod ; 7<br>$$<br>有了这个提示，这个程序也就不难了，除8是通过位移进行的，对8取余数是通过AND进行计算的。</p><p>原始汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.ORIG x3000<br>LOOPM JSR DIV8<br>AND R2, R1, #7<br>ADD R1, R2, R4<br>ADD R0, R1, #-7<br>BRP LOOPM<br>ADD R0, R1, #-7<br>BRN STOP<br>ADD R1, R1, #-7<br>STOP HALT<br>DIV8 AND R2, R2, #0 ; R1 &#x2F; 8 -&gt; R4<br>AND R3, R3, #0<br>AND R4, R4, #0<br>ADD R2, R2, #1<br>ADD R3, R3, #8<br>LOOP AND R5, R3, R1<br>BRZ NEXT<br>ADD R4, R2, R4<br>NEXT ADD R2, R2, R2<br>ADD R3, R3, R3<br>BRP LOOP<br>RET<br>.END<br></code></pre></td></tr></table></figure><h3 id="原始设计"><a href="#原始设计" class="headerlink" title="原始设计"></a>原始设计</h3><p>每个人拿到的程序都是不同的，是对16位bit进行随机反转得到的（不告诉你哪16位有错误）。鉴于实验难度过大，以及教务处提倡位更多同学减轻实验负担，这个部分已经被删除。于是大家都轻松愉快的完成了实验。</p><h2 id="Lab-5"><a href="#Lab-5" class="headerlink" title="Lab 5"></a>Lab 5</h2><p>这一部分的实验显然大部分同学曲解了我的本意，实验本意是：<code>functionally</code>复现，也就是说我只要你判断素数即可，算法我不care。但是大部分同学都在楞写了乘法去余数，这里我只希望大家复习一下筛法求素数的算法：<a href="https://baike.baidu.com/item/%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0/8670409">筛法素数百度百科</a></p><p>我依稀记得我在五年级的数学课本后的数学小天地（也可能是其他名字）里面学习过这个算法，相比这个算法不是很难，但是几乎没有同学用这个算法进行实践，因此我推荐大家复习一下小学数学课本。</p><p>这里程序不再详细写出，评测过程正在进行。</p><h2 id="Lab-6"><a href="#Lab-6" class="headerlink" title="Lab 6"></a>Lab 6</h2><p>一个不需要我评讲的实验，希望大家自己学习一下<strong>自己常用语言的时间评测工具</strong>，这种属于基本技能，相比是之后的科研工作中不可或缺的一个部分，希望大家能够掌握。</p><h2 id="Lab-A-amp-S"><a href="#Lab-A-amp-S" class="headerlink" title="Lab A&amp;S"></a>Lab A&amp;S</h2><p>今年第一次采用了**<u>程序填空+提问</u>**的方式进行检查实验。个人来看达到了比较好的实验效果，掌握了如何构建编译环境、如何编译命令行工具。这门课的重要作用之一就是在计算机学院的学习中承担承上启下的作用。掌握一些先进的开发工具和一些正确的开发方法是一个积极向上的计算机系学生的必备素养，所以这里我坚持使用C++进行实验设计。</p><p>其中有一些设计是为了大家进行更好的理解和学习，例如：</p><ul><li>汇编器实验中存留接口，可以方便有兴趣的同学设计指令集拓展，可以自己开发更有意思的部分</li><li>模拟器实验中采用libboost，有兴趣的同学回去了解学习这个在计算机开发</li><li>深入理解“指令集”如何变成一个可以执行的模型</li></ul><p>如果明年继续设计此部分实验，我将会进行如下设计：</p><ol><li>设计Python的版本</li><li>完成图形界面设计</li><li>设计扩展指令集和扩展结构，例如更多的特殊功能寄存器，或者是cache</li></ol><p>同样，今年的此部分实验也是抄袭的重灾区，框架中给出信息过多，考察重点偏向了学生对框架的理解。明年会调节比重。</p><h3 id="原始设计-1"><a href="#原始设计-1" class="headerlink" title="原始设计"></a>原始设计</h3><p>除了完成实验，需要为自己的代码写文档，学习使用doxygen/Sphinx或这其他代码文档工具编写文档，介绍接口、算法、程序框架。鉴于期末需要减轻负担，这一部分已经被移除。</p><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p>今年的课程设计，总体而言，我个人是非常愉快的。在实验被削弱后，我想大部分同学都轻松愉快的完成了实验。</p><p>实验和习题课，我分别教授了大家：</p><ul><li><p>git的使用方法</p></li><li><p>代码阅读和代码阅读辅助工具</p></li><li><p>如何在github上挑选优质项目进行学习</p></li><li><p>简单的debug技巧</p></li><li><p>简单的Markdown展示技巧</p></li><li><p>文档撰写</p></li><li><p>轻量级的多文件项目编译开发(GNU Make)</p></li><li><p>CMake项目的编译</p></li><li><p>第三方库的安装和配置</p></li><li><p>环境变量编辑</p></li><li><p>论文阅读和整理</p></li><li><p>相关文献查询</p></li><li><p><strong>搜索引擎的使用</strong></p></li></ul><p>我希望能尽自己微薄之力，为中国科学技术大学的本科生教育提升水平和质量，希望同学们在有限的时间内学习更多的内容。如果您是其中一位按照要求完成所有实验的同学，我希望你能有所收获，并且在一个学期的挣扎和努力中，对于系统运维，软件安装，环境配置都有了自己的品味和理解。在这个学期的努力下，很多同学学会了如何使用搜索引擎，这一点并不是开玩笑，很多时候“如何精确的描述自己的问题”比解决问题往往更加重要。对此我个人深感欣慰。这门课程在计算机学院的学习中，承担了承上启下的重要作用。我希望在这门课程里，大家对计算机科学有了一个更底层，更深刻的认识。如果大家之后在其他课程的学习遇到困难也欢迎随时和我联系。</p><p>我个人也是一位就读于安老师实验室的研究生，个人能力有限，精力有限，脾气有时候也有点急躁。这个学期感谢大家参与我设计的折磨人的实验，感谢大家这个学期对我的包容和支持。</p><p>鉴于今年的教学情况，我个人对我自己进行批评和反省，并提出以下改进方案：</p><ol><li>大作业提供Python版本，不是每一个同学都想学习C++，也不是每一个同学都需要会配环境</li><li>降低实验难度和评分要求，以更多的同学可以满分为目标设计实验</li><li>增加答疑时长，明年我研究生课程将结束，所以可以更多的时间为同学服务，同时我会改正自己不耐烦的坏毛病</li><li>对于实验补测和补交放宽条件，最好设计自动评测在线工具，方便更多的同学能随时随地检查自己实验的正确性</li></ol>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICS</tag>
      
      <tag>TA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2201-布谷计划</title>
    <link href="/2022/01/22/2022/2201-%E5%B8%83%E8%B0%B7%E8%AE%A1%E5%88%92/"/>
    <url>/2022/01/22/2022/2201-%E5%B8%83%E8%B0%B7%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>好吧，从2022年开始，我计划将自己变成一个不咕的人。为了实行这个计划，我觉得还是有必要用自己的博客督促一下自己。那么我的博客重新更新开始，但是在更新之前，我发现我过去一年其实写了很多文章和报告。</p><span id="more"></span><p>不过……</p><p>Hexo的格式僵硬，我日常一般用更利于同步的obsidian和notion。为了更好的解决这个问题，我个人觉得使用一个翻译器比我手动改更好一些。</p><p>在编写之前，我个人预想了一些设计理念，最终选定了Python编写（主要是便捷）。但是我一般使用python只是作为脚本类小工具编写，这里我需要做一个好用一点的命令行工具，最好用pypi进行打包。那么我们开始。</p><h1 id="Pypi"><a href="#Pypi" class="headerlink" title="Pypi"></a>Pypi</h1><p>首先进行比较，我在使用pypi的setup.py前后，我对自己的程序需要进行什么改动？<br><img src="image1.png" width="80%" height="80%"></p><p>简而言之，我自己对自己的程序进行了参数翻新。使得我们的程序可以进行更好的参数解析。如果使用 sys.argv 可能会有无法正确解析的问题，它更适合用来写小脚本，而不是功能复杂的命令行工具。argparse这里有一篇短文非常适合速成学习：</p><p><a href="https://haosquare.com/python-argparse/">Python-argparse</a></p><p>至于 setup.py 由于我是自用，所以我就快点搞搞得了，直接简单粗暴搞出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>setup(<br>    name=<span class="hljs-string">&quot;o2h&quot;</span>,<br>    version=<span class="hljs-string">&quot;0.1.0&quot;</span>,<br>    author=<span class="hljs-string">&quot;Chivier Humber&quot;</span>,<br>    entry_points=&#123;<br>        <span class="hljs-string">&quot;console_scripts&quot;</span>: [<span class="hljs-string">&quot;obs2hexo=o2h.o2h:o2h&quot;</span>],<br>    &#125;,<br>    license=<span class="hljs-string">&quot;MIT&quot;</span>,<br>    keywords=<span class="hljs-string">&quot;translator&quot;</span>,<br>    packages=find_packages(),<br>)<br><br></code></pre></td></tr></table></figure><p>复杂的功能并没有补充，这里介绍两项：</p><ul><li>entry_points： 用来制定命令行工具，格式为 <code>[执行命令]=‘模块名’.&#39;文件名&#39;:&#39;函数名&#39;</code>。我的例子写的不好，可以参考 <a href="https://stackoverflow.com/questions/56534678/how-to-create-a-cli-in-python-that-can-be-installed-with-pip">StackOverflow pypi</a>。<a href="https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html">官方教程</a>也有更完善的信息。</li><li>packages： 使用自动检索功能即可</li></ul><p>这样我就完成了一个翻译器的快速制作。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
      <tag>Work</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2110-LLVM整理</title>
    <link href="/2021/11/05/2022/2110-LLVM%E6%95%B4%E7%90%86/"/>
    <url>/2021/11/05/2022/2110-LLVM%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><span id="more"></span><p>这里首先先说明我整理次文档的目的，LLVM是我日常工作学习中最常用的工具，小到用C++写一个demo，大到做自带代码优化和代码分析，可以说我的日常工作学习离不开LLVM的Toolchains，在这里，我将自己对LLVM的见解和认识在这里做一个系统的整理和介绍。</p><p>这里我基于 LLVM 12 版本进行介绍，参考了一些 LLVM 的相关总结资料和书籍，结合官方文档，进行如下总结。</p><h2 id="使用系统环境"><a href="#使用系统环境" class="headerlink" title="使用系统环境"></a>使用系统环境</h2><img src="image1.png" width="80%" height="80%"><img src="image2.png" width="80%" height="80%">## 编译 LLVM 项目<p>简单来说步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/llvm/llvm-project.git<br>git checkout -b llvmorg-12.0.0<br><span class="hljs-built_in">cd</span> llvm-project<br>mkdir build<br>cmake –G Ninja -DCMAKE_INSTALL_PREFIX=<span class="hljs-variable">$INSTALL_DIR</span> -DLLVM_ENABLE_PROJECTS=clang ../llvm<br></code></pre></td></tr></table></figure><p>对于cmake项目的一般编译方法如此，这里需要对一些选项补充说明：</p><ul><li>LLVM_TARGETS_TO_BUILD： LLVM的目标平台，例如：<code>AArch64</code>, <code>AMDGPU</code>, <code>ARM</code>, <code>BPF</code>, <code>Hexagon</code>, <code>Lanai</code>, <code>Mips</code>, <code>MSP430</code>, <code>NVPTX</code>, <code>PowerPC</code>, <code>RISCV</code>, <code>Sparc</code>, <code>SystemZ</code>, <code>WebAssembly</code>, <code>X86</code>。默认和目前所在机器一致。</li><li>LLVM_ENABLE_PROJECTS： LLVM可以包含的组件，一般编译只加上clang，所有的组件为：<code>clang</code>, <code>clang-tools-extra</code>, <code>compiler-rt</code>, <code>debuginfo-tests</code>, <code>lib</code>, <code>libclc</code>, <code>libcxx</code>, <code>libcxxabi</code>, <code>libunwind</code>, <code>lld</code>, <code>lldb</code>, <code>llgo</code>, <code>mlir</code>, <code>openmp</code>, <code>parallel-libs</code>, <code>polly</code>, <code>pstl</code>。</li><li>LLVM_ENABLE_ASSERTIONS： Assertion check，非必要，但是可以加上。</li><li>LLVM_ENABLE_THREADS: 线程库，例如Pthreads，一般会考虑加上。</li><li>LLVM_ENABLE_WARNINGS: 如果可能，编译LLVM不应生成警告消息。因此，默认情况下会打开打印警告消息的选项。要将其关闭，必须指定–DLLVM_ENABLE_WARNINGS=off。</li><li>LLVM_OPTIMIZED_TABLEGEN: 通常，tablegen 工具使用与 LLVM 其他部分相同的选项构建。 同时使用tablegen生成大部分代码生成器。 因此，tablegen 在调试版本中要慢得多，从而显着增加了编译时间。 如果此选项设置为 ON，则在启用优化的情况下编译 tablegen，即使对于调试版本，也可能减少编译时间。 默认为关闭。 要启用此功能，您必须指定 –DLLVM_OPTIMIZED_TABLEGEN=ON。</li></ul><p>上述选项可以自行根据需求安装，更详细的编译选项说明见官方文档：</p><p><a href="https://llvm.org/docs/CMake.html">Building LLVM with CMake</a></p><h1 id="LLVM-代码结构"><a href="#LLVM-代码结构" class="headerlink" title="LLVM 代码结构"></a>LLVM 代码结构</h1><p>在 llvm-project 目录里，有诸多子目录，这些子目录包括了项目的各个内容组件，下面将概括性介绍这些组件的内容：</p><h2 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h2><p>llvm 目录存放 LLVM 项目的核心内容，即编译器后端工具。</p><p>重要组件有：</p><ul><li>llc: 静态编译器，llc 将 LLVMIR 文件作读入，输出 bitcode，特定架构汇编，或者直接输出二进制文件。</li><li>llvm-objdump, llvm-dwarfdump: 用于检查生成的对象文件，反编译工具。</li><li>llvm-ar：用于从 obj 文件整理生成归档文件。</li><li><strong>llvm-mc</strong>：这里需要额外强调，此工具我个人使用也并不是很多，但是将来会大有用途。该工具可以是一个机器码试验场，可以方便的编译和反汇编机器码并进行微调，<strong>在新增指令时非常有用</strong>。</li></ul><h2 id="polly"><a href="#polly" class="headerlink" title="polly"></a>polly</h2><p>数学优化方法，位于 Polly 目录中的 Polly 项目向 LLVM 添加了另一组优化。它基于一种称为多面体模型的数学表示法。使用这种方法，可以进行复杂的优化，例如针对缓存位置优化的循环。如果有时间可以稍微阅读了解一下。</p><h2 id="mlir"><a href="#mlir" class="headerlink" title="mlir"></a>mlir</h2><p>MLIR 项目旨在为 LLVM 提供多级中间表示。LLVM IR 已经处于较低级别，并且源语言的某些信息在编译器中生成IR期间丢失。<strong>所以 LLVM IR 并不能作为独立的编程语言使用</strong>（虽然理论上可行，但是写起来和写汇编一样麻烦），IR 的作用是<strong>面向未来，适应多种架构的后端</strong>。对于新的架构或者硬件设备，从 IR 到机器码或者二进制文件的成本是非常低廉的。</p><h2 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h2><p>clnag编译器也是llvm项目的一个重要组成部分，代码位于clang目录中。它提供了一套用于词法分析、语法分析、语义分析和从C、C++、Objtovi-C和Objul-C++源文件生成LLVM IR的库。</p><p>libclang 和相关组件基本位于 clang 中，其余一些额外的组件位于 clang-tools-extra 中。例如其中的 clang-tidy 是一个轻量级的代码整理工具。</p><h2 id="lld"><a href="#lld" class="headerlink" title="lld"></a>lld</h2><p>lld目录主要提供连接器。编译器创建的目标文件必须与运行时库链接在一起以形成可执行文件。链接器支持 ELF、COFF、Mach-O 和 WebAssembly 格式。</p><h2 id="lldb"><a href="#lldb" class="headerlink" title="lldb"></a>lldb</h2><p>一个和 gdb 等价的工具。</p><h2 id="llvm-runtime"><a href="#llvm-runtime" class="headerlink" title="llvm-runtime"></a>llvm-runtime</h2><p>llvm 运行时环境可以由 glibc 提供，也可以用自己的组件：</p><ul><li>compiler-rt 项目提供独立于编程语言的支持库。 它包括通用功能，例如 32 位 i386 的 64 位除法、各种santinizer、fuzzing 库和 profiling 库</li><li>libunwind 提供非绑定DWARF标准数据，用于debug</li><li>libcxxabi 提供 C++ 异常处理</li><li>libcxx C++标准库</li><li>libc C标准库</li><li>libclc OpenCL的运行时</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一己之见，LLVM之所以能够得到工业界的广泛认可和推崇，一个重要的理由就是LLVM设计的普适性。举个例子，在我们自己定制前端或者对 C/C++ 做一些语言拓展的时候，我们可以复用 LLVM 的代码，而绝对不会有人使用 GNU 的代码，尽管 GNU 编译器是认可度最高，最可信的编译器设计。</p><h1 id="使用-LLVM-相关库代码"><a href="#使用-LLVM-相关库代码" class="headerlink" title="使用 LLVM 相关库代码"></a>使用 LLVM 相关库代码</h1><p>既然上一小节最后提到了 LLVM 的复用问题，这里可以使用 LLVM 做一个小小的测试作为第一个 LLVM 项目的用例。</p><p>这里举例，用一个完整的 cmake 项目说明 LLVM 整体的使用方法。</p><p>一般的项目展开，会有<code>include</code>放置头文件，<code>src</code>放置源代码和框架，<code>lib</code>放置我们设计的动态和静态的库。</p><p>目录树结构如下：<br><img src="image3.png" width="80%" height="80%"></p><p>项目地址是：<br><a href="https://github.com/Chivier/llvm-test-frame">https://github.com/Chivier/llvm-test-frame</a></p><p>此处cmake可以直接抄走复用。个人认为之后对于DSL的开发不会脱离此模板。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLVM</tag>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2109-Source to Source LLVM 调研</title>
    <link href="/2021/10/26/2022/2109-Source-to-Source-LLVM-%E8%B0%83%E7%A0%94/"/>
    <url>/2021/10/26/2022/2109-Source-to-Source-LLVM-%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h1 id="翻译器调研"><a href="#翻译器调研" class="headerlink" title="翻译器调研"></a>翻译器调研</h1><span id="more"></span><p>首先阅读了一些相关的科研工作</p><p><a href="https://github.com/OP-DSL/clang-op-translator">GitHub - OP-DSL/clang-op-translator: Clang-based translator for OP2</a></p><p>但是这里最重要的还是自己实现一个Demo并且测试</p><h2 id="翻译器实验-clang-tool"><a href="#翻译器实验-clang-tool" class="headerlink" title="翻译器实验 clang-tool"></a>翻译器实验 clang-tool</h2><p>这里众说纷纭，网上并没有一个”直接可用“的版本供我进行快速测试和检查，经历了一整天的失败之后，在LLVM12.0和LLVM12.1版本上，Google搜索的几乎所有方法全部失败，因为LLVM11的API大改动导致之后的GetLocStart等clang::Stmt类里的方法更名，需要重新设计测试例子。</p><p>这里测试方案重新在 LLVM clang-extra-tools 里，基于 LLVM clang tool template 进行更改和测试。</p><h3 id="失败记录-1"><a href="#失败记录-1" class="headerlink" title="失败记录 #1"></a>失败记录 #1</h3><p>直接进行 cmake 失败，失败记录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">CMake Warning (dev) <span class="hljs-keyword">in</span> CMakeLists.txt:<br>  No project() <span class="hljs-built_in">command</span> is present.  The top-level CMakeLists.txt file must<br>  contain a literal, direct call to the project() <span class="hljs-built_in">command</span>.  Add a line of<br>  code such as<br><br>    project(ProjectName)<br><br>  near the top of the file, but after cmake_minimum_required().<br><br>  CMake is pretending there is a <span class="hljs-string">&quot;project(Project)&quot;</span> <span class="hljs-built_in">command</span> on the first<br>  line.<br>This warning is <span class="hljs-keyword">for</span> project developers.  Use -Wno-dev to suppress it.<br><br>CMake Error at CMakeLists.txt:6 (add_clang_executable):<br>  Unknown CMake <span class="hljs-built_in">command</span> <span class="hljs-string">&quot;add_clang_executable&quot;</span>.<br><br>CMake Warning (dev) <span class="hljs-keyword">in</span> CMakeLists.txt:<br>  No cmake_minimum_required <span class="hljs-built_in">command</span> is present.  A line of code such as<br><br>    cmake_minimum_required(VERSION 3.16)<br><br>  should be added at the top of the file.  The version specified may be lower<br>  <span class="hljs-keyword">if</span> you wish to support older CMake versions <span class="hljs-keyword">for</span> this project.  For more<br>  information run <span class="hljs-string">&quot;cmake --help-policy CMP0000&quot;</span>.<br>This warning is <span class="hljs-keyword">for</span> project developers.  Use -Wno-dev to suppress it.<br><br>-- Configuring incomplete, errors occurred!<br>See also <span class="hljs-string">&quot;/home/chivier/opt/llvm/clang-tools/tool-template/build/CMakeFiles/CMakeOutput.log&quot;</span>.<br></code></pre></td></tr></table></figure><p>add_clang_executable 没有 include 合适的 .cmake 文件，所以无法使用</p><p><a href="https://stackoverflow.com/questions/64271841/unknown-cmake-command-add-clang-executable">Unknown CMake command “add_clang_executable”</a></p><p>此处给出了一个不了了之的回答，并没有解决问题。之后对于LLVM的框架重新理解和思考，应该在find_package LLVM 和 libclang 入手，着手解决 LLVM 的 cmake 发现问题。</p><p>尝试用其他方法链接 LLVM 的 cmake 内容</p><p><a href="https://stackoverflow.com/questions/11933485/building-llvm-example">Building LLVM example</a></p><p>这里只给出了解决 add_llvm_excutable 的方案，并没有解决我的问题</p><h3 id="失败记录-2"><a href="#失败记录-2" class="headerlink" title="失败记录 #2"></a>失败记录 #2</h3><p>这里尝试直接去解决LLVM的问题，直接编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ ToolTemplate.cpp -I/home/chivier/opt/llvm/llvm-download/include -std=c++14   -fno-exceptions -fno-rtti -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS `llvm-config --libs all`<br></code></pre></td></tr></table></figure><p>这里直接采用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">llvm-config --cxxflags<br>llvm-config --libs all<br></code></pre></td></tr></table></figure><p>得到llvm需要的c++编译选项和llvm需要链接选项，但是此时发现无法链接，找不到需要的链接库，报错如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/bin/ld: cannot find -lLLVMMCParser<br>/usr/bin/ld: cannot find -lLLVMMC<br>/usr/bin/ld: cannot find -lLLVMDebugInfoCodeView<br>/usr/bin/ld: cannot find -lLLVMDebugInfoMSF<br>/usr/bin/ld: cannot find -lLLVMBitReader<br>/usr/bin/ld: cannot find -lLLVMCore<br>/usr/bin/ld: cannot find -lLLVMRemarks<br>/usr/bin/ld: cannot find -lLLVMBitstreamReader<br>/usr/bin/ld: cannot find -lLLVMBinaryFormat<br>/usr/bin/ld: cannot find -lLLVMTableGen<br>/usr/bin/ld: cannot find -lLLVMSupport<br>/usr/bin/ld: cannot find -lLLVMDemangle<br>...<br></code></pre></td></tr></table></figure><h3 id="失败记录-3"><a href="#失败记录-3" class="headerlink" title="失败记录 #3"></a>失败记录 #3</h3><p>根据之前的失败经验，分析之前的错误内容，主要错误集中在：<code>add_clang_executable</code> 的执行可行问题。在github里对该关键词进行搜索，找到和我需求最为相似的项目：<br><a href="https://github.com/firolino/clang-tool.git">https://github.com/firolino/clang-tool.git</a><br>但是编译报错还没有解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">/home/chivier/Projects/clang-tool/src/utils/utils.cc: In <span class="hljs-keyword">function</span> ‘bool utils::customRunToolOnCodeWithArgs(std::unique_ptr&lt;clang::FrontendAction&gt;, const llvm::Twine&amp;, const std::vector&lt;std::__cxx11::basic_string&lt;char&gt; &gt;&amp;, const llvm::Twine&amp;, const FileContentMappings&amp;)’:<br>/home/chivier/Projects/clang-tool/src/utils/utils.cc:32:16: error: ‘class clang::tooling::ToolInvocation’ has no member named ‘mapVirtualFile’<br>   32 |     invocation.mapVirtualFile(fileNameRef, code.toNullTerminatedStringRef(codeStorage));<br>      |                ^~~~~~~~~~~~~~<br>/home/chivier/Projects/clang-tool/src/utils/utils.cc:35:20: error: ‘class clang::tooling::ToolInvocation’ has no member named ‘mapVirtualFile’<br>   35 |         invocation.mapVirtualFile(filenameWithContent.first, filenameWithContent.second);<br>      |                    ^~~~~~~~~~~~~~<br>make[2]: *** [src/CMakeFiles/clang-tool.dir/build.make:102: src/CMakeFiles/clang-tool.dir/utils/utils.cc.o] Error 1<br>make[1]: *** [CMakeFiles/Makefile2:94: src/CMakeFiles/clang-tool.dir/all] Error 2<br>make: *** [Makefile:84: all] Error 2<br></code></pre></td></tr></table></figure><p>这里继续分析mapVirtualFile</p><p>调用 mapVirtualFile 的是一个 TollInnovation 类。这里存在一些借口不适配的问题。</p><h3 id="成功记录"><a href="#成功记录" class="headerlink" title="成功记录"></a>成功记录</h3><p>在网上搜索 ToolInnovation， 在 github 上找到了一个性质类似的项目：</p><p><a href="https://github.com/firolino/clang-tool.git">https://github.com/firolino/clang-tool.git</a></p><p>此项目可以很好的完善我目前的研究，基于 clang-tool 的 CMakeLists 我写出了如下的文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span>(LLVM_test)<br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><span class="hljs-keyword">find_package</span>(LLVM REQUIRED)<br><span class="hljs-keyword">find_package</span>(Clang REQUIRED)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;-Wall -g3 -O0 -fno-rtti $&#123;LLVM_COMPILE_FLAGS&#125;&quot;</span>)<br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CLANG_INCLUDE_DIRS&#125;</span>)<br><br><span class="hljs-keyword">set</span>(LLVM_LINK_COMPONENTS<br>  FrontendOpenMP<br>  Support<br>  )<br><br><span class="hljs-keyword">add_executable</span>(tool-template<br>  ToolTemplate.cpp<br>  )<br><br><span class="hljs-keyword">target_link_libraries</span>(tool-template<br>  PRIVATE<br>  clangAST<br>  clangASTMatchers<br>  clangBasic<br>  clangFrontend<br>  clangTooling<br>  clangToolingRefactoring<br>  )<br></code></pre></td></tr></table></figure><h1 id="clang-tooling"><a href="#clang-tooling" class="headerlink" title="clang tooling"></a>clang tooling</h1><p>对于 clang tooling 的做法，需要有如下考量</p><p>调研期间发现了一个 LLVM 更好用一些的文档网站：</p><p><a href="https://docs.hdoc.io/hdoc/llvm-project/">https://docs.hdoc.io/hdoc/llvm-project/</a></p><p>优势在于提供了 doxygen 中不便于搜索的麻烦，提供了搜索接口</p><p><a href="https://docs.hdoc.io/hdoc/llvm-project/search.html">https://docs.hdoc.io/hdoc/llvm-project/search.html</a></p><p>LLVM 框架的整体架构是</p><p>Frontend -&gt; Optimizer -&gt; Backend<br>Frontend = Lexer + Parser<br>Optimizer = Passed<br>Backend = MD Optimizer + CodeGen</p><p>分析出的 AST 树使我们前端分析的目标，但是 AST 的遍历具有一定的麻烦，我们不太可能根据 LLVM 每一代 API 的接口去设计我们的程序，这个实话需要借助 LLVM 一个相对独立的子项目，就是 clang tooling，作为 LLVM18 大会上的报告，Clang tooling 以及其代表组件 LibClang 在 “few years” 将维持稳定版本。</p><p>LibClang 的作用更想一个“光标”，用于遍历和访问每一个 AST 的 Translate Unit。</p><p>作为一个方便的接口，测试的时候可以先使用 Python 去开发和测试，便于调试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> clang.cindex <span class="hljs-keyword">import</span> *<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_function_call</span>(<span class="hljs-params">funcdecl, c</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; Determine where a call-expression cursor refers to a particular function declaration</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    defn = c.get_definition()<br>    <span class="hljs-keyword">return</span> (defn <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>) <span class="hljs-keyword">and</span> (defn == funcdecl)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fully_qualified</span>(<span class="hljs-params">c</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; Retrieve a fully qualified function name (with namespaces)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    res = c.spelling<br>    c = c.semantic_parent<br>    <span class="hljs-keyword">while</span> c.kind != CursorKind.TRANSLATION_UNIT:<br>        res = c.spelling + <span class="hljs-string">&#x27;::&#x27;</span> + res<br>        c = c.semantic_parent<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_funcs_and_calls</span>(<span class="hljs-params">tu</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; Retrieve lists of function declarations and call expressions in a translation unit</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    filename = tu.cursor.spelling<br>    calls = []<br>    funcs = []<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> tu.cursor.walk_preorder():<br>        <span class="hljs-keyword">if</span> c.location.file <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">elif</span> c.location.file.name != filename:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">elif</span> c.kind == CursorKind.CALL_EXPR:<br>            calls.append(c)<br>        <span class="hljs-keyword">elif</span> c.kind == CursorKind.FUNCTION_DECL:<br>            funcs.append(c)<br>    <span class="hljs-keyword">return</span> funcs, calls<br><br>idx = Index.create()<br>args =  <span class="hljs-string">&#x27;-x c++ --std=c++11&#x27;</span>.split()<br>tu = idx.parse(<span class="hljs-string">&#x27;tmp.cpp&#x27;</span>, args=args)<br>funcs, calls = find_funcs_and_calls(tu)<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> funcs:<br>    print(fully_qualified(f), f.location)<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> calls:<br>        <span class="hljs-keyword">if</span> is_function_call(f, c):<br>            print(<span class="hljs-string">&#x27;-&#x27;</span>, c.location)<br>    print()<br><br></code></pre></td></tr></table></figure><h1 id="OP2-Clang"><a href="#OP2-Clang" class="headerlink" title="OP2-Clang"></a>OP2-Clang</h1><p>OP2 clang 项目是基于 LLVM 项目开发的。基本思想是为了适应更多更新的硬件设备，我们不应该去专门花时间在底层设计上，这些部分理应由编译器后端进行处理。更好的构建起前端到这里的框架才是一个 DSL 应该做的事情。非结构化网格是一个代表性的问题。</p><img src="image1.png" width="80%" height="80%"><p>OP2 Clang 的主要工作是借用 Clang 将中间层 API 转移，用户不必直接去写 OP2 Library 中的 API 代码，而是用简单的逻辑说明代码的逻辑。Clang 再利用前端去实现 OP2 中的并行化。</p><p>Youtube 的视频讲解了论文的思路 <a href="https://www.youtube.com/watch?v=Ie2WjoUEnKw">https://www.youtube.com/watch?v=Ie2WjoUEnKw</a></p><p>设计思想重要部分是：<br><strong>handle significant structural transformations</strong></p><p>其实这个工作的价值并不在于 Clang，而在于 OP2 库的并行化的易用性，那么这项工作是否真的那么容易复现呢？</p><p>答案是肯定的，并且这里将给出一个更加简单的复现思路，如果读了之前的工作文档，那么会发现，如果使用 libclang Python API ，那么复现此工作将不再复杂，知识简单的：“模式匹配” + “代码替换”</p><p>其代码框架如下：</p><p>Op2ModeScan -&gt; [generator]</p><p>generator 包含如下部分：<br>common, cuda, openmp, sequntial, vectorization</p><p>以 openmp 举例，我在下面的代码标出注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> parLoopSkeletonCompStmtMatcher =<br>    compoundStmt(hasParent(functionDecl(hasName(<span class="hljs-string">&quot;op_par_loop_skeleton&quot;</span>))));<br>&#125; <span class="hljs-comment">// namespace</span><br><br><span class="hljs-keyword">namespace</span> OP2 &#123;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang::ast_matchers;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> clang;<br><span class="hljs-comment">//___________________________________MATCHERS__________________________________</span><br><span class="hljs-comment">// 下面用LLVM接口对AST的节点进行判定</span><br><br><span class="hljs-keyword">const</span> StatementMatcher OMPKernelHandler::locRedVarMatcher =<br>    declStmt(containsDeclaration(<span class="hljs-number">0</span>, varDecl(hasName(<span class="hljs-string">&quot;arg0_l&quot;</span>))),<br>             hasParent(parLoopSkeletonCompStmtMatcher))<br>        .bind(<span class="hljs-string">&quot;local_reduction_variable&quot;</span>);<br><br><span class="hljs-keyword">const</span> StatementMatcher OMPKernelHandler::locRedToArgMatcher =<br>    binaryOperator(<br>        hasOperatorName(<span class="hljs-string">&quot;=&quot;</span>),<br>        hasRHS(ignoringImpCasts(declRefExpr(to(varDecl(hasName(<span class="hljs-string">&quot;arg0_l&quot;</span>)))))),<br>        hasParent(parLoopSkeletonCompStmtMatcher))<br>        .bind(<span class="hljs-string">&quot;loc_red_to_arg_assignment&quot;</span>);<br><br><span class="hljs-keyword">const</span> StatementMatcher OMPKernelHandler::ompParForMatcher =<br>    ompParallelForDirective().bind(<br>        <span class="hljs-string">&quot;ompParForDir&quot;</span>); <span class="hljs-comment">// FIXME check if it is in the main file.</span><br><br><span class="hljs-comment">//_________________________________CONSTRUCTORS________________________________</span><br>OMPKernelHandler::OMPKernelHandler(<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, clang::tooling::Replacements&gt; *Replace,<br>    <span class="hljs-keyword">const</span> ParLoop &amp;loop)<br>    : Replace(Replace), loop(loop) &#123;&#125;<br><br><span class="hljs-comment">//________________________________GLOBAL_HANDLER_______________________________</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OMPKernelHandler::run</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!lineReplHandler&lt;DeclStmt, <span class="hljs-number">1</span>&gt;(<br>          Result, Replace, <span class="hljs-string">&quot;local_reduction_variable&quot;</span>,<br>          <span class="hljs-built_in">std</span>::bind(&amp;OMPKernelHandler::handleRedLocalVarDecl, <span class="hljs-keyword">this</span>)))<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (!HANDLER(CallExpr, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;func_call&quot;</span>, OMPKernelHandler::handleFuncCall))<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// if successfully handled return</span><br>  <span class="hljs-keyword">if</span> (!lineReplHandler&lt;BinaryOperator, <span class="hljs-number">7</span>&gt;(<br>          Result, Replace, <span class="hljs-string">&quot;loc_red_to_arg_assignment&quot;</span>,<br>          <span class="hljs-built_in">std</span>::bind(&amp;OMPKernelHandler::handlelocRedToArgAssignment, <span class="hljs-keyword">this</span>)))<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// if successfully handled return</span><br>  <span class="hljs-keyword">if</span> (!HANDLER(OMPParallelForDirective, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;ompParForDir&quot;</span>,<br>               OMPKernelHandler::handleOMPParLoop)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//___________________________________HANDLERS__________________________________</span><br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">OMPKernelHandler::handleFuncCall</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> funcCall = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">ss</span><span class="hljs-params">(funcCall)</span></span>;<br>  ss &lt;&lt; loop.getUserFuncInfo().funcName &lt;&lt; <span class="hljs-string">&quot;(&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; loop.getNumArgs(); ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!loop.getArg(i).isReduction()) &#123;<br>      <span class="hljs-keyword">if</span> (loop.getArg(i).isDirect()) &#123;<br>        ss &lt;&lt; loop.getArg(i).getArgCall(i, <span class="hljs-string">&quot;n&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        ss &lt;&lt; loop.getArg(i).getArgCall(<br>            loop.dat2argIdxs[loop.dataIdxs[i]],<br>            (<span class="hljs-string">&quot;map&quot;</span> + <span class="hljs-built_in">std</span>::to_string(loop.mapIdxs[i]) + <span class="hljs-string">&quot;idx&quot;</span>));<br>      &#125;<br>      ss &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ss &lt;&lt; <span class="hljs-string">&quot;&amp;arg&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;_l,&quot;</span>;<br>    &#125;<br>  &#125;<br>  ss.str();<br>  <span class="hljs-keyword">return</span> funcCall.substr(<span class="hljs-number">0</span>, funcCall.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;);&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">OMPKernelHandler::handleRedLocalVarDecl</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<br>  <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">os</span><span class="hljs-params">(s)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> ind = <span class="hljs-number">0</span>; ind &lt; loop.getNumArgs(); ++ind) &#123;<br>    <span class="hljs-keyword">const</span> OPArg &amp;arg = loop.getArg(ind);<br>    <span class="hljs-keyword">if</span> (arg.isReduction()) &#123;<br>      os &lt;&lt; arg.type &lt;&lt; <span class="hljs-string">&quot; arg&quot;</span> &lt;&lt; ind &lt;&lt; <span class="hljs-string">&quot;_l = *(&quot;</span> + arg.type + <span class="hljs-string">&quot; *)arg&quot;</span> &lt;&lt; ind<br>         &lt;&lt; <span class="hljs-string">&quot;.data;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> os.str();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">OMPKernelHandler::handlelocRedToArgAssignment</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<br>  <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">os</span><span class="hljs-params">(s)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> ind = <span class="hljs-number">0</span>; ind &lt; loop.getNumArgs(); ++ind) &#123;<br>    <span class="hljs-keyword">const</span> OPArg &amp;arg = loop.getArg(ind);<br>    <span class="hljs-keyword">if</span> (arg.isReduction()) &#123;<br>      os &lt;&lt; <span class="hljs-string">&quot;*((&quot;</span> + arg.type + <span class="hljs-string">&quot; *)arg&quot;</span> &lt;&lt; ind &lt;&lt; <span class="hljs-string">&quot;.data) = arg&quot;</span> &lt;&lt; ind<br>         &lt;&lt; <span class="hljs-string">&quot;_l;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> os.str();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">OMPKernelHandler::handleOMPParLoop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> plusReds, minReds, maxReds;<br>  <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">os</span><span class="hljs-params">(plusReds)</span></span>;<br>  <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">osMin</span><span class="hljs-params">(minReds)</span></span>;<br>  <span class="hljs-function">llvm::raw_string_ostream <span class="hljs-title">osMax</span><span class="hljs-params">(maxReds)</span></span>;<br>  <span class="hljs-comment">// 计算可用资源</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> ind = <span class="hljs-number">0</span>; ind &lt; loop.getNumArgs(); ++ind) &#123;<br>    <span class="hljs-keyword">const</span> OPArg &amp;arg = loop.getArg(ind);<br>    <span class="hljs-keyword">if</span> (arg.isReduction()) &#123;<br>      <span class="hljs-keyword">switch</span> (arg.accs) &#123;<br>      <span class="hljs-keyword">case</span> OP2::OP_INC:<br>        os &lt;&lt; <span class="hljs-string">&quot;arg&quot;</span> &lt;&lt; ind &lt;&lt; <span class="hljs-string">&quot;_l, &quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> OP2::OP_MAX:<br>        osMax &lt;&lt; <span class="hljs-string">&quot;arg&quot;</span> &lt;&lt; ind &lt;&lt; <span class="hljs-string">&quot;_l, &quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> OP2::OP_MIN:<br>        osMin &lt;&lt; <span class="hljs-string">&quot;arg&quot;</span> &lt;&lt; ind &lt;&lt; <span class="hljs-string">&quot;_l, &quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// error if this is a reduction it must be one of OP_MIN, OP_MAX or</span><br>        <span class="hljs-comment">// OP_INC</span><br>        assert(!arg.isReduction() ||<br>               (arg.accs == OP2::OP_INC || arg.accs == OP2::OP_MAX ||<br>                arg.accs == OP2::OP_MIN));<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 生成 omp 宏语句</span><br>  <span class="hljs-keyword">if</span> (os.str().length() &gt; <span class="hljs-number">0</span>) &#123;<br>    plusReds =<br>        <span class="hljs-string">&quot; reduction(+:&quot;</span> + plusReds.substr(<span class="hljs-number">0</span>, plusReds.length() - <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (osMin.str().length() &gt; <span class="hljs-number">0</span>) &#123;<br>    minReds = <span class="hljs-string">&quot; reduction(min:&quot;</span> + minReds.substr(<span class="hljs-number">0</span>, minReds.length() - <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (osMax.str().length() &gt; <span class="hljs-number">0</span>) &#123;<br>    maxReds = <span class="hljs-string">&quot; reduction(max:&quot;</span> + maxReds.substr(<span class="hljs-number">0</span>, maxReds.length() - <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;omp parallel for &quot;</span> + plusReds + <span class="hljs-string">&quot; &quot;</span> + minReds + <span class="hljs-string">&quot; &quot;</span> + maxReds;<br>&#125;<br><br>&#125; <span class="hljs-comment">// namespace OP2</span><br></code></pre></td></tr></table></figure><p>这项工作本质上难度不大，对于之后工作的意义在于：</p><p>网格划分部分的代码其实可以根据群论提供的对称性思想进行划分和生成。我们只需要简单描述网格方法，之后就可以生成那一部分的代码，并且自动将 OpenMP 的部分自动植入。</p><p>正在测试的例子：</p><img src="image2.png" width="80%" height="80%"><p>生成一个3维网格，每个格子里有10个点，之后会自由扩散。目前编码方法为自然编码，按长宽高依次顺次编号。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本周工作：</p><ol><li>总结 OP2 Clang，学习项目框架，自己基本复现。</li><li>总结 LLVM Clang Tooling 工作框架，于 github: Chivier/still</li><li>总结 LLVM Python Clang API，分析 Translation Unit 的行为，编写函数调用 demo 见 github: Chivier/still</li><li>学习文档工具 hdoc</li><li>继续完善 3D 绘图库，目前可以完成自动生成任意亏格小于2的管状模型</li><li>编译 LLVM 12，13，14 的文档，对比 LLVM Clang 接口</li><li>Sourcetrail 分析 Python Clang API</li></ol><p>之后工作计划：</p><ol><li>完善算例，将该算例发展成为网格Benchmark</li><li>基于改 Benchmark 测试自动 OpenMP 并行化方案的可行性</li><li>自动优化工具测试 SPH 原版代码</li></ol>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLVM</tag>
      
      <tag>DSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>New Laptop</title>
    <link href="/2021/03/25/2021/NewLaptop/"/>
    <url>/2021/03/25/2021/NewLaptop/</url>
    
    <content type="html"><![CDATA[<h1 id="Step-0-Before-All"><a href="#Step-0-Before-All" class="headerlink" title="Step 0: Before All"></a>Step 0: Before All</h1><p>2021年2月23日，我拿到了自己的新电脑，LG Gram 2021 16寸电脑。在这里记录我对电脑的配置过程和一些使用体验。</p><span id="more"></span><h2 id="Step-0-1-Reinstall-Windows"><a href="#Step-0-1-Reinstall-Windows" class="headerlink" title="Step 0.1: Reinstall Windows"></a>Step 0.1: Reinstall Windows</h2><p>在一切的一切之前，我先重新安装了系统。Windows家庭版缺少组策略和磁盘安全管理的功能，对我而言使用不是那么理想。所以在这里先重新安装了一些。不过这个时候问题已经出来了，重新安装Windows之后，由于驱动也被一并卸载了，所以需要重新安装。</p><p>百度lggram贴吧已经给出了一个解决方案：</p><p><a href="https://tieba.baidu.com/p/7239910408">https://tieba.baidu.com/p/7239910408</a></p><p>可以在这里下载LG Control Center</p><p>当然，也可以在LG官网的驱动支持里找到需要的内容。</p><h2 id="Step-0-2-Windows-Insider"><a href="#Step-0-2-Windows-Insider" class="headerlink" title="Step 0.2: Windows Insider"></a>Step 0.2: Windows Insider</h2><p>为了使用一些特殊的功能需求，在这里我加入了Windows Insider计划，不过为了笔记本的稳定和安全，我这台电脑加入的是Beta测试。同时用学校的KMS激活了一下我的Windows Pro。</p><h2 id="Step-0-3-Network"><a href="#Step-0-3-Network" class="headerlink" title="Step 0.3: Network"></a>Step 0.3: Network</h2><p>网络相关的配置是一切工作最重要的一个部分之一了。包含了下面这些工作：</p><ul><li>安装Clash for Windows，启用代理</li><li>安装Chrome Browser，启用Google的系列服务，包括我的密码、收藏夹、插件</li><li>找到之前的笔记本的SSH密钥对，放在用户目录下</li></ul><h1 id="Step1-Basic-Software-Install"><a href="#Step1-Basic-Software-Install" class="headerlink" title="Step1: Basic Software Install"></a>Step1: Basic Software Install</h1><p>下面我把自己常用的软件安装记录一下：</p><ol><li><p>搜狗输入法</p><p>这个应该不用太多解释，毕竟还是有中文输入的需求的，搜狗可以把你的输入习惯和词库记录，迁移性非常好。</p></li><li><p>Snipaste</p><p>这个是我个人比较常用的截图工具，在Microsoft Store里面下载。</p></li><li><p>Typora</p><p>Markdown个人最喜欢的编辑器</p><p>下载地址：<a href="https://typora.io/">https://typora.io/</a></p><p>这里补充一些，用于默认的主题都不是特批满意，个人在typora主页里面下载了额外的主题风格，我个人选择的是Ursine。</p><img src="image00.png"><p>在这里可以打开Style文件夹，对风格进行配置。</p></li><li><p>Eartrumpet</p><p>WIndows下最好用的音量管理工具，比原有的音量设置好用的多。</p><img src="image01.png"><p>同样在Microsoft Store里面下载。</p><p>这里我补充一个测量，因为Eartrumpet是一个独立的工具，两个喇叭按钮在下面放着可能会比较奇怪。移除Windows原生的音量控制会有点点小小的麻烦，具体操作如下：（这个时候就体现出组策略的优势了）</p><p><code>Windows</code>+<code>R</code>执行gpedit.msc</p><img src="image02.png"><p>如图所示，左侧的 <strong>User Configuration &gt; Administrative Templates &gt; Start Menu and Taskbar</strong>，在里面找到<strong>Remove the volumn control icon</strong>。启用这个选项就可以了。</p></li><li><p>AutoHotKey</p><p><a href="https://www.autohotkey.com/">https://www.autohotkey.com/</a></p><p>这个工具是一个必需品，为了下一个工具做准备。</p></li><li><p>Capslock-plus</p><p>一个非常好用的键盘扩展工具，具体的教程和介绍可以看这里：</p><p><a href="https://capslox.com/capslock-plus/">https://capslox.com/capslock-plus/</a></p><p>建议从此处下载：</p><p><a href="https://github.com/wo52616111/capslock-plus">https://github.com/wo52616111/capslock-plus</a></p><p>下载AHK代码，直接执行。</p></li><li><p>WIndows Terminal</p><p>阳间终端，虽然现在Windows的终端比以前好看了一点点，但是黑Windows Terminal还是没有什么可比性的。</p><p>Microsoft Store安装即可。</p><img src="image03.png"></li><li><p>社交通讯</p><p>QQ，微信，腾讯会议，telegram，飞书，Zoom</p></li><li><p>choco</p><p>Windows下安装的一个利器，可以简单快捷的安装各种其他软件</p><p><a href="https://chocolatey.org/install">https://chocolatey.org/install</a></p></li><li><p>gsudo</p><p>这个是用choco安装的一个便捷工具，作用和linux下的Sudo一样，可以在管理员权限下使用命令。</p></li><li><p>pandoc</p><p>又是一个非常重要的基础工具，可以作为插件给其他软件使用，用于各种格式的文件的转换。</p></li><li><p>Microsoft Office</p><p>Office 系列，用于常用编辑。</p></li><li><p>Visio</p><p>作图工具</p></li><li><p>Teamviewer</p><p>远程操作</p></li><li><p>VNC Viewer</p><p>VNC 控制台</p></li><li><p>Zotero</p><p>论文整理</p></li><li><p>Steam</p><p>为了摸鱼</p></li><li><p>Matlab</p><p>科研工具</p></li><li><p>Mathematica</p><p>计算器</p><p>破解方法：<a href="https://ibug.io/blog/2019/05/mathematica-keygen/">https://ibug.io/blog/2019/05/mathematica-keygen/</a></p></li><li><p>Foxit Reader</p><p>PDF阅读器、编辑器、OCR识别</p></li><li><p>Source Code Pro</p><p>字体配置</p><p><a href="https://fonts.google.com/specimen/Source+Code+Pro?preview.text_type=custom">https://fonts.google.com/specimen/Source+Code+Pro?preview.text_type=custom</a></p><p>Google 字体下载</p><p>解压之后放在<code>C:\Windows\Fonts</code>里即可</p><p>同时补充一个中文字体：Sarasa</p><p>安装方法同理</p></li><li><p>Bandizip</p><p>解压软件，7Zip的界面太丑了，有点难忍</p></li><li><p>Fences</p><p>桌面整理管理工具，可以用Nimi Places代替</p><p>总Steam里购买下载</p></li></ol><h1 id="Step2-Programming-Environment"><a href="#Step2-Programming-Environment" class="headerlink" title="Step2: Programming Environment"></a>Step2: Programming Environment</h1><h2 id="2-1-Python"><a href="#2-1-Python" class="headerlink" title="2.1 Python"></a>2.1 Python</h2><p>先把最简单的工具安装起来，这个直接在官网下载安装程序就OK了。</p><h2 id="2-2-Visual-Studio"><a href="#2-2-Visual-Studio" class="headerlink" title="2.2 Visual Studio"></a>2.2 Visual Studio</h2><h2 id="2-3-Visual-Studio-Code"><a href="#2-3-Visual-Studio-Code" class="headerlink" title="2.3 Visual Studio Code"></a>2.3 Visual Studio Code</h2><p>这个才是真正的核心工具，插件完善，功能多元。</p><p>至于插件安装和配置之后会写一篇，我目前都用VSCode的同步功能，非常好用。</p><h2 id="2-4-Git"><a href="#2-4-Git" class="headerlink" title="2.4 Git"></a>2.4 Git</h2><p>版本管理工具，不可或缺。</p><h2 id="2-5-MSYS"><a href="#2-5-MSYS" class="headerlink" title="2.5 MSYS"></a>2.5 MSYS</h2><p><a href="https://www.msys2.org/">https://www.msys2.org/</a></p><p>用类似Arch的管理方法去管理各种基础编译环境，作用和以前的Cygwin是一样的，不过更加优秀。</p><h2 id="2-6-WSL2"><a href="#2-6-WSL2" class="headerlink" title="2.6 WSL2"></a>2.6 WSL2</h2><p>这个是我日常工作不可或缺的一部分了，是我最常用的虚拟工作环境。</p><p><a href="https://www.omgubuntu.co.uk/how-to-install-wsl2-on-windows-10">https://www.omgubuntu.co.uk/how-to-install-wsl2-on-windows-10</a></p><p>此处为安装教程。</p><img src="image04.png"><p>如果安装不成功，需要下载<em>wsl_update_x64</em>进行补丁。</p><p>安装之后就可以顺利启动了。</p><h2 id="2-7-Jetbrains"><a href="#2-7-Jetbrains" class="headerlink" title="2.7 Jetbrains"></a>2.7 Jetbrains</h2><ul><li>CLion</li><li>Pycharm</li><li>PHPStorm</li><li>WebStorm</li><li>Idea</li></ul><p>这5个都属于我的常用工具，官网下载即可。</p><h2 id="2-8-X410"><a href="#2-8-X410" class="headerlink" title="2.8 X410"></a>2.8 X410</h2><p>X转发服务器，这里选用了X410，Microsoft Store 购买。</p><p>安装之后需要将WSL2和X410进行绑定和使用。使用有些技巧，在X410启动之后，需要更改WSL2的显示设置，在bashrc末尾添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DISPLAY_NUMBER=<span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-built_in">export</span> DISPLAY=$(grep -m 1 nameserver /etc/resolv.conf | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>):<span class="hljs-variable">$DISPLAY_NUMBER</span><br><span class="hljs-built_in">export</span> LIBGL_ALWAYS_INDIRECT=1<br></code></pre></td></tr></table></figure><p>这样就实现了WSL的X转发。</p><h2 id="2-9-Tilix"><a href="#2-9-Tilix" class="headerlink" title="2.9 Tilix"></a>2.9 Tilix</h2><p>Tilix是我个人偏好的终端，是在Linux下分屏最方便的终端。安装在WSL中进行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install tilix<br></code></pre></td></tr></table></figure><p>安装即可。</p><p>在windows中更自然的使用，需要做一下额外的调整和配置。</p><p>用AHK写一个快速启动的配置，使用更加像Linux。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">^!t::<br>    Run, C:\app\tilix\tilix.vbs<br>Return<br><br>^BackSpace:: ;;Delete previous word<br>    Send ^+&#123;Left&#125;&#123;Del&#125;<br>Return<br></code></pre></td></tr></table></figure><p>这里有一个使用习惯，Ctrl + BackSpace用于删除整个单词。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Softwares</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>X-forwarding Check</title>
    <link href="/2020/09/29/2021/x-forwarding-check/"/>
    <url>/2020/09/29/2021/x-forwarding-check/</url>
    
    <content type="html"><![CDATA[<p>When I use Linux or wanna use x-forward to use remote linux applications, I have to check out the x-forward port.</p><p>But how to check is a really fuszy problem.<br>  <span id="more"></span></p><p><strong>So Is there a command to list all open displays on a machine?</strong></p><p>Reference: <a href="https://unix.stackexchange.com/questions/17255/is-there-a-command-to-list-all-open-displays-on-a-machine/17278#17278">Stackoverflow: Is there a command to list all open displays on a machine</a></p><blockquote><p>If you want the X connection forwarded over SSH, you need to enable it on both the server side and the client side. (Depending on the distribution, it may be enabled or disabled by default.) On the server side, make sure that you have X11Forwarding yes in /etc/sshd_config (or /etc/ssh/sshd_config or wherever the configuration file is). On the client side, pass the -X option to the ssh command, or put ForwardX11 in your ~/.ssh/config.<br>If you run ssh -X localhost, you should see that $DISPLAY is (probably) localhost:10.0. Contrast with :0.0, which is the value when you’re not connected over SSH. (The .0 part may be omitted; it’s a screen number, but multiple screens are rarely used.) There are two forms of X displays that you’re likely to ever encounter:<br>Local displays, with nothing before the :.<br>TCP displays, with a hostname before the :.<br>With ssh -X localhost, you can access the X server through both displays, but the applications will use a different method: :NUMBER accesses the server via local sockets and shared memory, whereas HOSTNAME:NUMBER accesses the server over TCP, which is slower and disables some extensions.<br>Note that you need a form of authorization to access an X server, called a cookie and normally stored behind the scenes in the file ~/.Xauthority. If you’re using ssh to access a different user account, or if your distribution puts the cookies in a different file, you may find that DISPLAY=:0 doesn’t work within the SSH session (but ssh -X will, if it’s enabled in the server; you never need to mess with XAUTHORITY when doing ssh -X). If that’s a problem, you need to set the XAUTHORITY environment variable or obtain the other user’s cookies.<br>To answer your actual question:<br>Local displays correspond to a socket in /tmp/.X11-unix.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">(<span class="hljs-built_in">cd</span> /tmp/.X11-unix &amp;&amp; <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X*; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;:<span class="hljs-variable">$&#123;x#X&#125;</span>&quot;</span>; <span class="hljs-keyword">done</span>)</span><br></code></pre></td></tr></table></figure><p>Remote displays correspond to open TCP ports above 6000; accessing display number N on machine M is done by connecting to TCP port 6000+N on machine M. From machine M itself:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">&gt;netstat -lnt | awk &#x27;<br> sub(/.*:/,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-variable">$4</span>) &amp;&amp; <span class="hljs-variable">$4</span> &gt;= 6000 &amp;&amp; <span class="hljs-variable">$4</span> &lt; 6100 &#123;<br>   <span class="hljs-keyword">print</span> (<span class="hljs-variable">$1</span> == <span class="hljs-string">&quot;tcp6&quot;</span> ? <span class="hljs-string">&quot;ip6-localhost:&quot;</span> : <span class="hljs-string">&quot;localhost:&quot;</span>) (<span class="hljs-variable">$4</span> - 6000)<br> &#125;&#x27;<br></code></pre></td></tr></table></figure><p>(The rest of this bullet point is of academic interest only.)<br>From another machine, you can use nmap -p 6000-6099 host_name to probe open TCP ports in the usual range. It’s rare nowadays to have X servers listening on a TCP socket, especially outside the loopback interface.<br>Strictly speaking, another application could be using a port in the range usually used by X servers. You can tell whether an X server is listening by checking which program has the port open.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">&gt;lsof -i -n | awk <span class="hljs-string">&#x27;<span class="hljs-subst">$9</span> ~ /:60[0-9][0-9]$/ &#123;print&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>If that shows something ambiguous like sshd, there’s no way to know for sure whether it’s an X server or a coincidence.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
      <tag>Linux Tricks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL 2 Quick Fix</title>
    <link href="/2020/09/29/2021/WSL2-Quick-Fix/"/>
    <url>/2020/09/29/2021/WSL2-Quick-Fix/</url>
    
    <content type="html"><![CDATA[  <span id="more"></span><p>As is a well-known fact, Windows WSL 2 is not stable enough. Especially, you have taken some strange settings about your<br>Network. Here I will give out a common way to fix the WSL2 errors, such as ‘0xffffffff’ or something else.</p><h1 id="Method-1-Netsh"><a href="#Method-1-Netsh" class="headerlink" title="Method 1: Netsh"></a>Method 1: Netsh</h1><p>Input <code>netsh.exe winsock reset</code> in the powershell with administractor permission.</p><h1 id="Method-2-Automatic-scan-and-fix"><a href="#Method-2-Automatic-scan-and-fix" class="headerlink" title="Method 2: Automatic scan and fix"></a>Method 2: Automatic scan and fix</h1><p>Input <code>sfc /scannow</code> in the powershell is okay.</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>System</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Themes</title>
    <link href="/2020/09/18/2021/Linux-Themes/"/>
    <url>/2020/09/18/2021/Linux-Themes/</url>
    
    <content type="html"><![CDATA[<p>Here is a simple sharing about how to modify the themes in Ubuntu.</p><span id="more"></span><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>Before changing, the first is to install ‘gnome-tweaks’ &amp; ‘gnome-tweak-tool’. You can use ‘apt/apt-get’ to install.</p><h1 id="Download-and-Set"><a href="#Download-and-Set" class="headerlink" title="Download and Set"></a>Download and Set</h1><p>Which theme to choose is your freedom. You can choose from here:</p><p><a href="https://itsfoss.com/best-gtk-themes/">https://itsfoss.com/best-gtk-themes/</a></p><p>and put themes in ‘.icons’, ‘.themes’.</p><p>Finally, choose themes in ‘tweaks’.</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rebuild My Home - 04 Beautify</title>
    <link href="/2020/02/11/2021/Rebuild-My-Home-04-Beautify/"/>
    <url>/2020/02/11/2021/Rebuild-My-Home-04-Beautify/</url>
    
    <content type="html"><![CDATA[<h1 id="Remove-Ubuntu-dock"><a href="#Remove-Ubuntu-dock" class="headerlink" title="Remove Ubuntu dock"></a>Remove Ubuntu dock</h1><p>First of all, I wanna remove the left bar of my computer. I really don’t like it.</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt remove gnome-shell-extension-ubuntu-dock<br></code></pre></td></tr></table></figure><h1 id="Stacer"><a href="#Stacer" class="headerlink" title="Stacer"></a>Stacer</h1><p>A useful tool to help you decide which app to start when you boot your system. Also, it can help you clean the rubbish in your system.</p><h1 id="Plank"><a href="#Plank" class="headerlink" title="Plank"></a>Plank</h1><p>My favorite dock. sudo apt-get to install is okay.</p><h1 id="Albert"><a href="#Albert" class="headerlink" title="Albert"></a>Albert</h1><p>Opening any file or application is easy with Albert. It can search the file system with its files plugin and automatically looks for any installed application. With the <code>&gt;</code> prefix, it runs shell scripts in a heartbeat.</p><h1 id="Flat-icon"><a href="#Flat-icon" class="headerlink" title="Flat icon"></a>Flat icon</h1><p><a href="https://github.com/daniruiz/flat-remix">Flat remix</a></p><h1 id="Gnome-dash-fix"><a href="#Gnome-dash-fix" class="headerlink" title="Gnome dash fix"></a>Gnome dash fix</h1><p>Google it and I think you will like it ~</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rebuild My Home - 03 Programming</title>
    <link href="/2020/02/11/2021/Rebuild-My-Home-03-Programming/"/>
    <url>/2020/02/11/2021/Rebuild-My-Home-03-Programming/</url>
    
    <content type="html"><![CDATA[<p>As a programmer, I don’t think you can bear only working with ‘gdb’ and ‘vim’. Tools can never too better.</p><p>I will introduce my working environment.</p><span id="more"></span><h1 id="ZSH-amp-Tilix-amp-Gogh"><a href="#ZSH-amp-Tilix-amp-Gogh" class="headerlink" title="ZSH &amp; Tilix &amp; Gogh"></a>ZSH &amp; Tilix &amp; Gogh</h1><p>Ah, the most unbearable thing in Ubuntu is the default terminal is really ugly. Also I do not like bash.</p><p>So I really recommend zsh + tilix.</p><h2 id="ZSH-install"><a href="#ZSH-install" class="headerlink" title="ZSH install"></a>ZSH install</h2><ol><li><p>Install zsh core and basic tools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git zsh curl<br></code></pre></td></tr></table></figure></li><li><p>Execute</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>And then you can install zsh automatically.</p></li><li><p>Set zsh as default shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s $(<span class="hljs-built_in">which</span> zsh)<br></code></pre></td></tr></table></figure></li><li><p>Set zsh theme and edit your zsh configure.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>I need to add some my aliases, also I need to set up some plugins for my zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/custom/plugins<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-history-substring-search<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><p>Don’t forget to add them to your .zshrc/plugins</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">plugins=(git zsh-history-substring-search zsh-autosuggestions colored-man-pages zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure><h2 id="Tilix"><a href="#Tilix" class="headerlink" title="Tilix"></a>Tilix</h2></li></ol><p>So, why tilix?</p><p>tilix is a really useful terminal that can split screen easily.</p><p>Tilix is easy to install.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install tilix<br></code></pre></td></tr></table></figure><p>But I wanna to set tilix as my default terminal.</p><p>Here is a tutorial:</p><ol><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --config x-terminal-emulator<br></code></pre></td></tr></table></figure><p>Through this you can choose your default startup terminal emulator.</p></li><li><p>However, if you try to use right click and ‘Open terminal here’, you will find the terminal is still gnome-terminal.</p><p>About this problem I will share how to edit ‘right click’ panel in another tutorial.</p></li></ol><h2 id="Gogh"><a href="#Gogh" class="headerlink" title="Gogh"></a>Gogh</h2><p>Um, we almost finish all the steps. But I am unsatisfied with the color theme. Here I will share a perfect tool with you — ‘gogh.sh’</p><p><a href="https://github.com/Mayccoll/Gogh">gogh github</a></p><p>I recommend install it from here:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash -c  <span class="hljs-string">&quot;<span class="hljs-subst">$(wget -qO- https://git.io/vQgMr)</span>&quot;</span> <br></code></pre></td></tr></table></figure><p>And then choose your favorite color theme to download and then you can also choose in tilix preference.</p><h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><p>My favorite IDE, you can view more information here: <a href="https://code.visualstudio.com/">VS Code</a></p><h1 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h1><p>For Visualization.</p><p>Download an install is okay.</p><p><a href="https://www.qt.io/">Qt</a></p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rebuild My Home - 02 Office</title>
    <link href="/2020/02/11/2021/Rebuild-My-Home-02-Office/"/>
    <url>/2020/02/11/2021/Rebuild-My-Home-02-Office/</url>
    
    <content type="html"><![CDATA[<p>Many people say that Ubuntu is not fit for Office work. I do not agree. Here I will introduce some apps to you and teach you how to install them.</p><span id="more"></span><h1 id="Netease-Music"><a href="#Netease-Music" class="headerlink" title="Netease Music"></a>Netease Music</h1><p>Hmm, no music no life.</p><p>You can download from <a href="https://music.163.com/#/download">Netease Homepage</a></p><p>And you can find a Linux version.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i netease-cloud-music_xxx(version).deb<br></code></pre></td></tr></table></figure><p>And now I can build my Ubuntu with beautiful music.</p><h1 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h1><p>WPS Office is a perfect office on linux. You can write documents, make PPTs very fluently with its help.</p><p>You can download here:</p><p><a href="https://www.wps.cn/product/wpslinux">WPS foe linux</a></p><p>I prefer using DEB file for installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i wps-offxxx.deb<br></code></pre></td></tr></table></figure><p>You might meet some trouble here, if your Ubuntu is a grand new one.</p><p>You might meet error information like:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg: dependency problems prevent configuration of wps-office:<br> wps-office depends on libgtk2.0-0; however:<br>  Package libgtk2.0-0 is not installed.<br></code></pre></td></tr></table></figure><p>This means you need to install ‘libgtk2.0-common’. If there are other errors, you can solve by fix-broken.</p><p>Just like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ligtk2.0-common<br>sudo apt-get --fix-broken install<br></code></pre></td></tr></table></figure><p>After fix gtk dependencies, you can redo the install step by executing <code>sudo dpkg -i xxx</code></p><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>As a Markdown lover, I cannot live without an elegant markdown editor.</p><p>You can follow the installation steps on their home page.</p><p><a href="https://www.typora.io/#linux">Typora for linux</a></p><p>By the way I don’t like the default theme in Typora at all.</p><p>You can choose your favorite style in <a href="http://theme.typora.io/">Typora theme</a>.</p><p>I prefer using <a href="http://theme.typora.io/theme/Ursine/">Ursine</a>.</p><p>Download from <a href="https://github.com/aCluelessDanny/typora-theme-ursine/releases/tag/1.8.1">Github release</a>. You can get a zip file after downloading. Unzip it and copy all the file in <code>Ursine folder</code> into your <code>Typora Theme Folder</code>. Mostly, you can find it at <code>~/.config/Typora/themes</code>. Also, you can find it in your Typora Settings, File &gt; Settings &gt; Appearance &gt; Theme Folder.</p><h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><p>Well, I think I needn’t to introduce Chrome.</p><h1 id="Sogou-Pinyin"><a href="#Sogou-Pinyin" class="headerlink" title="Sogou Pinyin"></a>Sogou Pinyin</h1><p>As a Chinese, I cannot avoid inputing Chinese sometimes. However I recommend Sogou pinyin not  only for typing Chinese. Besides,Sogou pinyin has English spell hint function. I like it very much.</p><p>However, install Sogou pinyin is a little difficult.</p><p>Firstly, you need install Fcitx as a frame to hole Sogou pinyin.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install fcitx<br></code></pre></td></tr></table></figure><p>And then download Sogou here: <a href="https://pinyin.sogou.com/linux">Sogou pinyin for linux</a></p><p>Use <code>sudo dpkg -i</code> to install it.</p><p>Now open settings panel, choose <code>Region &amp; Language</code> and click <code>Manage Installed language</code>. </p><p>Here you can install Chinese language configure for your computer. And you should choose Keyboard input method system to fcitx.</p><p>Next step is reboot. After rebooting your computer, you can find a keyboard like icon.</p><p>And now it’s time to add input method. </p><p>However I have another important thing to share with you. As a programmer, I frequently use <code>shift</code> on my keyboard. But after using fcitx, <code>shift</code> will change your input language, and it is really annoying. </p><p>Here is a tutorial about how to disable <code>shift</code>:</p><ol><li><p>Fcitx setting is saved here: <code>~/.config/fcitx/config</code></p></li><li><p>Edit it, here are enough information about every configure in fcitx.</p></li><li><p>Finally, do not forget to lock it.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod -w config<br></code></pre></td></tr></table></figure></li></ol><h1 id="Snap-store"><a href="#Snap-store" class="headerlink" title="Snap store"></a>Snap store</h1><p>Here I am going to install a series of apps by using snap store system. It’s really convenient to install through snap.</p><p>I will list out here:</p><ul><li><p>Shotcut</p><p>Free, cross-platform, open source video editor</p></li><li><p>VLC player</p><p>The ultimate media player</p></li><li><p>MailSpring</p><p>My favorite email client</p></li><li><p>GNU Image Manipulation Program </p><p>PS for ubuntu</p></li></ul><h1 id="Pandoc"><a href="#Pandoc" class="headerlink" title="Pandoc"></a>Pandoc</h1><p><a href="https://pandoc.org/">pandoc</a> is a really powerful tool for documentations formats converting. </p><p>Download DEB file and install it is okay.</p><h1 id="Dia"><a href="#Dia" class="headerlink" title="Dia"></a>Dia</h1><p>An convenient app to draw almost all kinds of simple graphs you need.</p><p>It’s just like VISIO in linux.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install dia <br></code></pre></td></tr></table></figure><h1 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h1><p>Also there is a QQ-for-linux you can easily install by ‘apt install’.</p><p>However, it is really awful: easily to get unconnected and you can only scan the QR code to login.</p><p>So I recommend wine-QQ.</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rebuild My Home - 01 Get ready</title>
    <link href="/2020/02/11/2021/Rebuild-My-Home-01-Get-ready/"/>
    <url>/2020/02/11/2021/Rebuild-My-Home-01-Get-ready/</url>
    
    <content type="html"><![CDATA[<h1 id="Why-Ubuntu"><a href="#Why-Ubuntu" class="headerlink" title="Why Ubuntu?"></a>Why Ubuntu?</h1><p>In the very beginnning in this serials of tutorial, I wanna quote some words from Mr. Richard Feyman.</p><span id="more"></span><blockquote><p>What I cannot create, I do not understand.</p></blockquote><p>Linux family systems do highly respect their users. They have <code>sudo</code> option to allow users to do anything they want to do (Somethings may cause some big trouble). So, if you can understand the constucture and master some knowledge about computer science, Linux is a really wonderful choice.</p><p>But why Ubuntu?</p><p>Actually, there are many reasons. Firstly, I wanna say Ubuntu is one of the most popular Linux version in the world. There are enough informantion and resources about Ubuntu (You will find how important it is later). Another reason is my personal preference, I regard Ubuntu is one of the most elegant system in the world, light, easy to use, beautiful GUI, fast, easy to build. All in all, Ubuntu is the best system in my eyes.</p><p>So, let our story begin.</p><h1 id="FFFFirst"><a href="#FFFFirst" class="headerlink" title="FFFFirst"></a>FFFFirst</h1><p>FFFFirst things(Why 4 Fs, Hmmm, there are 4 very very important things, I cannot sort their importance) are:</p><h2 id="Install-vim"><a href="#Install-vim" class="headerlink" title="Install vim"></a>Install vim</h2><p>Hmm, I wanna emphasize here that <code>vi</code> is not <code>vim</code>. They are different apps.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install vim<br></code></pre></td></tr></table></figure><p>And if you are a really green hand on Linux. I recommand some other tools for you.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nano<br>sudo apt install gedit<br>sudo apt install geany<br></code></pre></td></tr></table></figure><p>There editors are all quite easy to get and easy to use.</p><h2 id="Change-the-source"><a href="#Change-the-source" class="headerlink" title="Change the source"></a>Change the source</h2><p>As I am a Chinese, the official source is too slow for me.</p><p>Here I recommand a tool:</p><p><a href="https://mirrors.ustc.edu.cn/repogen/">repository file generator</a></p><p>You can genetate a new source config file easily.</p><p>And then you just need to backup your old source config and create a new file here. Just like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo cp /etc/apt/source.list /etc/apt/source.list.old<br>sudo vim /etc/apt/source.list<br><span class="hljs-comment"># copy the source.list generated before</span><br></code></pre></td></tr></table></figure><h2 id="Update-source"><a href="#Update-source" class="headerlink" title="Update source"></a>Update source</h2><p>And don’t forget to update your source after change the source.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt upgrade<br></code></pre></td></tr></table></figure><h2 id="Build-proxy"><a href="#Build-proxy" class="headerlink" title="Build proxy"></a>Build proxy</h2><p>It’s essential for Chinese users, many forums and resources are unavailable unless you have VPN.<br>(But I won’t teach you how to build proxy here, I will show you about it in another tutorial)</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu Hotspot Creating and Configuring</title>
    <link href="/2019/12/05/2021/Ubuntu-Hotspot-Creating-and-Configuring/"/>
    <url>/2019/12/05/2021/Ubuntu-Hotspot-Creating-and-Configuring/</url>
    
    <content type="html"><![CDATA[ <span id="more"></span><p>Okay, it’s a simple tutorial about how to create and configure hotspot in Ubuntu 19.10.</p><h1 id="Creating-Hotspot"><a href="#Creating-Hotspot" class="headerlink" title="Creating Hotspot"></a>Creating Hotspot</h1><p>In a GUI interface, creating hotspot has become quite simple in Ubuntu. Just like the picture showing below.</p><img src="pic1.png"><h1 id="Configuring-Hotspot"><a href="#Configuring-Hotspot" class="headerlink" title="Configuring Hotspot"></a>Configuring Hotspot</h1>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPV6-Config in Ubuntu</title>
    <link href="/2019/12/03/2021/IPV6-Config-in-Ubuntu/"/>
    <url>/2019/12/03/2021/IPV6-Config-in-Ubuntu/</url>
    
    <content type="html"><![CDATA[<p>Linux is a simple OS, and you can almost define every system configure as you like. Today’s problem is about IPV6. In Windows or Mac, ipv6 config is done automaticlly by the system. However, in Linux, it’s a little hard to do such work. You have to change some system-conf file manually.</p><span id="more"></span><h1 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h1><p>Install some dependencies is required:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install miredo<br></code></pre></td></tr></table></figure><h1 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h1><p>Modify file <code>/etc/default/ufw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/default/ufw<br></code></pre></td></tr></table></figure><p>And change <code>IPV6=no</code> to <code>IPV6=yes</code>. If <code>IPV6</code> has already changed into <code>yes</code>, just skip this step. </p><h1 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h1><p>Restart the system serivce:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo invoke-rc.d networking restart<br></code></pre></td></tr></table></figure><h1 id="Step-4-Optional"><a href="#Step-4-Optional" class="headerlink" title="Step 4 (Optional)"></a>Step 4 (Optional)</h1><p>There is something more we have to do if you are connecting into <code>ethernet</code> like your education-network.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /etc/sysctl.d/10-ipv6-privacy.conf<br></code></pre></td></tr></table></figure><p>Change</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reStructuredText">net.ipv6.conf.all.use_tempaddr &#x3D; 2<br>net.ipv6.conf.default.use_tempaddr &#x3D; 2<br></code></pre></td></tr></table></figure><p>into </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reStructuredText">net.ipv6.conf.all.use_tempaddr &#x3D; 0<br>net.ipv6.conf.default.use_tempaddr &#x3D; 0<br></code></pre></td></tr></table></figure><p>And then refresh your configures:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl --system<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Md-quick-show</title>
    <link href="/2019/11/26/2021/Md-quick-show/"/>
    <url>/2019/11/26/2021/Md-quick-show/</url>
    
    <content type="html"><![CDATA[<h1 id="花里胡哨工具集-001"><a href="#花里胡哨工具集-001" class="headerlink" title="花里胡哨工具集 - 001"></a>花里胡哨工具集 - 001</h1><p>关于新坑：</p><p>这里挖了一个新坑，这一个系列叫做<code>Fansy tools</code>合集，用来介绍各种各样玄妙的工具～～～</p><span id="more"></span><h1 id="综述介绍"><a href="#综述介绍" class="headerlink" title="综述介绍"></a>综述介绍</h1><p>今天介绍的主要是我们的一套工具链：</p><ul><li>reveal.js 引擎</li><li>Maekdown 语法分析</li><li>基于Python的转换器</li></ul><p>听到这里，大部分人还没有明白我们到底想做些什么。</p><p>这里说明清楚： 我们的工具是一个讲Markdown快捷转换成HTML可展示页面的工具</p><p>使用流程是这样的</p><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>我们的环境需求如下两样东西：</p><ol><li>Mdast提供的markdown语法分析</li><li>reveal.js提供的引擎</li></ol><p>下载方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/hakimel/reveal.js.git<br><br>npm install -g remark-cli<br>npm install -g remark-preset-wooorm<br></code></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>具体的转换工具在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/Chivier/Md-quick-show<br></code></pre></td></tr></table></figure><p>运行方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python heading.py<br></code></pre></td></tr></table></figure><p>之后输入markdown文件名就可以得到一个<code>index.html</code>文件</p><p>复制index.html到reveal.js即可</p><h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><p>后面有空会将他完全部署到服务器上，这样就有一个网页，大家拖拽Markdown上传，就可以直接进行展示了。</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advancing on X86 Assembly 1 - Registers &amp; Memory</title>
    <link href="/2019/11/15/2021/Advancing-on-X86-Assembly-1-Registers-Memory/"/>
    <url>/2019/11/15/2021/Advancing-on-X86-Assembly-1-Registers-Memory/</url>
    
    <content type="html"><![CDATA[<p>对于X86的汇编我们的认识框架是这样的：</p><ul><li><p>认识寄存器，认识内存管理模式（确定数据存储位置）</p></li><li><p>了解存取模式（确定数据存取方法）</p></li><li><p>学习基本运算指令</p></li><li><p>多过程的处理</p></li><li><p>IO指令和中断</p></li><li><p>协处理器指令</p></li></ul><span id="more"></span><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="http://flint.cs.yale.edu/cs421/papers/x86-asm/x86-registers.png" alt="X86Registers"></p><p>General-Purpose Registers (GPR) </p><p>The 8 GPRs are:</p><ol><li>Accumulator register (AX). Used in arithmetic operations</li><li>Counter register (CX). Used in shift/rotate instructions and loops.</li><li>Data register (DX). Used in arithmetic operations and I/O operations.</li><li>Base register (BX). Used as a pointer to data (located in segment register DS, when in segmented mode).</li><li>Stack Pointer register (SP). Pointer to the top of the stack.</li><li>Stack Base Pointer register (BP). Used to point to the base of the stack.</li><li>Source Index register (SI). Used as a pointer to a source in stream operations.</li><li>Destination Index register (DI). Used as a pointer to a destination in stream operations.</li></ol><h2 id="专用寄存器"><a href="#专用寄存器" class="headerlink" title="专用寄存器"></a>专用寄存器</h2><p>有三个专用的寄存器：IP、SP、FLAGS</p><ul><li><p>IP（RIP、EIP）： 指令指针，指向下一条运行的指令</p></li><li><p>SP（RSP、ESP）： 堆栈指针。通过指针存取堆栈存储器中的数据</p></li><li><p>RFLAGS：</p><table><thead><tr><th align="left">Position</th><th></th></tr></thead><tbody><tr><td align="left">0.</td><td>CF : Carry Flag. Set if the last arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the size of the register. This is then checked when the operation is followed with an add-with-carry or subtract-with-borrow to deal with values too large for just one register to contain.</td></tr><tr><td align="left">2.</td><td>PF : Parity Flag. Set if the number of set bits in the least significant byte is a multiple of 2.</td></tr><tr><td align="left">4.</td><td>AF : Adjust Flag. Carry of Binary Code Decimal (BCD) numbers arithmetic operations.</td></tr><tr><td align="left">6.</td><td>ZF : Zero Flag. Set if the result of an operation is Zero (0).</td></tr><tr><td align="left">7.</td><td>SF : Sign Flag. Set if the result of an operation is negative.</td></tr><tr><td align="left">8.</td><td>TF : Trap Flag. Set if step by step debugging.</td></tr><tr><td align="left">9.</td><td>IF : Interruption Flag. Set if interrupts are enabled.</td></tr><tr><td align="left">10.</td><td>DF : Direction Flag. Stream direction. If set, string operations will decrement their pointer rather than incrementing it, reading memory backwards.</td></tr><tr><td align="left">11.</td><td>OF : Overflow Flag. Set if signed arithmetic operations result in a value too large for the register to contain.</td></tr><tr><td align="left">12-13.</td><td>IOPL : I/O Privilege Level field (2 bits). I/O Privilege Level of the current process.</td></tr><tr><td align="left">14.</td><td>NT : Nested Task flag. Controls chaining of interrupts. Set if the current process is linked to the next process.</td></tr><tr><td align="left">16.</td><td>RF : Resume Flag. Response to debug exceptions.</td></tr><tr><td align="left">17.</td><td>VM : Virtual-8086 Mode. Set if in 8086 compatibility mode.</td></tr><tr><td align="left">18.</td><td>AC : Alignment Check. Set if alignment checking of memory references is done.</td></tr><tr><td align="left">19.</td><td>VIF : Virtual Interrupt Flag. Virtual image of IF.</td></tr><tr><td align="left">20.</td><td>VIP : Virtual Interrupt Pending flag. Set if an interrupt is pending.</td></tr><tr><td align="left">21.</td><td>ID : Identification Flag. Support for CPUID instruction if can be set.</td></tr></tbody></table></li></ul><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>The 6 Segment Registers are:</p><ul><li>Stack Segment (SS). Pointer to the stack.</li><li>Code Segment (CS). Pointer to the code.</li><li>Data Segment (DS). Pointer to the data.</li><li>Extra Segment (ES). Pointer to extra data (‘E’ stands for ‘Extra’).</li><li>F Segment (FS). Pointer to more extra data (‘F’ comes after ‘E’).</li><li>G Segment (GS). Pointer to still more extra data (‘G’ comes after ‘F’).</li></ul><h1 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h1><p>不论何种寻址模式，我们基本上的框架都算是基于<code>segment address + offset address</code>进行计算的，每个<code>segment address</code>对应1MB空间，例如：</p><p>2000H — 起始地址：20000H ～ 种植地址：2FFFFH</p><p>加上偏移就可以定位具体的位置。</p><h2 id="实模式寻址"><a href="#实模式寻址" class="headerlink" title="实模式寻址"></a>实模式寻址</h2><p>实模式寻址就是直接的由base address + offset得到</p><p>默认的组合有：</p><img src="Picture1.png" width="80%" height="80%"><h2 id="保护模式寻址"><a href="#保护模式寻址" class="headerlink" title="保护模式寻址"></a>保护模式寻址</h2><p>保护模式的寻址模式其实是一种扩张性质的描述方法：</p><p><img src="https://pic4.zhimg.com/80/v2-1a08d48367745c2870e8818b7881b373_hd.jpg"></p><p>上面的这一张图里面就交代了**全局描述符表(GDT)**的结构。</p><p>G 表示粒度，G=1，界限值以4KB为单位，G=0，以字节为单位。</p><p>AV位：Available for use by system software，提供给系统软件使用。可用于指示段是否有效。AV=0，段有效；AV=1，段有效。</p><p>D位：指示保护模式下或实模式下80386~Core2指令如何访问寄存器和存储器数据。</p><p>如果D=0，则指令与8086~80286兼容，是16位指令。在默认情况下，用16位偏移地址和16位寄存器。这种模式通常称为16位指令模式或DOS模式。<br>如果D=1，则指示32位指令模式、32位段。</p><p>P：P=0，段不在内存中；P=1，段在内存中。</p><p>DPL：描述符特权级，取值0~3，确定段的特权级，为任务允许访问该段的最低特权级。</p><p>S：S=1表示该描述符为代码或数据段描述符；S=0，表示该描述符为系统段描述符。</p><p>Type：段的类型（与段描述符类型相关）。</p><h2 id="平展模式"><a href="#平展模式" class="headerlink" title="平展模式"></a>平展模式</h2><p>不分页不分段直接访问的模式</p><h1 id="Something-about-Moving-Data"><a href="#Something-about-Moving-Data" class="headerlink" title="Something about Moving Data"></a>Something about Moving Data</h1><img src="Picture2.png" width="80%" height="80%"><p>就MOV指令而言：<br>不允许段寄存器到段寄存器的MOV指令。<br>CS不能作为MOV指令的目的操作数。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Assembly</tag>
      
      <tag>Programming Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex Package Management in Ubuntu</title>
    <link href="/2019/11/10/2021/Latex-Package-Management-in-Ubuntu/"/>
    <url>/2019/11/10/2021/Latex-Package-Management-in-Ubuntu/</url>
    
    <content type="html"><![CDATA[<p>上次确实介绍了一些关于Linux Latex的基本使用，但是过多的Package让人头皮发麻，所以今天就介绍与点简单的package处理方法。</p><span id="more"></span><h2 id="方法一：简单粗暴"><a href="#方法一：简单粗暴" class="headerlink" title="方法一：简单粗暴"></a>方法一：简单粗暴</h2><p>讲道理，与其考虑缺这缺那，不如全部安装。所以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install texlive-full<br></code></pre></td></tr></table></figure><p>至此，问题全部解决</p><h2 id="方法二：高级工具"><a href="#方法二：高级工具" class="headerlink" title="方法二：高级工具"></a>方法二：高级工具</h2><p>这里介绍一下一个LaTeX Package管理工具：<code>tlmgr</code></p><p>这个工具安装可以直接<code>apt-get</code>进行安装处理</p><p>使用第一步是进入你的package管理目录，这个在之前的Blog里面有提到。</p><p>在该目录同级的位置，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlmgr init-usertree<br></code></pre></td></tr></table></figure><p>可能会需要sudo</p><p>我们之后就可以进行package的简单安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlmgr install &#123;<span class="hljs-variable">$package_name</span>&#125;<br></code></pre></td></tr></table></figure><p>同样，可能也需要sudo</p><p>至此，问题全部解决</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux QQ Bug Fix</title>
    <link href="/2019/11/09/2021/Linux-QQ-Bug-Fix/"/>
    <url>/2019/11/09/2021/Linux-QQ-Bug-Fix/</url>
    
    <content type="html"><![CDATA[<p>As Tecent Inc. has updated their <code>QQ for linux</code>. Although this project is really silly and out-of-date, we have to admit that this version of QQ is one of the stablest version in Linux.</p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>However, there are still many silly bugs need us to fix by ourselves.</p><p>For example, when you have changed your GTK panel style, QQ would become very fragile. So we have to use some special method.</p><p>First of all, we need to create a new file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit /usr/bin/qq<br></code></pre></td></tr></table></figure><p>And then, input the following code:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">export</span> GDK_NATIVE_WINDOWS=<span class="hljs-literal">true</span><br><span class="hljs-built_in">cd</span> /usr/share/tencent/qq/<br>./qq<br></code></pre></td></tr></table></figure><p>Finally, a friendly hints here — never click too fast, it will shut your QQ down.</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux Software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shut Auto-discovering devices</title>
    <link href="/2019/09/22/2021/Shut-Auto-discovering-devices/"/>
    <url>/2019/09/22/2021/Shut-Auto-discovering-devices/</url>
    
    <content type="html"><![CDATA[  <span id="more"></span><p>Well, you may say, ‘Hey, Chivier, It’s really convenient that Ubuntu can automatically add new web-devices like printers, scanners. Why are you going to shut it down?’</p><p>First I wanna say that, it’s <strong>UNSAFE</strong>. In many special places, maybe they will have some strange devices which are covered up just like printers.  For example, I wanna hack into your computer, I bought something just like a printer and use some tricks to pack it up, and your computer may recognize it as a printer. However, I will program some dirty thing into <code>auto setup</code> program. And now, get it?</p><p>Second, it will generate many useless messages into my computer. Many many use less <code>HTTP GET</code> requests and responses. It’s awful when you are catching packets in wireshark or something else.</p><p>So, let’s figure out how to shut this function down.</p><p>Fist step is to modify the configure file.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/cups/cups-browsed.conf<br></code></pre></td></tr></table></figure><p>Add <code>BrowseProtocols none</code> and <code>BrowseRemoteProtocols none</code>.</p><p>Second run following.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">service cups-browsed restart<br>service cups restart<br></code></pre></td></tr></table></figure><p>When you wanna to turn this function on, just do something reverse~</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计资源</title>
    <link href="/2019/09/10/2021/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%B5%84%E6%BA%90/"/>
    <url>/2019/09/10/2021/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言程序设计资料"><a href="#C语言程序设计资料" class="headerlink" title="C语言程序设计资料"></a>C语言程序设计资料</h1><p>程序设计相关资料</p> <span id="more"></span><p><a href="/Download/C_TA/Book1.pdf">Beginning C++17, 5th Edition</a></p><p><a href="/Download/C_TA/Book2.pdf">Beginning Programming with C For Dummies, 2nd Edition</a></p><p><a href="/Download/C_TA/Book4.pdf">C Primer Plus, 6th Edition</a></p><p><a href="/Download/C_TA/Book5.pdf">C++ Primer Plus, 6th Edition</a></p><p><a href="/Download/C_TA/Book7.pdf">C程序设计(第四版).谭浩强</a></p><p><a href="/Download/C_TA/Book8.pdf">the_c_programming_language_2</a></p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programming language</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路习题资源</title>
    <link href="/2019/06/10/2021/%E7%94%B5%E8%B7%AF%E4%B9%A0%E9%A2%98%E8%B5%84%E6%BA%90/"/>
    <url>/2019/06/10/2021/%E7%94%B5%E8%B7%AF%E4%B9%A0%E9%A2%98%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[ <span id="more"></span><p><a href="/Download/electronic_circuit/1.rar">习题集</a></p><p><a href="/Download/electronic_circuit/slides.zip">slides</a></p>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Electronic</tag>
      
      <tag>Circuits</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Shadowsocks</title>
    <link href="/2019/05/28/2021/Android-Shadowsocks/"/>
    <url>/2019/05/28/2021/Android-Shadowsocks/</url>
    
    <content type="html"><![CDATA[<p>Android Shadowsocks.</p><span id="more"></span><p><a href="/Download/shadowsocks--universal-4.7.4.zip">Shadowsocks</a></p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COD-LAB-CPU</title>
    <link href="/2019/05/28/2021/COD-LAB-CPU/"/>
    <url>/2019/05/28/2021/COD-LAB-CPU/</url>
    
    <content type="html"><![CDATA[<p> 计算机组成原理系列实验，流水线CPU。附代码。</p><span id="more"></span><div class="row">    <embed src="./Report.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COD-LAB-Multicycle</title>
    <link href="/2019/05/25/2021/COD-LAB-Multicycle/"/>
    <url>/2019/05/25/2021/COD-LAB-Multicycle/</url>
    
    <content type="html"><![CDATA[<p> 计算机组成原理系列实验，多周期CPU。附代码。</p><span id="more"></span><div class="row">    <embed src="./Report.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COD-LAB4-VGA</title>
    <link href="/2019/05/25/2021/COD-LAB4-VGA/"/>
    <url>/2019/05/25/2021/COD-LAB4-VGA/</url>
    
    <content type="html"><![CDATA[<p> 计算机组成原理系列实验，VGA画图实验。附代码。</p><span id="more"></span><div class="row">    <embed src="./Report.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COD-LAB3-Regfiles</title>
    <link href="/2019/05/25/2021/COD-LAB3-Regfiles/"/>
    <url>/2019/05/25/2021/COD-LAB3-Regfiles/</url>
    
    <content type="html"><![CDATA[<p> 计算机组成原理系列实验，FSM。附代码。</p><span id="more"></span><div class="row">    <embed src="./Report.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COD-LAB2-FSM</title>
    <link href="/2019/05/25/2021/COD-LAB2-FSM/"/>
    <url>/2019/05/25/2021/COD-LAB2-FSM/</url>
    
    <content type="html"><![CDATA[<p> 计算机组成原理系列实验，FSM。附代码。</p><span id="more"></span><div class="row">    <embed src="./Report.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COD-LAB1-ALU</title>
    <link href="/2019/05/25/2021/COD-LAB1-ALU/"/>
    <url>/2019/05/25/2021/COD-LAB1-ALU/</url>
    
    <content type="html"><![CDATA[<p> 计算机组成原理系列实验，实验一，ALU。附代码。</p><span id="more"></span><div class="row">    <embed src="./Repoet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COD Casual Disscussion 1</title>
    <link href="/2019/05/14/2021/COD-Casual-Disscussion-1/"/>
    <url>/2019/05/14/2021/COD-Casual-Disscussion-1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h1><p>选用MIPS指令集</p><p>MIPS:无互锁流水级的微处理器 (Microprocessor without Interlocked Piped Stages)</p><p>MIPS指令字格式：</p><ul><li>R-type:arithmetic instruction</li><li>I-type:data transfer, arithmetic instruction(如addi)</li><li>J-type:branch instruction(conditional &amp; unconditional)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Architechture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex in Ubuntu</title>
    <link href="/2019/05/14/2021/Latex-in-Ubuntu/"/>
    <url>/2019/05/14/2021/Latex-in-Ubuntu/</url>
    
    <content type="html"><![CDATA[<p>在Ubuntu下安装中文Latex以及安装package的教程～</p><span id="more"></span><h1 id="安装latex"><a href="#安装latex" class="headerlink" title="安装latex"></a>安装latex</h1><p>可以简单的直接再应用商店里面随便搜索一款latex的编辑器，就可以解决大部分问题。但是缺点在于不够灵活，设置僵硬。推荐还是按下面的步骤进行。</p><h1 id="安装Latex中文环境和TexStudio"><a href="#安装Latex中文环境和TexStudio" class="headerlink" title="安装Latex中文环境和TexStudio"></a>安装Latex中文环境和TexStudio</h1><p>个人推荐的tex编辑器是TexStudio，确实十分好用，按<code>F5</code>就可以直接生成pdf再旁边，随点随用，两边同步。</p><p>安装如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install texlive<br>sudo apt-get install texlive-xetex<br>sudo apt-get install texlive-lang-chinese<br>sudo apt-get install texstudio<br></code></pre></td></tr></table></figure><p>就完成了所有安装。</p><p>但是进入texstudio之后并不能直接使用，需要我们调整一些设置，再<code>Option</code>栏里的<code>Configure TexStudio...</code>里的<code>Build</code>选项，我们需要将<code>Default</code>的编译方式转为<strong>Xelatex</strong>。这样才可以完成配置。</p><h1 id="新包安装"><a href="#新包安装" class="headerlink" title="新包安装"></a>新包安装</h1><p>latex里，我们会使用各种package以满足我们的需求。Ubuntu下配置包方法如下。</p><p>配置package文件都位于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/texlive/texmf-dist/tex/latex<br></code></pre></td></tr></table></figure><p>我们进入CTAN网站下载需要的包：<a href="https://www.ctan.org/pkg/">CTAN</a></p><p>下载之后复制到之前所说的目录里，最后再运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo texhash<br></code></pre></td></tr></table></figure><p>之后就可以顺利使用了</p><h1 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h1><p>对于CS的同学，论文中插入代码必不可少，优雅的插入代码也十分关键。</p><p>一般我们先生命风格，再添加代码。</p><p>这里以插入verilog代码作为例子</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\definecolor</span>&#123;dkgreen&#125;&#123;rgb&#125;&#123;0,0.6,0&#125;<br><span class="hljs-keyword">\definecolor</span>&#123;gray&#125;&#123;rgb&#125;&#123;0.5,0.5,0.5&#125;<br><span class="hljs-keyword">\definecolor</span>&#123;mauve&#125;&#123;rgb&#125;&#123;0.58,0,0.82&#125;<br><span class="hljs-keyword">\definecolor</span>&#123;vgreen&#125;&#123;RGB&#125;&#123;104,180,104&#125;<br><span class="hljs-keyword">\definecolor</span>&#123;vblue&#125;&#123;RGB&#125;&#123;49,49,255&#125;<br><span class="hljs-keyword">\definecolor</span>&#123;vorange&#125;&#123;RGB&#125;&#123;255,143,102&#125;<br><span class="hljs-keyword">\lstdefinestyle</span>&#123;verilog-style&#125;<br>&#123;<br>language=Verilog,<br>basicstyle=<span class="hljs-keyword">\small</span><span class="hljs-keyword">\ttfamily</span>,<br>breaklines=true,<br>showstringspaces=false,<br>columns=flexible,<br>keywordstyle=<span class="hljs-keyword">\color</span>&#123;vblue&#125;,<br>identifierstyle=<span class="hljs-keyword">\color</span>&#123;black&#125;,<br>commentstyle=<span class="hljs-keyword">\color</span>&#123;vgreen&#125;,<br>numbers=left,<br>numberstyle=<span class="hljs-keyword">\tiny</span><span class="hljs-keyword">\color</span>&#123;black&#125;,<br>numbersep=7pt,<br>tabsize=4,<br>literate=*&#123;:&#125;&#123;&#123;<span class="hljs-keyword">\textcolor</span>&#123;black&#125;&#123;:&#125;&#125;&#125;1<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\lstinputlisting</span>[style=&#123;verilog-style&#125;,caption=&#123;....v&#125;]&#123;...&#125;<br></code></pre></td></tr></table></figure><p>插入MIPS汇编的方法有些特殊，CTAN没有官方的sty文件，民间有一个可以用得很顺的版本：<a href="https://xvx.ca/notes/mips-latex.html">Latex-mips</a></p><h1 id="MathType"><a href="#MathType" class="headerlink" title="MathType"></a>MathType</h1><p>输入数学公式符号表：<a href="http://web.ift.uib.no/Teori/KURS/WRK/TeX/symALL.html">Math Symbol</a></p><h1 id="模板网"><a href="#模板网" class="headerlink" title="模板网"></a>模板网</h1><p><a href="https://www.latextemplates.com/">Templates</a></p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating System Concept - 2</title>
    <link href="/2019/05/14/2021/Operating-System-Concept-2/"/>
    <url>/2019/05/14/2021/Operating-System-Concept-2/</url>
    
    <content type="html"><![CDATA[ <span id="more"></span><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h2><ul><li><strong>Responsiveness</strong>. Multithreading an interactive application may allow a program to continue running even if part of it is blocked or is performing a lengthy operation, thereby increasing responsiveness to the user. </li><li><strong>Resource sharing</strong>. Processes can only share resources through techniques such as shared memory and message passing.</li><li><strong>Economy</strong>. Allocating memory and resources for process creation is costly.</li><li><strong>Scalability</strong>. The benefits of multithreading can be even greater in a multiprocessor architecture, where threads may be running in parallel on different processing cores. A single-threaded process can run on only one processor, regardless how many are available. We explore this issue further in the following section.</li></ul><h2 id="Multithreading-Models"><a href="#Multithreading-Models" class="headerlink" title="Multithreading Models"></a>Multithreading Models</h2><h3 id="Many-to-One-Model"><a href="#Many-to-One-Model" class="headerlink" title="Many-to-One Model"></a>Many-to-One Model</h3><img src="mto.png" width="50%" height="50%"><p>The many-to-one model maps many user-level threads to one kernel thread. </p><p>Thread management is <strong>done by the thread library</strong> in <strong>user space</strong>,so it is efficient. However, the entire<br>process will block if a thread makes a blocking system call. Also, because <strong>only one thread can access the kernel at a time</strong>, multiple threads are <strong>unable to run in parallel</strong> on multi-core systems.</p><h3 id="One-to-One-Model"><a href="#One-to-One-Model" class="headerlink" title="One-to-One Model"></a>One-to-One Model</h3><img src="oto.png" width="50%" height="50%"><p>Provide <strong>more concurrency</strong> than the many-to-one model by allowing another thread to run when a thread makes a blocking system call.</p><p>Allow multiple threads to <strong>run in parallel</strong> on multiprocessors.</p><p>Drawbacks: overhead of creating kernel threads can burden the performance of an application.</p><h3 id="Many-to-Many-Model"><a href="#Many-to-Many-Model" class="headerlink" title="Many-to-Many Model"></a>Many-to-Many Model</h3><img src="mtm.png" width="50%" height="50%"><p>A balance between concurrency and developing.</p><p>Many-to-one model: easy to develop, bad concurrency.</p><p>One-to-one mode: great concurrency, hard to develop. Developers have to pay much attentions on how many system threads to create since the number of threads is strictly limited.</p><p>(In this model, the number of kernel threads is smaller than the number of user threads.)</p><h1 id="CPU-Scheduling"><a href="#CPU-Scheduling" class="headerlink" title="CPU Scheduling"></a>CPU Scheduling</h1><h2 id="Concept-of-Scheduling"><a href="#Concept-of-Scheduling" class="headerlink" title="Concept of Scheduling"></a>Concept of Scheduling</h2><p>In a single-processor system, only one process can run at a time. Others must wait until the CPU is free and can be rescheduled. $\rightarrow$ <strong>Waste of time</strong>.</p><p>With multiprogramming, we try to <strong>use this time productively</strong>. Several processes are kept in memory at one time. When one process has to wait, the operating system takes the CPU away from that process and gives the CPU to another process.</p><p>Whenever the CPU becomes idle, the operating system must <strong>select one of the processes in the ready queue to be executed</strong>. The selection process is carried out by the short-term scheduler, or CPU scheduler. The scheduler selects a process from the processes in memory that are ready to execute and allocates the CPU to that process.</p><h2 id="Preemptive-or-Non-preemptive"><a href="#Preemptive-or-Non-preemptive" class="headerlink" title="Preemptive or Non-preemptive"></a>Preemptive or Non-preemptive</h2><p>书中并没有很好的总结，中文描述更好理解：</p><ol><li>可剥夺式(可抢占式Preemptive): 当有比正在运行的进程优先级更高的进程就绪时,系统可强行剥夺正在运行进程的CPU,提供给具有更高优先级的进程使用。</li><li>不可剥夺式(不可抢占式Non-preemptive ): 某一进程被调度运行后,除非由于它自身的原因不能运行,否则一直运行下去。</li></ol><p>CPU-scheduling decisions may take place under the following four circumstances:</p><ol><li>When a process switches from the running state to the waiting state</li><li>When a process switches from the running state to the ready state</li><li>When a process switches from the waiting state to the ready state</li><li>When a process terminates</li></ol><p>When scheduling takes place <strong>only under circumstances 1 and 4</strong>, we say that the scheduling scheme is non-preemptive or cooperative. Otherwise,it is preemptive. </p><h2 id="Scheduling-Algorithms"><a href="#Scheduling-Algorithms" class="headerlink" title="Scheduling Algorithms"></a>Scheduling Algorithms</h2>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 开机加速</title>
    <link href="/2019/05/14/2021/Ubuntu-%E5%BC%80%E6%9C%BA%E5%8A%A0%E9%80%9F/"/>
    <url>/2019/05/14/2021/Ubuntu-%E5%BC%80%E6%9C%BA%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<p> 啊啊啊，真的等不及了……开机慢死了怎么破～</p><span id="more"></span><h1 id="开机时间分析"><a href="#开机时间分析" class="headerlink" title="开机时间分析"></a>开机时间分析</h1><p>我们需要加速开机流程，受限最重要的是知道那些地方影响了开机速度。我们利用<code>systemd-analyse blame</code>命令来观察具体那些流程较慢：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemd-analyse blame<br></code></pre></td></tr></table></figure><img src="p1.png" width="80%" height="80%"><img src="p2.png" width="80%" height="80%"><p>看出来了吧，第一项巨慢无比，不能忍，掐掉。</p><h1 id="掐掉？"><a href="#掐掉？" class="headerlink" title="掐掉？"></a>掐掉？</h1><p>掐掉之前，稳妥一点的做法是搜索一下，这一开机启动service的作用，确认没有恶劣影响之后我们可以关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl mask xx.service<br></code></pre></td></tr></table></figure><img src="p3.png" width="80%" height="80%"><p>至此，开机加速任务完成。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Logic-谓词演算-2</title>
    <link href="/2019/04/23/2021/Logic-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97-2/"/>
    <url>/2019/04/23/2021/Logic-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97-2/</url>
    
    <content type="html"><![CDATA[ <span id="more"></span><h1 id="谓词演算语义"><a href="#谓词演算语义" class="headerlink" title="谓词演算语义"></a>谓词演算语义</h1><h2 id="解释域和项解释"><a href="#解释域和项解释" class="headerlink" title="解释域和项解释"></a>解释域和项解释</h2><p><strong>解释域</strong>:非空集合M具有</p><ol><li>K中每个个体常元$c_i$，M中都有对应的$\overline{c_i}$</li><li>K中每个运算符$f_i^n$，M中都有对应的n元运算符$\overline{f_i^n}​$</li><li>K中每个谓词$R_i^n$，M中都有对应n元关系的$\overline{R_i^n}​$</li></ol><p>具有这三类映射的集合才被成为K的解释域</p><p>例子：</p><p>参考汪芳庭的《数理逻辑》中Page82的例子。同时证明了，只有解释域中才可以说明K中公式的真假。</p><p>我们之前定义过K中的项集构造：</p><ul><li>变元和常元是项</li><li>若$t_1,…,t_n$是项，则$f_i^n(t_1,…,t_n)$也是项</li></ul><p>我们类似定义出我们的<strong>项解释</strong>$\varphi:T\rightarrow M$：</p><ul><li><p>$\varphi(x_i)=\varphi_0(x_i),,\varphi(c_i)=\overline{c_i}$</p></li><li><p>若$\varphi(t_1),…,\varphi(t_n)$已经定义好，那么</p><p>$\varphi(f_i^n(t_1,…,t_n))=\overline{f_i^n}(\varphi(t_1),…,\varphi(t_n))$（保运算性）</p></li></ul><p>总结为：</p><p>解释域完成了常元、运算符、谓词的映射</p><p>项解释完成了变元的映射</p><p>这样M中所有元素都有了相对应的映射。</p><p>解释域M下我们的所有发项解释集合记作$\Phi_M$</p><p><strong>项解释的变元变通</strong>：x是某个给定的个体变元，y是任意的个体变元，$\varphi,,\varphi’ \in \Phi_M$</p><p>使得：$y\neq x ,\Rightarrow , \varphi(y)=\varphi’(y)$，则$\varphi’$叫$\varphi$的变通。</p><font color=0x0099ff><p>通俗来说，变通，顾名思义，就是说明再特定变量x上采取变通的方式，只有变量x的解释产生变化，其余变量保持不变。</p></font><h2 id="公式的赋值函数"><a href="#公式的赋值函数" class="headerlink" title="公式的赋值函数"></a>公式的赋值函数</h2><h3 id="公式的赋值函数-1"><a href="#公式的赋值函数-1" class="headerlink" title="公式的赋值函数"></a>公式的赋值函数</h3><p>解释域M给定，p是K中任一公式</p><p>按下面的方式定义的$|p|:\Phi_M \rightarrow Z_2​$叫公式的赋值函数：</p><p>对于任意项解释$\varphi$，</p><ul><li><p>p为原子公式$R_i^n(t_1,…,t_n)​$时，令<br>$$<br>|p|(\varphi)=\begin{cases}<br>1,\quad if,(\overline{t_1},\overline{t_2},…,\overline{t_n})\in \overline{R^n_i} \\<br>0,\quad if,(\overline{t_1},\overline{t_2},…,\overline{t_n})\notin \overline{R^n_i}<br>\end{cases}<br>$$<br>规定原子公式的赋值</p></li><li><p>$p=\neg q​$ 或 $p=q\rightarrow r​$<br>$$<br>|\neg q| (\varphi) = \neg |q| (\varphi) \\<br>|q \rightarrow r| (\varphi) = |q| (\varphi) \rightarrow |r| (\varphi)<br>$$<br>规定对于$\neg$和$\rightarrow$的保运算性</p></li><li><p>$p=\forall q​$<br>$$<br>|\forall x q|(\varphi)=\begin{cases}<br>1,\quad if,\varphi任意一个x变通\varphi’都有|q|(\varphi’)=1\\<br>0,\quad otherwise<br>\end{cases}<br>$$</p><p>规定全称</p></li></ul><h2 id="闭式语义特征"><a href="#闭式语义特征" class="headerlink" title="闭式语义特征"></a>闭式语义特征</h2><h3 id="语义等性"><a href="#语义等性" class="headerlink" title="语义等性"></a>语义等性</h3><p>M是K的解释域$\varphi,\psi \in \Phi_M$</p><ul><li>如果项t中任一变元x都有$\varphi(x) = \psi(x)​$，则$\varphi(t) = \psi(t)​$</li><li>如果p中任意一个自由变元x都有$\varphi(x) = \psi(x)$，则$|p|(\varphi) = |p|(\psi)$</li></ul><h3 id="恒真恒假推论法"><a href="#恒真恒假推论法" class="headerlink" title="恒真恒假推论法"></a>恒真恒假推论法</h3><p>如果M解释域下任一一种指派都使得p的语义为1则p恒真，类似的我们也可以知道恒假</p><p>$p$中所有的变元为$x_1,x_2,…,x_n$，则$\forall x_1 \forall x_2 … \forall x_n p$记作$p’$，成为<strong>全称闭式</strong></p><p>对于这一类有如下两条重要关系：</p><ul><li><p>$$<br>|p|_M = 1 \Leftrightarrow |p’|_M = 1<br>$$</p></li><li><p>$$<br>|p|_M = 0 \Leftrightarrow |p’|_M = 0<br>$$</p></li></ul><h2 id="语义推论和有效式"><a href="#语义推论和有效式" class="headerlink" title="语义推论和有效式"></a>语义推论和有效式</h2><p>模型： M为K的解释域，M是公式集$\Gamma$的模型是指$\Gamma$中每一个公式M中都恒真，即<br>$$<br>r \in \Gamma \Rightarrow |r|_M = 1<br>$$<br>语义推论：类似与语法推论，$\Gamma \models p$解释为，当所有$\Gamma$中元素都解释为真的时候，p解释也为恒真</p><p>结论关系：<br>$$<br>\Gamma \models p \Leftrightarrow \Gamma \models p’<br>$$</p><h1 id="语义语法关联"><a href="#语义语法关联" class="headerlink" title="语义语法关联"></a>语义语法关联</h1><h2 id="K可靠性"><a href="#K可靠性" class="headerlink" title="K可靠性"></a>K可靠性</h2><p>$$<br>\vdash p \Rightarrow \models p<br>$$</p><h2 id="K完全性"><a href="#K完全性" class="headerlink" title="K完全性"></a>K完全性</h2><p>$$<br>\models p \Rightarrow \vdash p<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths</tag>
      
      <tag>Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instructions</title>
    <link href="/2019/04/23/2021/Instructions/"/>
    <url>/2019/04/23/2021/Instructions/</url>
    
    <content type="html"><![CDATA[<p>参考使用，Hexo使用指令</p><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>信息栏加入：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">toc: true<br></code></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">0x0099ff</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>更多字体设置：<a href="https://blog.csdn.net/testcs_dn/article/details/45719357/">Font Help</a></p><p>更多颜色信息：<a href="https://blog.csdn.net/u010177286/article/details/50358720">Font Color</a></p><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">File name</span>](<span class="hljs-link">\Download\...</span>)<br></code></pre></td></tr></table></figure><h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;process.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;80%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;80%&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="pdf-插入"><a href="#pdf-插入" class="headerlink" title="pdf 插入"></a>pdf 插入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% pdf ./Repoet.pdf %&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust-Shell-Project</title>
    <link href="/2019/04/22/2021/Rust-Shell-Project/"/>
    <url>/2019/04/22/2021/Rust-Shell-Project/</url>
    
    <content type="html"><![CDATA[<p> Rust项目——Rust编写Shell。一个用Rust写的Shell。</p><span id="more"></span><h1 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h1><p>项目位置：</p><p><a href="https://github.com/Chivier/Rustshell">Rust shell</a></p><h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>功能介绍：</p><p>这里只是使用Rust写了一个简单的Shell，功能十分简陋，主要功能</p><ul><li>简单的bash shell命令</li><li>简单的健壮性处理，无视多余的空格、回车、tab等字符</li><li>支持环境变量导出和修改</li><li>支持管道</li><li>支持基本文件重定向</li><li>支持alias和unalias</li><li>增加showalias命令输出所有的alias</li></ul><h1 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h1><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>本Shell主要参考：</p><ul><li><p><a href="https://www.joshmcguigan.com/blog/build-your-own-shell-rust/">Build a Sell in Rust</a></p></li><li><p><a href="https://github.com/google/rust-shell">Rust shell google</a></p></li></ul><p>基本框架由该博客提供：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>        stdout().flush();<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> input = <span class="hljs-built_in">String</span>::new();<br>        stdin().read_line(&amp;<span class="hljs-keyword">mut</span> input).unwrap();<br><br>        <span class="hljs-comment">// must be peekable so we know when we are on the last command</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> commands = input.trim().split(<span class="hljs-string">&quot; | &quot;</span>).peekable();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> previous_command = <span class="hljs-literal">None</span>;<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(command) = commands.next()  &#123;<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> parts = command.trim().split_whitespace();<br>            <span class="hljs-keyword">let</span> command = parts.next().unwrap();<br>            <span class="hljs-keyword">let</span> args = parts;<br><br>            <span class="hljs-keyword">match</span> command &#123;<br>                <span class="hljs-string">&quot;exit&quot;</span> =&gt; <span class="hljs-keyword">return</span>,<br>                command =&gt; &#123;<br>                    <span class="hljs-keyword">let</span> stdin = previous_command<br>                        .map_or(<br>                            Stdio::inherit(),<br>                            |output: Child| Stdio::from(output.stdout.unwrap())<br>                        );<br><br>                    <span class="hljs-keyword">let</span> stdout = <span class="hljs-keyword">if</span> commands.peek().is_some() &#123;<br>                        <span class="hljs-comment">// there is another command piped behind this one</span><br>                        <span class="hljs-comment">// prepare to send output to the next command</span><br>                        Stdio::piped()<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// there are no more commands piped behind this one</span><br>                        <span class="hljs-comment">// send output to shell stdout</span><br>                        Stdio::inherit()<br>                    &#125;;<br><br>                    <span class="hljs-keyword">let</span> output = Command::new(command)<br>                        .args(args)<br>                        .stdin(stdin)<br>                        .stdout(stdout)<br>                        .spawn();<br><br>                    <span class="hljs-keyword">match</span> output &#123;<br>                        <span class="hljs-literal">Ok</span>(output) =&gt; &#123; previous_command = <span class="hljs-literal">Some</span>(output); &#125;,<br>                        <span class="hljs-literal">Err</span>(e) =&gt; &#123;<br>                            previous_command = <span class="hljs-literal">None</span>;<br>                            eprintln!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>                        &#125;,<br>                    &#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">mut</span> final_command) = previous_command &#123;<br>            <span class="hljs-comment">// block until the final command has finished</span><br>            final_command.wait();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这作为基本框架。</p><h2 id="框架缺陷"><a href="#框架缺陷" class="headerlink" title="框架缺陷"></a>框架缺陷</h2><p>第一，该框架支持命令过少，很多问题无法解决</p><p>第二，cd指令不能正常使用</p><p>第三，export指令无效</p><p>第四，无法使用alias</p><p>等等……</p><h2 id="环境变量处理"><a href="#环境变量处理" class="headerlink" title="环境变量处理"></a>环境变量处理</h2><p>环境变量我采取了自己构建的方法，虽然export指令失效，但是我们的env指令可以正常执行。</p><p>构建HashMap解决</p><h2 id="alias解决"><a href="#alias解决" class="headerlink" title="alias解决"></a>alias解决</h2><p>方法同上</p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>利用Command库特殊指令修改目录位置，这条指令必须做在shell指令之外单独处理</p><h2 id="cicada扩展"><a href="#cicada扩展" class="headerlink" title="cicada扩展"></a>cicada扩展</h2><p>实际上Rust有一个名为cicada的crate，可以执行学大多数的shell指令，但是该crate有许多未知bug，而且输入输出方法过于简化，倒置无法执行带有’\n’的指令，还是需要由自己重新构建</p>]]></content>
    
    
    <categories>
      
      <category>Develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Rust</tag>
      
      <tag>Programming language</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Logic-形式算数-1</title>
    <link href="/2019/04/16/2021/Logic-%E5%BD%A2%E5%BC%8F%E7%AE%97%E6%9C%AF1/"/>
    <url>/2019/04/16/2021/Logic-%E5%BD%A2%E5%BC%8F%E7%AE%97%E6%9C%AF1/</url>
    
    <content type="html"><![CDATA[  <span id="more"></span><h1 id="带等词的谓词演算"><a href="#带等词的谓词演算" class="headerlink" title="带等词的谓词演算"></a>带等词的谓词演算</h1><h2 id="等词公理"><a href="#等词公理" class="headerlink" title="等词公理"></a>等词公理</h2><ul><li><p>$$<br>(E1) \quad t \approx t<br>$$</p></li><li><p>$$<br>(E2) \quad t_k \approx u \rightarrow f_i^n (t_1,…,t_k,…,t_n) \approx f_i^n (t_1,…,u,…,t_n)<br>$$</p></li><li><p>$$<br>(E3) \quad t_k \approx u \rightarrow R_i^n (t_1,…,t_k,…,t_n) \rightarrow R_i^n (t_1,…,u,…,t_n)<br>$$</p></li></ul><p>如果M是E的模型，则等词$\approx$可以解释为等价关系</p>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths</tag>
      
      <tag>Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Logic-谓词演算-1</title>
    <link href="/2019/04/16/2021/Logic-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97/"/>
    <url>/2019/04/16/2021/Logic-%E8%B0%93%E8%AF%8D%E6%BC%94%E7%AE%97/</url>
    
    <content type="html"><![CDATA[  <span id="more"></span><h1 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h1><h2 id="基本集合"><a href="#基本集合" class="headerlink" title="基本集合"></a>基本集合</h2><p>谓词演算与命题演算不同之处在于公式定义上的区别，产生了新的命题元素：$\forall$</p><p>四个基本集合：</p><p>个体变元集$X$，个体常元集$C$，运算函数集$F$，谓词集$R$</p><p>我们定义项集T为层次集合，$T_i​$为i次运算函数产生的项</p><p><strong>原子公式集</strong>:<br>$$<br>Y = \bigcup_\text{i,n} ((R_i^n) \times T \times … \times T)<br>$$<br>定义为原子公式集。原子公式就是指代形如$R_i^n(t_1,…,t_2)$。</p><h2 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h2><p>公式定义：</p><ul><li>原子公式是公式</li><li>若$p,q​$是公式，则$\neg p​$，$p \rightarrow q​$，$\forall x_i p​$都是公式</li><li>前两条若干次变换</li></ul><h2 id="其他运算定义"><a href="#其他运算定义" class="headerlink" title="其他运算定义"></a>其他运算定义</h2><p>$$<br>p \vee q = \neg p \rightarrow q \\<br>p \wedge q = \neg (p \rightarrow \neg q) \\<br>p \leftrightarrow q = (p \rightarrow q) \wedge (q \rightarrow p) \\<br>\exists x_i p = \neg \forall x_i p<br>$$</p><p>定义了$\vee\ \quad \wedge \quad \leftrightarrow \quad \exists​$四种运算符</p><h2 id="约束出现和自由出现"><a href="#约束出现和自由出现" class="headerlink" title="约束出现和自由出现"></a>约束出现和自由出现</h2><p>变元的<strong>自由出现</strong>指变元$x$不在$\forall x​$的范围内出现，反之叫约束出现</p><p>如果公式中没有自由出现的变元，则叫<strong>闭式</strong></p><p><strong>项t对p中x自由</strong>，完整的说法是“项t对于公式p中的x变元自由”，即用t取替换p中自由出现的x之后，所有的t变元还是自由的。等价于满足下面3条中任意一条：</p><ul><li>t是闭项（只有常元没有变元）</li><li>x再p中不自由出现</li><li>x对p中x自由</li></ul><p>符号p(x)表示公式，p(t)默认表示用t取代换所有的x</p><h1 id="谓词演算K"><a href="#谓词演算K" class="headerlink" title="谓词演算K"></a>谓词演算K</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>指有一下规定的功利和证明的公式集：</p><ul><li><p>公理</p><p>(K1) $p \rightarrow (q \rightarrow p)​$</p><p>(K2) $(p \rightarrow (q \rightarrow r)) \rightarrow ((p \rightarrow q) \rightarrow (p \rightarrow r))$</p><p>(K3) $(\neg p  \rightarrow \neg q) \rightarrow (q \rightarrow p)$</p><p>(K4) $\forall x ,p(x)  \rightarrow p(t) \quad$其中t对p(x)中x自由</p><p>(K5) $\forall x,(p \rightarrow q) \rightarrow (p \rightarrow \forall x ,q)\quad$其中x不在p中自由出现</p></li><li><p>证明</p><p>p是公式，$\Gamma$是公式集。p从$\Gamma$可证，记作$\Gamma \vdash p$</p><p>指：</p><p>从有限公式序列$p_1,…,p_n$有$p_n=p$并且每个k=1…n都有</p><ul><li>$p_k \in \Gamma$</li><li>$p_k$是公理</li><li>$\exists i,j&lt;k$使得$p_j = p_i \rightarrow p_k$ <em>（等价于：要有$p_k$，必须现有$p_i$和$p_i \rightarrow p_k$）</em></li><li>$\exists j&lt;k$使得$p_k = \forall x , p_j $</li></ul></li></ul><h2 id="永真式和定理"><a href="#永真式和定理" class="headerlink" title="永真式和定理"></a>永真式和定理</h2><p>如果K中命题再L中有对应的命题演算定理，且永真，则叫永真式</p><p>简而言之：L中也有的叫永真，永真式一定是定理，反之未必</p><h2 id="exists-1-规则"><a href="#exists-1-规则" class="headerlink" title="$\exists_1$规则"></a>$\exists_1$规则</h2><p>如果项t对于p中x自由，则：<br>$$<br>\vdash p (t) \rightarrow \exists x,p(x)<br>$$</p><h2 id="exists-2-规则"><a href="#exists-2-规则" class="headerlink" title="$\exists_2$规则"></a>$\exists_2$规则</h2><p>设$\Gamma \cup {p}\vdash q​$其证明中Gen变元不在p中自由出现，x不在q中自由出现，则有$\Gamma \cup {\exists x , p}\vdash q​$，且出来x不增加其他Gen变元</p><p>注意：<strong>演绎定理、归谬律、反证律</strong>都可以使用，但是<strong>略有不同</strong></p><h2 id="演绎定理"><a href="#演绎定理" class="headerlink" title="演绎定理"></a>演绎定理</h2><ul><li>若$\Gamma \vdash p \rightarrow q​$则$\Gamma \cup {p} \vdash q​$</li><li>若$\Gamma \cup {p} \vdash q$且证明中所用Gen变元不在p中自由出现，则不增加Gen变元就能使$\Gamma \vdash p \rightarrow q$</li></ul><p>推论：</p><ul><li>p是闭式时$\Gamma \vdash p \rightarrow q \Leftrightarrow \Gamma \cup {p} \vdash q$</li></ul><h2 id="反证律"><a href="#反证律" class="headerlink" title="反证律"></a>反证律</h2><p>若$\Gamma \cup {\neg p} \vdash q​$ 且$\Gamma \cup {\neg p} \vdash \neg q​$切所用Gen变元不在p中自由出现，则不增加新的Gen变元就能使得$\Gamma \vdash p​$</p><h2 id="归谬律"><a href="#归谬律" class="headerlink" title="归谬律"></a>归谬律</h2><p>若$\Gamma \cup {p} \vdash q​$ 且$\Gamma \cup {p} \vdash \neg q​$切所用Gen变元不在p中自由出现，则不增加新的Gen变元就能使得$\Gamma \vdash \neg p​$</p><p>注意演绎定理、归谬律、反证律说起来都是多了<strong>不增加新的Gen变元就能使得</strong></p><h2 id="子公式等价替换"><a href="#子公式等价替换" class="headerlink" title="子公式等价替换"></a>子公式等价替换</h2><p>如果公式q是p的子公式：$p=…q…$</p><p>公式$q’$替代$q$得到：$p’ = … q’ …$</p><p>则 $\Gamma \vdash q \leftrightarrow q’ \Rightarrow \Gamma \vdash p \leftrightarrow p’$</p><h2 id="对偶律"><a href="#对偶律" class="headerlink" title="对偶律"></a>对偶律</h2><p>将公式p表示为只含有原子公式以及$\neg,\vee,\wedge,\forall,\exists​$的形式之后：</p><ul><li>所有原子公式改为他们的否定</li><li>$\wedge​$和$\vee​$互换</li><li>$\forall​$和$\exists​$互换</li></ul><p>新公式记为$p^<em>​$则<br>$$<br>\vdash p^</em> \leftrightarrow \neg p<br>$$</p><h2 id="前束范式"><a href="#前束范式" class="headerlink" title="前束范式"></a>前束范式</h2><p>形如$Q_1x…Q_ny p​$的式子叫前束范式，其中$Q_i​$表示量词符号$\forall​$或者$\exists​$，一般的，我们将$Q​$的对偶符号记作$Q^*​$</p><p>结论：</p><ol><li>若y不在$p(x)​$中自由出现，则</li></ol><p>$$<br>\vdash Qxp(x) \leftrightarrow Qyp(y)<br>$$</p><ol start="2"><li>若x不在p中自由出现，则</li></ol><p>$$<br>\vdash (p\rightarrow Qxq) \leftrightarrow Qx(p\rightarrow q)<br>$$<br>​    若x不在q中自由出现，则<br>$$<br>\vdash(Qxp \rightarrow q) \leftrightarrow Q^*x(p \rightarrow q)<br>$$</p><ol start="3"><li>$$<br> \vdash \neg Q x p \leftrightarrow Q^* x \neg p<br> $$</li></ol><font color=0x0099ff><p>用上述三条结论完成前束范式的变形，步骤：</p><ul><li><p>利用好结论1和子公式替换，替换p中变元</p></li><li><p>利用结论2和3将量词移动 </p><ul><li>结论2用于移动量词在$\rightarrow$两侧的情况</li><li>结论3用于移动再$\neg$之后的情况</li></ul></li></ul></font><p>补充两个定义：</p><ul><li><strong>$\Pi_n$型前束范式</strong>：从$\forall​$开始，从左往右改变n-1次词性</li><li><strong>$\Sigma_n$型前束范式</strong>：从$\exists$开始，从左往右改变n-1次词性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maths</tag>
      
      <tag>Logic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating System Concept - 1</title>
    <link href="/2019/04/10/2021/Operating-System-Concept-1/"/>
    <url>/2019/04/10/2021/Operating-System-Concept-1/</url>
    
    <content type="html"><![CDATA[ <span id="more"></span><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><blockquote><p>A piece of software that manages a computer, making computer’s hardware<br>resources accessible to software through a consistent set of interfaces.</p></blockquote><p>并发(Concurrence)</p><p>共享(Sharing) </p><p>虚拟(Virtual) </p><p>异步(Asynchronism)</p><p>四项重要特征为OS的核心特征，也是我们进一步做得更好的核心挑战所在。</p><h2 id="OS-Functions"><a href="#OS-Functions" class="headerlink" title="OS Functions"></a>OS Functions</h2><ol><li>CPU管理<ol><li>进程/线程控制和管理</li><li>进程同步和互斥（mutual exclusion）</li><li>进程通信和死锁（dead lock）</li><li>处理器调度，作业调度和进程调度</li></ol></li><li>存储管理<ol><li>存储分配</li><li>存储共享</li><li>存储保护</li><li>地址转换</li><li>存储扩充</li></ol></li><li>⽂件管理<ol><li>⽬录管理</li><li>存取控制/保护</li><li>逻辑组织</li><li>物理组织</li><li>⽂件存储空间管理</li></ol></li><li>设备管理<ol><li>设备分配</li><li>设备驱动</li><li>缓冲管理</li></ol></li><li>⽤户接口<ol><li>命令接口</li><li>程序接口</li><li>图形接口</li></ol></li><li>⽹络与通信管理</li></ol><h1 id="OS-Structure"><a href="#OS-Structure" class="headerlink" title="OS Structure"></a>OS Structure</h1><blockquote><p>System calls provide an interface to the services made available by an operating system.</p></blockquote><p>Categories of System call:</p><p>• Process control<br>• File management<br>• Device management<br>• Information maintenance<br>• Communications</p><h2 id="Simple-Structure"><a href="#Simple-Structure" class="headerlink" title="Simple Structure"></a>Simple Structure</h2><h3 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h3><p>MS-DOS – written to provide the most functionality in the least space</p><ul><li>Not divided into modules</li><li>Interfaces and levels of functionality not well separated</li></ul><img src="DOS.png" width="80%" height="80%"><h3 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h3><p>Limited by hardware functionality</p><p>Original UNIX operating system consists of two separable parts:</p><ul><li>Systems programs</li><li>The kernel<ul><li>Consists of everything below the system-call interface and above the physical hardware</li><li>Provides the file system, CPU scheduling, memory management, and other operating-system functions;</li><li>Many interacting functions for one level</li></ul></li></ul><img src="Unix.png" width="80%" height="80%"><h2 id="Layered-Structure"><a href="#Layered-Structure" class="headerlink" title="Layered Structure"></a>Layered Structure</h2><p> Operating system is divided many layers (levels)</p><ul><li>Each built on top of lower layers</li><li>Bottom layer (layer 0) is hardware</li><li>Highest layer (layer N) is the user interface</li></ul><p>模块化，易于调试</p><h2 id="Microkernel-System-Structure"><a href="#Microkernel-System-Structure" class="headerlink" title="Microkernel System Structure"></a>Microkernel System Structure</h2><blockquote><p> Moves as much from the kernel into “user” space as possible.</p></blockquote><p>非基本的方法从内核中抽离，留下基本的方法。<em>（基本：一般认为内存管理和通信功能是必须的基本方法）</em></p><p>Benefits:<br>• Easier to extend a microkernel<br>• Easier to port the operating system to new architectures<br>• More reliable (less code is running in kernel mode)<br>• More secure<br>Detriments:<br>• Performance overhead of user space to kernel space communication</p><h2 id="Module-based"><a href="#Module-based" class="headerlink" title="Module based"></a>Module based</h2><p>Most modern operating systems implement kernel<br>modules<br>• Uses object-oriented approach<br>• Each core component is separate<br>• Each talks to the others over known interfaces<br>• Each is loadable as needed within the kernel</p><p>类似于layered structure，但是灵活性大大增长</p><p>Example:</p><img src="Queueing-diagram.png" width="80%" height="80%"><ol><li>Scheduling classes</li><li>File systems</li><li>Loadable system calls</li><li>Executable formats</li><li>STREAMS modules</li><li>Miscellaneous</li><li>Device and bus drivers</li></ol><h2 id="Hybrid-Systems"><a href="#Hybrid-Systems" class="headerlink" title="Hybrid Systems"></a>Hybrid Systems</h2><p>更为现代的设计方式都是采用混合模型</p><h1 id="Virtual-Machines"><a href="#Virtual-Machines" class="headerlink" title="Virtual Machines"></a>Virtual Machines</h1><p>分层方法逻辑可延伸为虚拟机概念。虚拟机的基本思想是<u>单个计算机(CPU 、内存、磁盘、网卡等)的硬件<strong>抽象</strong>为几个不同的执行部件</u>，从而造成一种”幻觉”，仿佛每个独立的执行环境都在自己的计算机上运行一样。</p><p>创建虚拟机有几个原因，最根本的是，在并行运行几个不同的执行环境(即不同的操作系统)时能够共享相同的硬件。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>底层机器有两种模式:用户模式和内核模式。虚拟机软件可以运行在内核模式，因为它就是操作系统。虚拟机<u>本身只能运行在用户模式</u>。正如物理机器有两种模式一样，虚拟机也有两种模式。因此，<strong>必须有虚拟用户模式和虚拟内核模式</strong>，这<strong>两种模式都运行在物理用户模式</strong>。</p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><p>• Isolation from all other virtual machines. 保证安全<br>• No disruption on normal system operation. 开发测试操作系统不需要中断正常操作系统的服务<br>• Difficult to implement due to the effort required to provide an exact duplicate to the underlying machine</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="Vmware"><a href="#Vmware" class="headerlink" title="Vmware"></a>Vmware</h3><p>虚拟层是VMware 的核心，因为它将物理硬件抽象为独立的作为客户操作系统的虚拟机运行。每个虚拟机都有它自己的虚拟 CPU、内存、磁盘驱动、网络接口等。</p><h3 id="Java-虚拟机-JVM"><a href="#Java-虚拟机-JVM" class="headerlink" title="Java 虚拟机 (JVM)"></a>Java 虚拟机 (JVM)</h3><p>Java 对象用类结构来描述; Java 程序由一个或多个类组成。对于每个 Java 类， Java编译器会生成<strong>与平台无关的字节码 (bytecode) 输出文件( .class )</strong> ，它可运行在任何JVM 上。</p><p>JVM包括类加载器和执行与平台无关的字节码的Java解释器。JVM 通过执行垃圾收集(garbage collection ，回收不再使用的内存并返回给系统)来自动管理内存。</p><h3 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h3><p>.NET框架是一套包含了类库集舍、执行环境和软件开发平台的技术。这个平台允许基于.NET框架编程而不是针对任何特定平台。</p><p>.NET 框架的核心是公共语言运行时间 (CLR)</p><p> CLR 是 .NET 虚拟机的实现</p><p>用 C#或者 VB.NET 编写的程序被编译为一种平台无关的中间语言(叫做微软中间语言 MS-IU 。这些被编译好的文件叫做组合 (assembly) ,它包含了 MS-IL 指令和元数据。它们的文件名后缀是.dll 或者.exeo 当要运行这些程序的时候， CLR 把这些组合加载进应用程序域 (Application Domain) 。</p><h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p>进程不只是程序代码，程序代码有时称为<strong>文本段(或代码段)**。进程还包括</strong>当前活动<strong>，通过程序计数器的值和处理器寄存器的内容来表示。另外，进程通常还包括进程</strong>堆栈段**(包括临时数据，如函数参数、返回地址和局部变量)和<strong>数据段</strong>(包括全局变量)。进程还可能包括堆 (heap) ，是在进程运行期间动态分配的内存。</p><p>英文解释更为简单：</p><p><strong>A process is a program in execution</strong></p><p>进程在执行时产生许多进程是很常见的。</p><blockquote><p>程序与进程之间的区别:</p><ul><li>“进程”是一个动态的概念:进程强调的是程序的一次“执行”过程,程序是一组有序指令的集合,在多道程序设计环境下,它不涉及“执行”,因此,是一个静态的概念;</li><li>不同的进程可以执行同一个程序:即使多个进程执行同一个程序,只要它们运行在不同的数据集合上,它们就是不同的进程;</li><li>每一个进程都有自己的生命期:当系统要完成某一项工作时,它就“创建”一个进程,程序执行完毕,系统就“撤销”这个进程,收回它所占用的资源。</li></ul></blockquote><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程在执行时会改变状态。进程状态在某种程度上是由当前活动所定义的。每个进程可能处于下列状态之一:</p><ul><li>新的:进程正在被创建。</li><li>运行:指令正在被执行。</li><li>等待:进程等待某个事件的发生(如 IO 完成或收到信号)。</li><li>就绪:进程等待分配处理器。</li><li>终止:进程完成执行。</li></ul><img src="process.png" width="80%" height="80%"><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>每个进程在操作系统内用<strong>进程控制块</strong> (process control block. PCB. 也称为任务控制块)来表示。</p><img src="PCB.png" width="30%" height="30%"><ul><li>**进程状态:**状态可包括新的、就绪、运行、等待、停止等。</li><li>**程序计数器:**计数器表示进程要执行的下个指令的地址。</li><li>**CPU 寄存器:**根据计算机体系结构的不同，寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆战指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。</li><li>**CPU 调度信息:**这类信息包括进程优先级、调度队列的指针和其他调度参数</li><li>**内存管理信息:**根据操作系统所使用的内存系统，这类信息包括基址和界限寄存器的值、页表或段表(见第 8 章)。</li><li>**记账信息:**这类信息包括 CPU 时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</li><li>**I/O 状态信息:**这类信息包括分配给进程的 νo 设备列表、打开的文件列表等。<br>简而言之， PCB 简单地作为这些信息的仓库，这些信息在进程与进程之间是不同的。</li></ul><img src="PCB_Switch.png" width="80%" height="80%"><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程是一个只能进行单个执行线程的程序。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h3><p>进程进入系统时，会被加到作业队列中，该队列包括系统中的所有进程。</p><p>讨论进程调度的常用表示方法是<strong>队列图</strong></p><p>每个长方形表示一个队列。有两种队列:就绪队列和一组设备队列。圆形表示为队列服务的资源，箭头表示系统内进程的流向。</p><img src="Queueing-diagram.png" width="80%" height="80%"><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>当进程创建新进程时，有两种执行可能:</p><ul><li>父进程与子进程并发执行。</li><li>父进程等待，直到某个或全部子进程执行完。</li></ul><p>新进程的地址空间也有两种可能:</p><ul><li>子进程是父进程的复制品(具有与父进程相同的程序和数据)。</li><li>子进程装入另一个新程序。</li></ul><p>Unix通过pid变量标记进程，fork（）函数创建进程。</p><p><strong>fork的时候发生什么？</strong><br>=》执行到这一句的时候，一个进程被创建了，这个进程与父进程一样，拥有一套与父进程相同的变量，相同的一套代码，这里可以粗浅的理解为子进程又复制了一份main函数。这里返回一个子进程的进程号，大于0。（第一次fork）</p><p>通常，在系统调用<code>fork()</code>之后，一个进程会使用系统调用<code>exec()</code>，以用新程序来取代进<br>程的内存雪间。系统调用<code>exec()</code>将二进制文件装入内存(消除了原来包含系统调用<code>exec()</code>的<br>程序的内存映射)，并开始执行。采用这种方式，两个进程能相互通信，并能按各自的方法<br>执行。父进程能创建更多的子进程，或者如果在子进程运行时没有什么可做，那么它采用<br>系统调用<code>wait()</code>把自己移出就绪队列来等待子进程的终止。</p><p><strong>子进程怎么执行：</strong></p><p>=》<strong>子进程从fork()的位置开始执行</strong>，也就是说前面的代码不走，但是拥有之前的变量以及变量的值，与父进程的值一样，这次fork()，返回值是0，所以在子进程里面直接执行了pid==0这一个分支，父进程里面并不执行这个分支的语句。这就为我们在写mian函数的时候怎么写子进程的程序提供了一个方法来隔离代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    pid[<span class="hljs-number">0</span>] = fork();<br>    pid[<span class="hljs-number">1</span>] = fork();<br>    pid[<span class="hljs-number">2</span>] = fork();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is process\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行会输出8次<code>this is a process</code></p><h2 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h2><p>当进程完成执行最后的语句并使用系统调用<code>exit()</code>请求操作系统删除自身时，进程终止。这时，进程可以返回状态值(通常为整数)到父进程(通过系统调用<code>wait()</code>) 。所有进程资源(包括物理和虚拟内存、打开文件和 I/O 缓冲)会被操作系统释放。</p><p>有些系统，包括 VMS ，不允许子进程在父进程己终止的情况下存在。对于这类系统，如果一个进程终止(正常或不正常)，那么它的所有子进程也将终止。这种现象，称为<strong>级联终止</strong>( cascading termination) ，通常由操作系统进行。</p><h2 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h2><p>进程调度算法的原则:</p><ul><li>(1)公平性。</li><li>(2)资源利用率(特别是CPU利用率)。</li><li>(3)响应时间 - 交互式系统情况。</li><li>(4)系统吞吐量 - 批处理系统。</li><li>(5)周转时间 – 从进程提交到进程完成的时间间隔。</li><li>(6)等待时间 – 在就绪队列中等待所花费的时间之和</li></ul><p>通常对于批处理系统，进程更多地是被提交，而不是马上执行。这些进程被放到大容量存储设备(通常为磁盘)的缓冲地中，保存在那里以便以后执行。<strong>长期调度程序(long-term scheduler)</strong> 或<strong>作业调度程序 (job scheduler)</strong> 从该地中选择进程，并装入内存以准备执行。<strong>短期调度程序 (short-term scheduler)</strong> 或 <strong>CPU 调度程序</strong>从准备执行的进程中选择进程，并为之分配 CPU 。</p><p>这两个调度程序的主要差别是它们执行的频率。短期调度程序必须频繁地为CPU 选择新进程。</p>]]></content>
    
    
    <categories>
      
      <category>Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust-Learning-4</title>
    <link href="/2019/04/09/2021/Rust-Learning-4/"/>
    <url>/2019/04/09/2021/Rust-Learning-4/</url>
    
    <content type="html"><![CDATA[<p> Rust学习进阶。</p><span id="more"></span><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期的主要目标是避免悬垂引用，它会导致程序引用了非预期引用的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> r;<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br>        r = &amp;x;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>例如上面的程序</p><p>外部作用域声明了一个没有初值的变量 <code>r</code>，而内部作用域声明了一个初值为 5 的变量<code>x</code>。在内部作用域中，我们尝试将 <code>r</code> 的值设置为一个 <code>x</code> 的引用。接着在内部作用域结束后，尝试打印出 <code>r</code> 的值。这段代码不能编译因为 <code>r</code> 引用的值在尝试使用之前就离开了作用域。如下是错误信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0597]: `x` does not live long enough<br>  --&gt; src/main.rs:7:5<br>   |<br>6  |         r = &amp;x;<br>   |              - borrow occurs here<br>7  |     &#125;<br>   |     ^ `x` dropped here while still borrowed<br>...<br>10 | &#125;<br>   | - borrowed value needs to live until here<br></code></pre></td></tr></table></figure><p>Rust 编译器有一个 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> r;                <span class="hljs-comment">// ---------+-- &#x27;a</span><br>                          <span class="hljs-comment">//          |</span><br>    &#123;                     <span class="hljs-comment">//          |</span><br>        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;        <span class="hljs-comment">// -+-- &#x27;b  |</span><br>        r = &amp;x;           <span class="hljs-comment">//  |       |</span><br>    &#125;                     <span class="hljs-comment">// -+       |</span><br>                          <span class="hljs-comment">//          |</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="hljs-comment">//          |</span><br>&#125;                         <span class="hljs-comment">// ---------+</span><br></code></pre></td></tr></table></figure><p>这里将 <code>r</code> 的生命周期标记为 <code>&#39;a</code> 并将 <code>x</code> 的生命周期标记为 <code>&#39;b</code>。如你所见，内部的 <code>&#39;b</code> 块要比外部的生命周期 <code>&#39;a</code> 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 <code>r</code> 拥有生命周期 <code>&#39;a</code>，不过它引用了一个拥有生命周期 <code>&#39;b</code> 的对象。程序被拒绝编译，因为生命周期 <code>&#39;b</code> 比生命周期 <code>&#39;a</code> 要小：被引用的对象比它的引用者存在的时间更短。</p><p>下面是一个资源借用的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">100_i32</span>;<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> x = &amp;a;<br>    &#125;  <span class="hljs-comment">// x 作用域结束</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译时，我们会看到一个严重的错误提示：</p><blockquote><p>error: unresolved name <code>x</code>.</p></blockquote><p>错误的意思是“无法解析 <code>x</code> 标识符”，也就是找不到 <code>x</code> , 这是因为像很多编程语言一样，Rust中也存在作用域概念，当资源离开离开作用域后，资源的内存就会被释放回收，当借用/引用离开作用域后也会被销毁，所以 <code>x</code> 在离开自己的作用域后，无法在作用域之外访问。</p><p>上面的涉及到几个概念：</p><ul><li><strong>Owner</strong>: 资源的所有者 <code>a</code></li><li><strong>Borrower</strong>: 资源的借用者 <code>x</code></li><li><strong>Scope</strong>: 作用域，资源被借用/引用的有效期</li></ul><p>强调下，无论是资源的所有者还是资源的借用/引用，都存在在一个有效的存活时间或区间，这个时间区间称为<strong>生命周期</strong>， 也可以直接以<strong>Scope作用域</strong>去理解。</p><p>所以上例子代码中的生命周期/作用域图示如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">            &#123;    a    &#123;    x    &#125;    *    &#125;</span><br>所有者 a:         |<span class="hljs-emphasis">_____</span><span class="hljs-emphasis">_____</span><span class="hljs-emphasis">_____</span><span class="hljs-emphasis">_____</span>____|<br>借用者 x:                   |<span class="hljs-emphasis">____</span>|            x = &amp;a<br><span class="hljs-code">  访问 x:                             |       失败：访问 x</span><br></code></pre></td></tr></table></figure><p>可以看到，借用者 <code>x</code> 的生命周期是资源所有者 <code>a</code> 的生命周期的<strong>子集</strong>。但是 <code>x</code> 的生命周期在第一个 <code>&#125;</code> 时结束并销毁，在接下来的 <code>println!</code> 中再次访问便会发生严重的错误。</p><p>我们来修正上面的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">100_i32</span>;<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> x = &amp;a;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>    &#125;  <span class="hljs-comment">// x 作用域结束</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们仅仅把 <code>println!</code> 放到了中间的 <code>&#123;&#125;</code>, 这样就可以在 <code>x</code>的生命周期内正常的访问 <code>x</code> ，此时的Lifetime图示如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">            &#123;    a    &#123;    x    *    &#125;    &#125;</span><br>所有者 a:         |<span class="hljs-emphasis">_____</span><span class="hljs-emphasis">_____</span><span class="hljs-emphasis">_____</span><span class="hljs-emphasis">_____</span>____|<br>借用者 x:                   |<span class="hljs-emphasis">_____</span>____|       x = &amp;a<br><span class="hljs-code">  访问 x:                        |            OK：访问 x</span><br></code></pre></td></tr></table></figure><h2 id="隐式Lifetime"><a href="#隐式Lifetime" class="headerlink" title="隐式Lifetime"></a>隐式Lifetime</h2><p>我们经常会遇到参数或者返回值为引用类型的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>    x<br>&#125;<br></code></pre></td></tr></table></figure><p>上面函数在实际应用中并没有太多用处，<code>foo</code> 函数仅仅接受一个 <code>&amp;str</code> 类型的参数（<code>x</code>为对某个<code>string</code>类型资源<code>Something</code>的借用），并返回对资源<code>Something</code>的一个新的借用。</p><p>实际上，上面函数包含该了隐性的生命周期命名，这是由编译器自动推导的，相当于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    x<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，约束返回值的Lifetime必须大于或等于参数<code>x</code>的Lifetime。下面函数写法也是合法的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-string">&quot;hello, world!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么呢？这是因为字符串”hello, world!”的类型是<code>&amp;&#39;static str</code>，我们知道<code>static</code>类型的Lifetime是整个程序的运行周期，所以她比任意传入的参数的Lifetime<code>&#39;a</code>都要长，即<code>&#39;static &gt;= &#39;a</code>满足。</p><p>在上例中Rust可以自动推导Lifetime，所以并不需要程序员显式指定Lifetime <code>&#39;a</code> 。</p><p><code>&#39;a</code>是什么呢？它是Lifetime的标识符，这里的<code>a</code>也可以用<code>b</code>、<code>c</code>、<code>d</code>、<code>e</code>、…，甚至可以用<code>this_is_a_long_name</code>等，当然实际编程中并不建议用这种冗长的标识符，这样会严重降低程序的可读性。<code>foo</code>后面的<code>&lt;&#39;a&gt;</code>为Lifetime的声明，可以声明多个，如<code>&lt;&#39;a, &#39;b&gt;</code>等等。</p><p>另外，除非编译器无法自动推导出Lifetime，否则不建议显式指定Lifetime标识符，会降低程序的可读性。</p><h2 id="显式Lifetime"><a href="#显式Lifetime" class="headerlink" title="显式Lifetime"></a>显式Lifetime</h2><p>当输入参数为多个借用/引用时会发生什么呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: &amp;<span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候再编译，就没那么幸运了：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>missing lifetime specifier [E0106]<br>fn foo(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;<br>                            ^~~~<br></code></pre></td></tr></table></figure><p>编译器告诉我们，需要我们显式指定Lifetime标识符，因为这个时候，编译器无法推导出返回值的Lifetime应该是比 <code>x</code>长，还是比<code>y</code>长。虽然我们在函数中中用了 <code>if true</code> 确认一定可以返回<code>x</code>，但是要知道，编译器是在编译时候检查，而不是运行时，所以编译期间会同时检查所有的输入参数和返回值。</p><p>修复后的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lifetime推导"><a href="#Lifetime推导" class="headerlink" title="Lifetime推导"></a>Lifetime推导</h2><p>要推导Lifetime是否合法，先明确两点：</p><ul><li>输出值（也称为返回值）依赖哪些输入值</li><li>输入值的Lifetime大于或等于输出值的Lifetime (准确来说：子集，而不是大于或等于)</li></ul><p><strong>Lifetime推导公式：</strong> 当输出值R依赖输入值X Y Z …，当且仅当输出值的Lifetime为所有输入值的Lifetime交集的子集时，生命周期合法。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">Lifetime</span>(<span class="hljs-variable">R</span>) ⊆ ( <span class="hljs-title">Lifetime</span>(<span class="hljs-variable">X</span>) ∩ <span class="hljs-title">Lifetime</span>(<span class="hljs-variable">Y</span>) ∩ <span class="hljs-title">Lifetime</span>(<span class="hljs-variable">Z</span>) ∩ <span class="hljs-title">Lifetime</span>(...) )</span><br></code></pre></td></tr></table></figure><p>对于例子1：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为返回值同时依赖输入参数<code>x</code>和<code>y</code>，所以</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Lifetime(返回值)</span> ⊆ ( <span class="hljs-constructor">Lifetime(<span class="hljs-params">x</span>)</span> ∩ <span class="hljs-constructor">Lifetime(<span class="hljs-params">y</span>)</span> )<br><br>即：<br><br>&#x27;a ⊆ (&#x27;a ∩ &#x27;a)  <span class="hljs-comment">// 成立</span><br></code></pre></td></tr></table></figure><h4 id="定义多个Lifetime标识符"><a href="#定义多个Lifetime标识符" class="headerlink" title="定义多个Lifetime标识符"></a>定义多个Lifetime标识符</h4><p>那我们继续看个更复杂的例子，定义多个Lifetime标识符：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看下编译，又报错了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">&lt;anon&gt;:<span class="hljs-number">5</span>:<span class="hljs-number">3</span>: <span class="hljs-number">5</span>:<span class="hljs-number">4</span> error: cannot infer an appropriate lifetime <span class="hljs-keyword">for</span> automatic coercion due to conflicting requirements [E0495]<br>&lt;anon&gt;:<span class="hljs-number">5</span>        y<br>                ^<br>&lt;anon&gt;:<span class="hljs-number">1</span>:<span class="hljs-number">1</span>: <span class="hljs-number">7</span>:<span class="hljs-number">2</span> help: consider using an explicit lifetime parameter <span class="hljs-keyword">as</span> shown: <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span><br>&lt;anon&gt;:<span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>&lt;anon&gt;:<span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>&lt;anon&gt;:<span class="hljs-number">3</span>        x<br>&lt;anon&gt;:<span class="hljs-number">4</span>    &#125; <span class="hljs-keyword">else</span> &#123;<br>&lt;anon&gt;:<span class="hljs-number">5</span>        y<br>&lt;anon&gt;:<span class="hljs-number">6</span>    &#125;<br></code></pre></td></tr></table></figure><p>编译器说自己无法正确地推导返回值的Lifetime，读者可能会疑问，“我们不是已经指定返回值的Lifetime为<code>&#39;a</code>了吗？”。</p><p>这儿我们同样可以通过生命周期推导公式推导：</p><p>因为返回值同时依赖<code>x</code>和<code>y</code>，所以</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Lifetime(返回值)</span> ⊆ ( <span class="hljs-constructor">Lifetime(<span class="hljs-params">x</span>)</span> ∩ <span class="hljs-constructor">Lifetime(<span class="hljs-params">y</span>)</span> )<br><br>即：<br><br>&#x27;a ⊆ (&#x27;a ∩ &#x27;b)  <span class="hljs-comment">//不成立</span><br></code></pre></td></tr></table></figure><p>很显然，上面我们根本没法保证成立。</p><p>所以，这种情况下，我们可以显式地告诉编译器<code>&#39;b</code>比<code>&#39;a</code>长（<code>&#39;a</code>是<code>&#39;b</code>的子集），只需要在定义Lifetime的时候, 在<code>&#39;b</code>的后面加上<code>: &#39;a</code>, 意思是<code>&#39;b</code>比<code>&#39;a</code>长，<code>&#39;a</code>是<code>&#39;b</code>的子集:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>: <span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们根据公式继续推导：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">条件：<span class="hljs-constructor">Lifetime(<span class="hljs-params">x</span>)</span> ⊆ <span class="hljs-constructor">Lifetime(<span class="hljs-params">y</span>)</span><br>推导：<span class="hljs-constructor">Lifetime(返回值)</span> ⊆ ( <span class="hljs-constructor">Lifetime(<span class="hljs-params">x</span>)</span> ∩ <span class="hljs-constructor">Lifetime(<span class="hljs-params">y</span>)</span> )<br><br>即：<br><br>条件： &#x27;a ⊆ &#x27;b<br>推导：&#x27;a ⊆ (&#x27;a ∩ &#x27;b) <span class="hljs-comment">// 成立</span><br></code></pre></td></tr></table></figure><p>上面是成立的，所以可以编译通过。</p><h4 id="推导总结"><a href="#推导总结" class="headerlink" title="推导总结"></a>推导总结</h4><p>通过上面的学习相信大家可以很轻松完成Lifetime的推导，总之，记住两点：</p><ol><li>输出值依赖哪些输入值。</li><li>推导公式。</li></ol><h2 id="Lifetime-in-struct"><a href="#Lifetime-in-struct" class="headerlink" title="Lifetime in struct"></a>Lifetime in struct</h2><p>上面我们更多讨论了函数中Lifetime的应用，在<code>struct</code>中Lifetime同样重要。</p><p>我们来定义一个<code>Person</code>结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span> &#123;<br>    age: &amp;<span class="hljs-built_in">u8</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>编译时我们会得到一个error：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;anon&gt;</span>:<span class="hljs-number">2</span>:<span class="hljs-number">8</span>: <span class="hljs-number">2</span>:<span class="hljs-number">12</span> error: missing lifetime specifier [E0106]<br><span class="hljs-params">&lt;anon&gt;</span>:<span class="hljs-number">2</span>    age: <span class="hljs-variable">&amp;str</span>,<br></code></pre></td></tr></table></figure><p>之所以会报错，这是因为Rust要确保<code>Person</code>的Lifetime不会比它的<code>age</code>借用长，不然会出现<code>Dangling Pointer</code>的严重内存问题。所以我们需要为<code>age</code>借用声明Lifetime：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    age: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>不需要对<code>Person</code>后面的<code>&lt;&#39;a&gt;</code>感到疑惑，这里的<code>&#39;a</code>并不是指<code>Person</code>这个<code>struct</code>的Lifetime，仅仅是一个泛型参数而已，<code>struct</code>可以有多个Lifetime参数用来约束不同的<code>field</code>，实际的Lifetime应该是所有<code>field</code>Lifetime交集的子集。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fn <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> x = 20_u8;<br>    <span class="hljs-keyword">let</span> stormgbs = Person &#123;<br>                        age: &amp;x,<br>                     &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，生命周期/Scope的示意图如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">                  &#123;   x    stormgbs      *     &#125;<br>所有者 x:              |<span class="hljs-type">________________________</span>|<span class="hljs-type"></span><br><span class="hljs-type">所有者 stormgbs</span>:                |<span class="hljs-type">_______________</span>|  <span class="hljs-type">&#x27;a</span><br>借用者 stormgbs.age:            |<span class="hljs-type">_______________</span>|  <span class="hljs-type">stormgbs</span>.age = &amp;x<br></code></pre></td></tr></table></figure><p>既然<code>&lt;&#39;a&gt;</code>作为<code>Person</code>的泛型参数，所以在为<code>Person</code>实现方法时也需要加上<code>&lt;&#39;a&gt;</code>，不然：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> Person &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_age</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Person.age = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;anon&gt;</span>:<span class="hljs-number">5</span>:<span class="hljs-number">6</span>: <span class="hljs-number">5</span>:<span class="hljs-number">12</span> error: wrong <span class="hljs-keyword">number</span> of lifetime parameter<span class="hljs-variable">s:</span> expected <span class="hljs-number">1</span>, found <span class="hljs-number">0</span> [E0107]<br><span class="hljs-symbol">&lt;anon&gt;</span>:<span class="hljs-number">5</span> impl Person &#123;<br>              ^~~~~~<br></code></pre></td></tr></table></figure><p><strong>正确的做法是</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Person&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print_age</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Person.age = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样加上<code>&lt;&#39;a&gt;</code>后就可以了。读者可能会疑问，为什么<code>print_age</code>中不需要加上<code>&#39;a</code>？这是个好问题。因为<code>print_age</code>的输出参数为<code>()</code>，也就是可以不依赖任何输入参数, 所以编译器此时可以不必关心和推导Lifetime。即使是<code>fn print_age(&amp;self, other_age: &amp;i32) &#123;...&#125;</code>也可以编译通过。</p><p><strong>如果Person的方法存在输出值（借用）呢？</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Person&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_age</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">u8</span> &#123;<br>        <span class="hljs-keyword">self</span>.age<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>get_age</code>方法的输出值依赖一个输入值<code>&amp;self</code>，这种情况下，Rust编译器可以自动推导为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Person&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_age</span></span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span> &#123;<br>        <span class="hljs-keyword">self</span>.age<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果输出值（借用）依赖了多个输入值呢？</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; Person&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_max_age</span></span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, p: &amp;<span class="hljs-symbol">&#x27;a</span> Person) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">u8</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.age &gt; p.age &#123;<br>            <span class="hljs-keyword">self</span>.age<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.age<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似之前的Lifetime推导章节，当返回值（借用）依赖多个输入值时，需显示声明Lifetime。和函数Lifetime同理。</p><p><strong>其他</strong></p><p>无论在函数还是在<code>struct</code>中，甚至在<code>enum</code>中，Lifetime理论知识都是一样的。希望大家可以慢慢体会和吸收，做到举一反三。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Programming Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust-Learning-3</title>
    <link href="/2019/04/07/2021/Rust-Learning-3/"/>
    <url>/2019/04/07/2021/Rust-Learning-3/</url>
    
    <content type="html"><![CDATA[<p>Rust学习进阶。</p> <span id="more"></span><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>两个只在名称和签名中类型有所不同的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> integer = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-keyword">let</span> float = Point &#123; x: <span class="hljs-number">1.0</span>, y: <span class="hljs-number">4.0</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>用T表示泛型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>&lt;T, U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> both_integer = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-keyword">let</span> both_float = Point &#123; x: <span class="hljs-number">1.0</span>, y: <span class="hljs-number">4.0</span> &#125;;<br>    <span class="hljs-keyword">let</span> integer_and_float = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">4.0</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有不同类型需求，需要这样用<code>U</code></p><p>枚举也可以拥有多个泛型类型。第九章使用过的 <code>Result</code> 枚举定义就是一个这样的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Result</span></span>&lt;T, E&gt; &#123;<br>    <span class="hljs-literal">Ok</span>(T),<br>    <span class="hljs-literal">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Result</code> 枚举有两个泛型类型，<code>T</code> 和 <code>E</code>。<code>Result</code> 有两个成员：<code>Ok</code>，它存放一个类型 <code>T</code> 的值，而 <code>Err</code> 则存放一个类型 <code>E</code> 的值。这个定义使得 <code>Result</code> 枚举能很方便的表达任何可能成功（返回 <code>T</code> 类型的值）也可能失败（返回 <code>E</code> 类型的值）的操作。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> Point&lt;<span class="hljs-built_in">f32</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">distance_from_origin</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f32</span> &#123;<br>        (<span class="hljs-keyword">self</span>.x.powi(<span class="hljs-number">2</span>) + <span class="hljs-keyword">self</span>.y.powi(<span class="hljs-number">2</span>)).sqrt()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样可以为不同的类型单独设计不同的方法</p><h1 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h1><p>使用<strong>trait</strong>定义一个特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">HasArea</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f64</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>trait</strong>里面的函数可以没有函数体，实现代码交给具体实现它的类型去补充：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span></span> &#123;<br>    x: <span class="hljs-built_in">f64</span>,<br>    y: <span class="hljs-built_in">f64</span>,<br>    radius: <span class="hljs-built_in">f64</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> HasArea <span class="hljs-keyword">for</span> Circle &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f64</span> &#123;<br>        std::<span class="hljs-built_in">f64</span>::consts::PI * (<span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> c = Circle &#123;<br>        x: <span class="hljs-number">0.0f64</span>,<br>        y: <span class="hljs-number">0.0f64</span>,<br>        radius: <span class="hljs-number">1.0f64</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;circle c has an area of &#123;&#125;&quot;</span>, c.area());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="trait与泛型"><a href="#trait与泛型" class="headerlink" title="trait与泛型"></a>trait与泛型</h2><blockquote><p>我们了解了Rust中trait的定义和使用，接下来我们介绍一下它的使用场景，从中我们可以窥探出接口这特性带来的惊喜</p></blockquote><p>我们知道泛型可以指任意类型，但有时这不是我们想要的，需要给它一些约束。</p><h3 id="泛型的trait约束"><a href="#泛型的trait约束" class="headerlink" title="泛型的trait约束"></a>泛型的trait约束</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;T: <span class="hljs-built_in">Debug</span>&gt;(s: T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>Debug是<strong>Rust</strong>内置的一个trait，为”{:?}”实现打印内容，函数<code>foo</code>接受一个泛型作为参数，并且约定其需要实现`Debug</p><h3 id="多trait约束"><a href="#多trait约束" class="headerlink" title="多trait约束"></a>多trait约束</h3><p>可以使用多个trait对泛型进行约束：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;T: <span class="hljs-built_in">Debug</span> + <span class="hljs-built_in">Clone</span>&gt;(s: T) &#123;<br>    s.clone();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;T: Debug + Clone&gt;</code>中<code>Debug</code>和<code>Clone</code>使用<code>+</code>连接，标示泛型<code>T</code>需要同时实现这两个trait。</p><h3 id="where关键字"><a href="#where关键字" class="headerlink" title="where关键字"></a>where关键字</h3><p>约束的trait增加后，代码看起来就变得诡异了，这时候需要使用<code>where</code>从句：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;T: <span class="hljs-built_in">Clone</span>, K: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>&gt;(x: T, y: K) &#123;<br>    x.clone();<br>    y.clone();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, y);<br>&#125;<br><br><span class="hljs-comment">// where 从句</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;T, K&gt;(x: T, y: K) <span class="hljs-keyword">where</span> T: <span class="hljs-built_in">Clone</span>, K: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span> &#123;<br>    x.clone();<br>    y.clone();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, y);<br>&#125;<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;T, K&gt;(x: T, y: K)<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-built_in">Clone</span>,<br>          K: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span> &#123;<br>    x.clone();<br>    y.clone();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="trait与内置类型"><a href="#trait与内置类型" class="headerlink" title="trait与内置类型"></a>trait与内置类型</h2><p>内置类型如：<code>i32</code>, <code>i64</code>等也可以添加trait实现，为其定制一些功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">HasArea</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f64</span>;<br>&#125;<br><br><span class="hljs-keyword">impl</span> HasArea <span class="hljs-keyword">for</span> <span class="hljs-built_in">i32</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f64</span> &#123;<br>        *<span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span><br>    &#125;<br>&#125;<br><br><span class="hljs-number">5</span>.area();<br></code></pre></td></tr></table></figure><p>这样的做法是有限制的。Rust 有一个“孤儿规则”：当你为某类型实现某 trait 的时候，必须要求类型或者 trait 至少有一个是在当前 crate 中定义的。你不能为第三方的类型实现第三方的 trait 。</p><p>在调用 trait 中定义的方法的时候，一定要记得让这个 trait 可被访问。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> f = std::fs::File::open(<span class="hljs-string">&quot;foo.txt&quot;</span>).ok().expect(<span class="hljs-string">&quot;Couldn’t open foo.txt&quot;</span>);<br><span class="hljs-keyword">let</span> buf = <span class="hljs-string">b&quot;whatever&quot;</span>; <span class="hljs-comment">//  buf: &amp;[u8; 8]</span><br><span class="hljs-keyword">let</span> result = f.write(buf);<br># result.unwrap();<br></code></pre></td></tr></table></figure><p>这里是错误：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">error: <span class="hljs-keyword">type</span> `std::fs::File` does <span class="hljs-keyword">not</span> implement any <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">in</span> <span class="hljs-title">scope</span> <span class="hljs-title">named</span> `<span class="hljs-title">write</span>`</span><br><span class="hljs-function"><span class="hljs-title">let</span> <span class="hljs-title">result</span> = <span class="hljs-title">f</span>.<span class="hljs-title">write</span><span class="hljs-params">(buf)</span>;</span><br>               ^~~~~~~~~~<br></code></pre></td></tr></table></figure><p>我们需要先use这个Write trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Write;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> f = std::fs::File::open(<span class="hljs-string">&quot;foo.txt&quot;</span>).expect(<span class="hljs-string">&quot;Couldn’t open foo.txt&quot;</span>);<br><span class="hljs-keyword">let</span> buf = <span class="hljs-string">b&quot;whatever&quot;</span>;<br><span class="hljs-keyword">let</span> result = f.write(buf);<br># result.unwrap(); <span class="hljs-comment">// ignore the error</span><br></code></pre></td></tr></table></figure><p>这样就能无错误地编译了。</p><h2 id="trait的默认方法"><a href="#trait的默认方法" class="headerlink" title="trait的默认方法"></a>trait的默认方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_valid</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_invalid</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> &#123; !<span class="hljs-keyword">self</span>.is_valid() &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>is_invalid</code>是默认方法，<code>Foo</code>的实现者并不要求实现它，如果选择实现它，会覆盖掉它的默认行为。</p><h2 id="trait的继承"><a href="#trait的继承" class="headerlink" title="trait的继承"></a>trait的继承</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FooBar</span></span> : Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foobar</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样<code>FooBar</code>的实现者也要同时实现<code>Foo</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Baz</span></span>;<br><br><span class="hljs-keyword">impl</span> Foo <span class="hljs-keyword">for</span> Baz &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;foo&quot;</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> FooBar <span class="hljs-keyword">for</span> Baz &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foobar</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;foobar&quot;</span>); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="derive属性"><a href="#derive属性" class="headerlink" title="derive属性"></a>derive属性</h2><p><strong>Rust</strong>提供了一个属性<code>derive</code>来自动实现一些trait，这样可以避免重复繁琐地实现他们，能被<code>derive</code>使用的trait包括：<code>Clone</code>, <code>Copy</code>, <code>Debug</code>, <code>Default</code>, <code>Eq</code>, <code>Hash</code>, <code>Ord</code>, <code>PartialEq</code>, <code>PartialOrd</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, Foo);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="impl-Trait"><a href="#impl-Trait" class="headerlink" title="impl Trait"></a>impl Trait</h2><p>在版本1.26 开始，Rust提供了<code>impl Trait</code>的写法，作为和Scala 对等的<code>既存型别(Existential Type)</code>的写法。</p><p>在下面这个写法中，<code>fn foo()</code>将返回一个实作了<code>Trait</code>的trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//before</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;Trait&gt; &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">//after</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>() -&gt; <span class="hljs-keyword">impl</span> Trait &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相较于1.25 版本以前的写法，新的写法会在很多场合中更有利于开发和执行效率。</p><h3 id="impl-Trait-的普遍用例"><a href="#impl-Trait-的普遍用例" class="headerlink" title="impl Trait 的普遍用例"></a>impl Trait 的普遍用例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">method</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> <span class="hljs-built_in">i32</span> &#123;<br>    <span class="hljs-comment">// implementation goes here</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> <span class="hljs-built_in">f32</span> &#123;<br>    <span class="hljs-comment">// implementation goes here</span><br>&#125;<br></code></pre></td></tr></table></figure><p>利用Box 会意味：即便回传的内容是固定的，但也会使用到动态内存分配。利用<code>impl Trait</code> 的写法可以避免便用Box。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//before</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;Trait&gt; &#123;<br>    <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Box</span>&lt;Trait&gt;<br>&#125;<br><br><span class="hljs-comment">//after</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>() -&gt; <span class="hljs-keyword">impl</span> Trait &#123;<br>    <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他受益的用例"><a href="#其他受益的用例" class="headerlink" title="其他受益的用例"></a>其他受益的用例</h3><p>闭包:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// before</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>() -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-built_in">Fn</span>(<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span>&gt; &#123;<br>    <span class="hljs-built_in">Box</span>::new(|x| x + <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// after</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>() -&gt; <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Fn</span>(<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    |x| x + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>传参：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// before</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>&lt;T: Trait&gt;(x: T) &#123;<br><br><span class="hljs-comment">// after</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: <span class="hljs-keyword">impl</span> Trait) &#123;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Programming Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust-Learning-2</title>
    <link href="/2019/04/05/2021/Rust-Learning-2/"/>
    <url>/2019/04/05/2021/Rust-Learning-2/</url>
    
    <content type="html"><![CDATA[<p>Rust学习篇，介绍Rust的基础知识。</p> <span id="more"></span><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span></span> &#123;<br>    username: <span class="hljs-built_in">String</span>,<br>    email: <span class="hljs-built_in">String</span>,<br>    sign_in_count: <span class="hljs-built_in">u64</span>,<br>    active: <span class="hljs-built_in">bool</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦定义了结构体后，为了使用它，通过为每个字段指定具体值来创建这个结构体的 <strong>实例</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> user1 = User &#123;<br>    email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>    username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>    active: <span class="hljs-literal">true</span>,<br>    sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h2><p><strong>变量与字段同名时的字段初始化简写语法</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">build_user</span></span>(email: <span class="hljs-built_in">String</span>, username: <span class="hljs-built_in">String</span>) -&gt; User &#123;<br>    User &#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结构体更新语法</strong>（<em>struct update syntax</em>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> user2 = User &#123;<br>    email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>    username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;anotherusername567&quot;</span>),<br>    active: user1.active,<br>    sign_in_count: user1.sign_in_count,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>可以简单写成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> user2 = User &#123;<br>    email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>    username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;anotherusername567&quot;</span>),<br>    ..user1<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>无命名字段</strong> 我们叫做<strong>元组结构体</strong>（<em>tuple structs</em>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);<br><br><span class="hljs-keyword">let</span> black = Color(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> origin = Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>我们也可以定义一个没有任何字段的结构体！它们被称为 <strong>类单元结构体</strong>（<em>unit-like structs</em>）</p><h2 id="结构体例子"><a href="#结构体例子" class="headerlink" title="结构体例子"></a>结构体例子</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> rect1 = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        area(&amp;rect1)<br>    );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(rectangle: &amp;Rectangle) -&gt; <span class="hljs-built_in">u32</span> &#123;<br>    rectangle.width * rectangle.height<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们来试试！现在 <code>println!</code> 宏调用看起来像 <code>println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);</code> 这样。在 <code>&#123;&#125;</code> 中加入 <code>:?</code> 指示符告诉 <code>println!</code> 我们想要使用叫做 <code>Debug</code> 的输出格式。<code>Debug</code> 是一个 trait，它允许我们以一种对开发者有帮助的方式打印结构体，以便当我们调试代码时能看到它的值。为此，在结构体定义之前加上 <code># derive(Debug)]</code> 注解。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> rect1 = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">rect1 is Rectangle &#123; width: 30, height: 50 &#125;<br></code></pre></td></tr></table></figure><h2 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a>方法语法</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法</strong> 与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Rectangle &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> rect1 = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        rect1.area()<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法语法</strong>（<em>method syntax</em>）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。</p><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p><code>impl</code> 块的另一个有用的功能是：允许在 <code>impl</code> 块中定义 <strong>不</strong> 以 <code>self</code> 作为参数的函数。这被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 <code>String::from</code> 关联函数了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> Rectangle &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">square</span></span>(size: <span class="hljs-built_in">u32</span>) -&gt; Rectangle &#123;<br>        Rectangle &#123; width: size, height: size &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用结构体名和 <code>::</code> 语法来调用这个关联函数：比如 <code>let sq = Rectangle::square(3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。第七章会讲到模块。</p><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>可以通过在代码中定义一个 <code>IpAddrKind</code> 枚举来表现这个概念并列出可能的 IP 地址类型，<code>V4</code> 和 <code>V6</code>。这被称为枚举的 <strong>成员</strong>（<em>variants</em>）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IpAddrKind</span></span> &#123;<br>    V4,<br>    V6,<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举值</p><p>可以像这样创建 <code>IpAddrKind</code> 两个不同成员的实例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> four = IpAddrKind::V4;<br><span class="hljs-keyword">let</span> six = IpAddrKind::V6;<br></code></pre></td></tr></table></figure><p>注意枚举的成员位于其标识符的命名空间中，并使用两个冒号分开。这么设计的益处是现在 <code>IpAddrKind::V4</code> 和 <code>IpAddrKind::V6</code> 都是 <code>IpAddrKind</code> 类型的。例如，接着可以定义一个函数来获取任何 <code>IpAddrKind</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">route</span></span>(ip_type: IpAddrKind) &#123; &#125;<br></code></pre></td></tr></table></figure><p>现在可以使用任一成员来调用这个函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">route(IpAddrKind::V4);<br>route(IpAddrKind::V6);<br></code></pre></td></tr></table></figure><p>使用枚举甚至还有更多优势。进一步考虑一下我们的 IP 地址类型，目前没有一个存储实际 IP 地址 <strong>数据</strong> 的方法；只知道它是什么 <strong>类型</strong> 的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IpAddrKind</span></span> &#123;<br>    V4,<br>    V6,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IpAddr</span></span> &#123;<br>    kind: IpAddrKind,<br>    address: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> home = IpAddr &#123;<br>    kind: IpAddrKind::V4,<br>    address: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;127.0.0.1&quot;</span>),<br>&#125;;<br><br><span class="hljs-keyword">let</span> loopback = IpAddr &#123;<br>    kind: IpAddrKind::V6,<br>    address: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;::1&quot;</span>),<br>&#125;;<br></code></pre></td></tr></table></figure><p>用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。IPv4 版本的 IP 地址总是含有四个值在 0 和 255 之间的数字部分。如果我们想要将 <code>V4</code> 地址存储为四个 <code>u8</code> 值而 <code>V6</code> 地址仍然表现为一个 <code>String</code>，这就不能使用结构体了。枚举则可以轻易处理的这个情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IpAddr</span></span> &#123;<br>    V4(<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>),<br>    V6(<span class="hljs-built_in">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> home = IpAddr::V4(<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">let</span> loopback = IpAddr::V6(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;::1&quot;</span>));<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> Message &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 在这里定义方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> m = Message::Write(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>));<br>m.call();<br></code></pre></td></tr></table></figure><p>有一个非常重要的枚举类型：<code>Option&lt;T&gt;</code></p><p><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option文档</a></p><h2 id="match控制流"><a href="#match控制流" class="headerlink" title="match控制流"></a>match控制流</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> &#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    Quarter,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u32</span> &#123;<br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; <span class="hljs-number">1</span>,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter =&gt; <span class="hljs-number">25</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 <code>Coin::Penny</code> 而之后的 <code>=&gt;</code> 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 <code>1</code>。每一个分支之间使用逗号分隔。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u32</span> &#123;<br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Lucky penny!&quot;</span>);<br>            <span class="hljs-number">1</span><br>        &#125;,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter =&gt; <span class="hljs-number">25</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要在分支中运行多行代码，可以使用大括号。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span> <span class="hljs-comment">// 这样可以可以立刻看到州的名称</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UsState</span></span> &#123;<br>    Alabama,<br>    Alaska,<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> &#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    Quarter(UsState),<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u32</span> &#123;<br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; <span class="hljs-number">1</span>,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter(state) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);<br>            <span class="hljs-number">25</span><br>        &#125;,<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>如果调用 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>，<code>coin</code> 将是 <code>Coin::Quarter(UsState::Alaska)</code>。当将值与每个分支相比较时，没有分支会匹配，直到遇到 <code>Coin::Quarter(state)</code>。这时，<code>state</code> 绑定的将会是值 <code>UsState::Alaska</code>。接着就可以在 <code>println!</code> 表达式中使用这个绑定了，像这样就可以获取 <code>Coin</code> 枚举的 <code>Quarter</code> 成员中内部的州的值。</p><h3 id="match枚举必须写齐全"><a href="#match枚举必须写齐全" class="headerlink" title="match枚举必须写齐全"></a>match枚举必须写齐全</h3><p><code>match</code> 还有另一方面需要讨论。考虑一下 <code>plus_one</code> 函数的这个版本，它有一个 bug 并不能编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; &#123;<br>    <span class="hljs-keyword">match</span> x &#123;<br>        <span class="hljs-literal">Some</span>(i) =&gt; <span class="hljs-literal">Some</span>(i + <span class="hljs-number">1</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">error[E0004]: non-exhaustive patterns:</span> `None` <span class="hljs-literal">not</span> covered<br> --&gt;<br>  |<br><span class="hljs-number">6</span> |         match x &#123;<br>  |               ^ pattern `None` <span class="hljs-literal">not</span> covered<br></code></pre></td></tr></table></figure><p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 <strong>穷尽的</strong>（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这使我们免于假设拥有一个实际上为空的值，这造成了之前提到过的价值亿万的错误。</p><h3 id="match通配符"><a href="#match通配符" class="headerlink" title="match通配符"></a>match通配符</h3><p>Rust 也提供了一个模式用于不想列举出所有可能值的场景。例如，<code>u8</code> 可以拥有 0 到 255 的有效的值，如果我们只关心 1、3、5 和 7 这几个值，就并不想必须列出 0、2、4、6、8、9 一直到 255 的值。所幸我们不必这么做：可以使用特殊的模式 <code>_</code> 替代：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq"><br><span class="hljs-keyword">let</span> some_u8_value = <span class="hljs-number">0</span>u8;<br><span class="hljs-keyword">match</span> some_u8_value &#123;<br>    <span class="hljs-number">1</span> =&gt; println!(<span class="hljs-string">&quot;one&quot;</span>),<br>    <span class="hljs-number">3</span> =&gt; println!(<span class="hljs-string">&quot;three&quot;</span>),<br>    <span class="hljs-number">5</span> =&gt; println!(<span class="hljs-string">&quot;five&quot;</span>),<br>    <span class="hljs-number">7</span> =&gt; println!(<span class="hljs-string">&quot;seven&quot;</span>),<br>    <span class="hljs-keyword">_</span> =&gt; (),<br>&#125;<br></code></pre></td></tr></table></figure><p><code>_</code> 模式会匹配所有的值。通过将其放置于其他分支之后，<code>_</code> 将会匹配所有之前没有指定的可能的值。<code>()</code> 就是 unit 值，所以 <code>_</code> 的情况什么也不会发生。因此，可以说我们想要对 <code>_</code> 通配符之前没有列出的所有可能的值不做任何处理。</p><h2 id="if-let-简洁控制流"><a href="#if-let-简洁控制流" class="headerlink" title="if let 简洁控制流"></a>if let 简洁控制流</h2><p><code>if let</code> 语法让我们以一种不那么冗长的方式结合 <code>if</code> 和 <code>let</code>，来处理只匹配一个模式的值而忽略其他模式的情况。考虑示例 6-6 中的程序，它匹配一个 <code>Option&lt;u8&gt;</code> 值并只希望当值为 3 时执行代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> some_u8_value = <span class="hljs-literal">Some</span>(<span class="hljs-number">0u8</span>);<br><span class="hljs-keyword">match</span> some_u8_value &#123;<br>    <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; (),<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) = some_u8_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以加上一处else以对操作进行扩展</p><p>可以在 <code>if let</code> 中包含一个 <code>else</code>。<code>else</code> 块中的代码与 <code>match</code> 表达式中的 <code>_</code> 分支块中的代码相同，这样的 <code>match</code> 表达式就等同于 <code>if let</code> 和 <code>else</code>。回忆一下示例 6-4 中 <code>Coin</code> 枚举的定义，其 <code>Quarter</code> 成员也包含一个 <code>UsState</code> 值。如果想要计数所有不是 25 美分的硬币的同时也报告 25 美分硬币所属的州，可以使用这样一个 <code>match</code> 表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">match</span> coin &#123;<br>    Coin::Quarter(state) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state),<br>    _ =&gt; count += <span class="hljs-number">1</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>或者可以使用这样的 <code>if let</code> 和 <code>else</code> 表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> Coin::Quarter(state) = coin &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    count += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="包、crate、模块"><a href="#包、crate、模块" class="headerlink" title="包、crate、模块"></a>包、crate、模块</h1><p>让我们聊聊 <strong>模块</strong> 与 <em>crate</em>。下面是一个总结：</p><ul><li><em>crate</em> 是一个二进制或库项目。</li><li><strong>crate 根</strong>（<em>crate root</em>）是一个用来描述如何构建 crate 的文件。</li><li>带有 <em>Cargo.toml</em> 文件的 <strong>包</strong> 用以描述如何构建一个或多个 crate。一个包中至多可以有一个库项目。</li></ul><p>一个包可以带有零个或一个库 crate 和任意多个二进制 crate。一个包中必须带有至少一个（库或者二进制）crate。</p><p>如果包同时包含 <em>src/main.rs</em> 和 <em>src/lib.rs</em>，那么它带有两个 crate：一个库和一个二进制项目，同名。如果只有其中之一，则包将只有一个库或者二进制 crate。包可以带有多个二进制 crate，需将其文件置于 <em>src/bin</em> 目录；每个文件将是一个单独的二进制 crate。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>首先讲讲模块。模块允许我们将代码组织起来。下面的代码定义了名为 <code>sound</code> 的模块，其包含名为 <code>guitar</code> 的函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">guitar</span></span>() &#123;<br>        <span class="hljs-comment">// 函数体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里定义了两个函数，<code>guitar</code> 和 <code>main</code>。<code>guitar</code> 函数定义于 <code>mod</code> 块中。这个块定义了 <code>sound</code> 模块。</p><p>为了将代码组织到模块层次体系中，可以将模块嵌套进其他模块，如示例 7-2 所示：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">mod</span> woodwind &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>                <span class="hljs-comment">// 函数体</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">mod</span> voice &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 “包和 crate 用来创建库和二进制项目” 部分提到 <em>src/main.rs</em> 和 <em>src/lib.rs</em> 被称为 <strong>crate 根</strong>。他们被称为 crate 根是因为这两个文件在 crate 模块树的根组成了名为 <code>crate</code> 模块。所以示例 7-2 中，有如示例 7-3 所示的模块树：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel"><br>crate<br>└── <span class="hljs-keyword">sound</span><br>    ├── instrument<br>    │   └── woodwind<br>    └── voice<br></code></pre></td></tr></table></figure><p>如果想要调用函数，需要知道其 <strong>路径</strong>。“路径” 是 “名称”（“name”） 的同义词，不过它用于文件系统语境。另外，函数、结构体和其他项可能会有多个指向相同项的路径，所以 “名称” 这个概念不太准确。</p><p><strong>路径</strong> 可以有两种形式：</p><ul><li><strong>绝对路径</strong>（<em>absolute path</em>）从 crate 根开始，以 crate 名或者字面值 <code>crate</code> 开头。</li><li><strong>相对路径</strong>（<em>relative path</em>）从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li></ul><p>绝对路径和相对路径都后跟一个或多个由双冒号（<code>::</code>）分割的标识符。</p><h3 id="模块私有性"><a href="#模块私有性" class="headerlink" title="模块私有性"></a>模块私有性</h3><p>之前我们讨论到模块的语法和组织代码的用途。Rust 采用模块还有另一个原因：模块是 Rust 中的 <strong>私有性边界</strong>（<em>privacy boundary</em>）。如果你希望函数或结构体是私有的，将其放入模块。私有性规则有如下：</p><ul><li>所有项（函数、方法、结构体、枚举、模块和常量）默认是私有的。</li><li>可以使用 <code>pub</code> 关键字使项变为公有。</li><li>不允许使用定义于当前模块的子模块中的私有代码。</li><li>允许使用任何定义于父模块或当前模块中的代码。</li></ul><p>换句话说，对于没有 <code>pub</code> 关键字的项，当你从当前模块向 “下” 看时是私有的，不过当你向 “上” 看时是公有的。再一次想象一下文件系统：如果你没有某个目录的权限，则无法从父目录中查看其内容。如果有该目录的权限，则可以查看其中的目录和任何父目录。</p><p>现在的错误表明 <code>clarinet</code> 函数是私有的。私有性规则适用于结构体、枚举、函数和方法以及模块。</p><p>在 <code>clarinet</code> 函数前增加 <code>pub</code> 关键字使其变为公有，如示例 7-8 所示：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            <span class="hljs-comment">// 函数体</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 绝对路径</span><br>    crate::sound::instrument::clarinet();<br><br>    <span class="hljs-comment">// 相对路径</span><br>    sound::instrument::clarinet();<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用 <code>super</code> 开头来构建相对路径。这么做类似于文件系统中以 <code>..</code> 开头：该路径从 <strong>父</strong> 模块开始而不是当前模块。这在例如示例 7-9 这样的情况下有用处，在这里 <code>clarinet</code> 函数通过指定以 <code>super</code> 开头的路径调用 <code>breathe_in</code> 函数：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">mod</span> instrument &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>        super::breathe_in();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">breathe_in</span></span>() &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>clarinet</code> 函数位于 <code>instrument</code> 模块中，所以可以使用 <code>super</code> 进入 <code>instrument</code> 的父模块，也就是根 <code>crate</code>。从这里可以找到 <code>breathe_in</code>。成功！</p><p>你可能想要使用 <code>super</code> 开头的相对路而不是以 <code>crate</code> 开头的绝对路径的原因是  <code>super</code> 可能会使修改有着不同模块层级结构的代码变得更容易，如果定义项和调用项的代码被一同移动的话。例如，如果我们决定将 <code>instrument</code> 模块和 <code>breathe_in</code> 函数放入 <code>sound</code> 模块中，这时我们只需增加 <code>sound</code> 模块即可，如示例 7-10 所示。</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            super::breathe_in();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">breathe_in</span></span>() &#123;<br>        <span class="hljs-comment">// 函数体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体和枚举类型的pub"><a href="#结构体和枚举类型的pub" class="headerlink" title="结构体和枚举类型的pub"></a>结构体和枚举类型的pub</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> plant &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vegetable</span></span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-built_in">String</span>,<br>        id: <span class="hljs-built_in">i32</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> Vegetable &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(name: &amp;<span class="hljs-built_in">str</span>) -&gt; Vegetable &#123;<br>            Vegetable &#123;<br>                name: <span class="hljs-built_in">String</span>::from(name),<br>                id: <span class="hljs-number">1</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = plant::Vegetable::new(<span class="hljs-string">&quot;squash&quot;</span>);<br><br>    v.name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;butternut squash&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; are delicious&quot;</span>, v.name);<br><br>    <span class="hljs-comment">// 如果将如下行取消注释代码将无法编译:</span><br>    <span class="hljs-comment">// println!(&quot;The ID is &#123;&#125;&quot;, v.id);</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> menu &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Appetizer</span></span> &#123;<br>        Soup,<br>        Salad,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> order1 = menu::Appetizer::Soup;<br>    <span class="hljs-keyword">let</span> order2 = menu::Appetizer::Salad;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="use-缩短关键路径"><a href="#use-缩短关键路径" class="headerlink" title="use 缩短关键路径"></a>use 缩短关键路径</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            <span class="hljs-comment">// 函数体</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::sound::instrument;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    instrument::clarinet();<br>    instrument::clarinet();<br>    instrument::clarinet();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            <span class="hljs-comment">// 函数体</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> performance_group &#123;<br>    <span class="hljs-keyword">use</span> crate::sound::instrument;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet_trio</span></span>() &#123;<br>        instrument::clarinet();<br>        instrument::clarinet();<br>        instrument::clarinet();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    performance_group::clarinet_trio();<br>&#125;<br></code></pre></td></tr></table></figure><p>示例 7-13 中，你可能会好奇为什么指定 <code>use crate::sound::instrument</code> 接着在 <code>main</code> 中调用 <code>instrument::clarinet</code>，而不是如示例 7-16 所示的有相同行为的代码：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            <span class="hljs-comment">// 函数体</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::sound::instrument::clarinet;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    clarinet();<br>    clarinet();<br>    clarinet();<br>&#125;<br></code></pre></td></tr></table></figure><p>示例 7-16: 通过 <code>use</code> 将 <code>clarinet</code> 函数引入作用域，这是不推荐的</p><p>对于函数来说，通过 <code>use</code> 指定函数的父模块接着指定父模块来调用方法被认为是习惯用法。这么做而不是像示例 7-16 那样通过 <code>use</code> 指定函数的路径，清楚的表明了函数不是本地定义的，同时仍最小化了指定全路径时的重复。</p><p>对于结构体、枚举和其它项，通过 <code>use</code> 指定项的全路径是习惯用法。例如，示例 7-17 展示了将标准库中 <code>HashMap</code> 结构体引入作用域的习惯用法。</p><h3 id="as关键字"><a href="#as关键字" class="headerlink" title="as关键字"></a>as关键字</h3><p>将两个同名类型引入同一作用域这个问题还有另一个解决办法：可以通过在 <code>use</code> 后加上 <code>as</code> 和一个新名称来为此类型指定一个新的本地名称。示例 7-20 展示了另一个编写示例 7-19 中代码的方法，通过 <code>as</code> 重命名了其中一个 <code>Result</code> 类型。</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Result</span>;<br><span class="hljs-keyword">use</span> std::io::<span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function1</span></span>() -&gt; <span class="hljs-built_in">Result</span> &#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function2</span></span>() -&gt; IoResult&lt;()&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h3><p>当使用 <code>use</code> 关键字将名称导入作用域时，在新作用域中可用的名称是私有的。如果希望调用你编写的代码的代码能够像你一样在其自己的作用域内引用这些类型，可以结合 <code>pub</code> 和 <code>use</code>。这个技术被称为 “重导出”（<em>re-exporting</em>），因为这样做将项引入作用域并同时使其可供其他代码引入自己的作用域。</p><p>例如，示例 7-21 展示了示例 7-15 中的代码将 <code>performance_group</code> 的 <code>use</code> 变为 <code>pub use</code> 的版本。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            <span class="hljs-comment">// 函数体</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> performance_group &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::sound::instrument;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet_trio</span></span>() &#123;<br>        instrument::clarinet();<br>        instrument::clarinet();<br>        instrument::clarinet();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    performance_group::clarinet_trio();<br>    performance_group::instrument::clarinet();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="外部包"><a href="#外部包" class="headerlink" title="外部包"></a>外部包</h3><p>在 <em>Cargo.toml</em> 中加入 <code>rand</code> 依赖告诉了 Cargo 要从 <em><a href="https://crates.io/">https://crates.io</a></em> 下载 <code>rand</code> 和其依赖，并使其可在项目代码中使用。</p><p>接着，为了将 <code>rand</code> 定义引入项目包的作用域，加入一行 <code>use</code>，它以 <code>rand</code> 包名开头并列出了需要引入作用域的项。回忆一下第二章的 “生成一个随机数” 部分，我们曾将 <code>Rng</code> trait 引入作用域并调用了 <code>rand::thread_rng</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand::Rng;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意标准库（<code>std</code>）对于你的包来说也是外部 crate。因为标准库随 Rust 语言一同分发，无需修改 <em>Cargo.toml</em> 来引入 <code>std</code>，不过需要通过 <code>use</code> 将标准库中定义的项引入项目包的作用域中来引用它们，比如 <code>HashMap</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br></code></pre></td></tr></table></figure><p>这是一个以标注库 crate 名 <code>std</code> 开头的绝对路径。</p><h1 id="通用集合类型"><a href="#通用集合类型" class="headerlink" title="通用集合类型"></a>通用集合类型</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector 允许我们在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。</p><h3 id="创建vector"><a href="#创建vector" class="headerlink" title="创建vector"></a>创建vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">Vec</span>::new();<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>vec！为Rust自带的宏</p><h3 id="更新vector"><a href="#更新vector" class="headerlink" title="更新vector"></a>更新vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">Vec</span>::new();<br><br>v.push(<span class="hljs-number">5</span>);<br>v.push(<span class="hljs-number">6</span>);<br>v.push(<span class="hljs-number">7</span>);<br>v.push(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><h3 id="vector作用域"><a href="#vector作用域" class="headerlink" title="vector作用域"></a>vector作用域</h3><p>丢弃 vector 时也会丢弃其所有元素</p><p>类似于任何其他的 <code>struct</code>，vector 在其离开作用域时会被释放，如示例 8-4 所标注的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>&#123;<br>    let v = vec![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>    <span class="hljs-regexp">//</span> 处理变量 v<br><br>&#125; <span class="hljs-regexp">//</span> &lt;- 这里 v 离开作用域并被丢弃<br></code></pre></td></tr></table></figure><p>示例 8-4：展示 vector 和其元素于何处被丢弃</p><p>当 vector 被丢弃时，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理。这可能看起来非常直观，不过一旦开始使用 vector 元素的引用，情况就变得有些复杂了。</p><h3 id="读取vector元素的方法"><a href="#读取vector元素的方法" class="headerlink" title="读取vector元素的方法"></a>读取vector元素的方法</h3><p>现在你知道如何创建、更新和销毁 vector 了，接下来的一步最好了解一下如何读取它们的内容。有两种方法引用 vector 中储存的值。为了更加清楚的说明这个例子，我们标注这些函数返回的值的类型。</p><p>展示了访问 vector 中一个值的两种方式，索引语法或者 <code>get</code> 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> third: &amp;<span class="hljs-built_in">i32</span> = &amp;v[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;&#125;&quot;</span>, third);<br><br><span class="hljs-keyword">match</span> v.get(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-literal">Some</span>(third) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;&#125;&quot;</span>, third),<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no third element.&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两个需要注意的地方。首先，我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 0 开始的。其次，这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</p><h3 id="遍历-vector-中的元素"><a href="#遍历-vector-中的元素" class="headerlink" title="遍历 vector 中的元素"></a>遍历 vector 中的元素</h3><p>如果想要依次访问 vector 中的每一个元素，我们可以遍历其所有的元素而无需通过索引一次一个的访问。示例 8-8 展示了如何使用 <code>for</code> 循环来获取 <code>i32</code> 值的 vector 中的每一个元素的不可变引用并将其打印：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>示例 8-8：通过 <code>for</code> 循环遍历 vector 的元素并打印</p><p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们。示例 8-9 中的 <code>for</code> 循环会给每一个元素加 <code>50</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>    *i += <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例8-9：遍历 vector 中元素的可变引用</p><p>为了修改可变引用所指向的值，在使用 <code>+=</code> 运算符之前必须使用解引用运算符（<code>*</code>）获取 <code>i</code> 中的值。第十五章会详细介绍 <code>*</code>。</p><h3 id="使用枚举来储存多种类型"><a href="#使用枚举来储存多种类型" class="headerlink" title="使用枚举来储存多种类型"></a>使用枚举来储存多种类型</h3><p>在本章的开始，我们提到 vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！</p><p>例如，假如我们想要从电子表格的一行中获取值，而这一行的有些列包含数字，有些包含浮点值，还有些是字符串。我们可以定义一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型，那个枚举的类型。接着可以创建一个储存枚举值的  vector，这样最终就能够储存不同类型的值了。示例 8-10 展示了其用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SpreadsheetCell</span></span> &#123;<br>    Int(<span class="hljs-built_in">i32</span>),<br>    Float(<span class="hljs-built_in">f64</span>),<br>    Text(<span class="hljs-built_in">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> row = <span class="hljs-built_in">vec!</span>[<br>    SpreadsheetCell::Int(<span class="hljs-number">3</span>),<br>    SpreadsheetCell::Text(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;blue&quot;</span>)),<br>    SpreadsheetCell::Float(<span class="hljs-number">10.12</span>),<br>];<br></code></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="新建String"><a href="#新建String" class="headerlink" title="新建String"></a>新建String</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();<br></code></pre></td></tr></table></figure><p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面值也实现了它。示例 8-12 展示了两个例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;initial contents&quot;</span>;<br><br><span class="hljs-keyword">let</span> s = data.to_string();<br><br><span class="hljs-comment">// 该方法也可直接用于字符串字面值：</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;initial contents&quot;</span>.to_string();<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;initial contents&quot;</span>);<br></code></pre></td></tr></table></figure><p>实际上，from方法和to_string方法并没有本质区别</p><h3 id="更新String"><a href="#更新String" class="headerlink" title="更新String"></a>更新String</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;foo&quot;</span>);<br>s.push_str(<span class="hljs-string">&quot;bar&quot;</span>);<br></code></pre></td></tr></table></figure><p>示例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 附加字符串 slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;bar&quot;</span>;<br>s1.push_str(s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s2 is &#123;&#125;&quot;</span>, s2);<br></code></pre></td></tr></table></figure><p>示例 8-16：将字符串 slice 的内容附加到 <code>String</code> 后使用它</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;lo&quot;</span>);<br>s.push(<span class="hljs-string">&#x27;l&#x27;</span>);<br></code></pre></td></tr></table></figure><p>示例 8-17：使用 <code>push</code> 将一个字符加入 <code>String</code> 值中</p><p>使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</p><p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符，如示例 8-18 所示。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Hello, &quot;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;world!&quot;</span>);<br><span class="hljs-keyword">let</span> s3 = s1 + &amp;s2; <span class="hljs-comment">// 注意 s1 被移动了，不能继续使用</span><br></code></pre></td></tr></table></figure><p>示例 8-18：使用 <code>+</code> 运算符将两个 <code>String</code> 值合并到一个新的 <code>String</code> 值中</p><p>如果想要级联多个字符串，<code>+</code> 的行为就显得笨重了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tic&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tac&quot;</span>);<br><span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;toe&quot;</span>);<br><br><span class="hljs-keyword">let</span> s = s1 + <span class="hljs-string">&quot;-&quot;</span> + &amp;s2 + <span class="hljs-string">&quot;-&quot;</span> + &amp;s3;<br></code></pre></td></tr></table></figure><p>这时 <code>s</code> 的内容会是 “tic-tac-toe”。在有这么多 <code>+</code> 和 <code>&quot;</code> 字符的情况下，很难理解具体发生了什么。对于更为复杂的字符串链接，可以使用 <code>format!</code> 宏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tic&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;tac&quot;</span>);<br><span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;toe&quot;</span>);<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);<br></code></pre></td></tr></table></figure><h3 id="索引字符串"><a href="#索引字符串" class="headerlink" title="索引字符串"></a>索引字符串</h3><p>在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。然而在 Rust 中，如果你尝试使用索引语法访问 <code>String</code> 的一部分，会出现一个错误。考虑一下如示例 8-19 中所示的无效代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::<span class="hljs-keyword">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> h = s1[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>示例 8-19：尝试对字符串使用索引语法</p><p>会导致如下错误：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>error[E0277]: the trait bound `<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::<span class="hljs-keyword">String</span>: <span class="hljs-built_in">std</span>::ops::Index&lt;&#123;integer&#125;&gt;` is <span class="hljs-keyword">not</span> satisfied<br> --&gt;<br>  |<br><span class="hljs-number">3</span> |     let h = s1[<span class="hljs-number">0</span>];<br>  |             ^^^^^ the type `<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::<span class="hljs-keyword">String</span>` cannot be indexed by `&#123;integer&#125;`<br>  |<br>  = help: the trait `<span class="hljs-built_in">std</span>::ops::Index&lt;&#123;integer&#125;&gt;` is <span class="hljs-keyword">not</span> implemented <span class="hljs-keyword">for</span> `<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::<span class="hljs-keyword">String</span>`<br></code></pre></td></tr></table></figure><p>错误和提示说明了全部问题：Rust 的字符串不支持索引。</p><p>字节、标量值和字形簇！天呐！</p><p>这引起了关于 UTF-8 的另外一个问题：从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 <strong>字母</strong> 的概念）。</p><p>比如这个用梵文书写的印度语单词 “नमस्ते”，最终它储存在 vector 中的 <code>u8</code> 值看起来像这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><br>[<span class="hljs-number">224</span>, <span class="hljs-number">164</span>, <span class="hljs-number">168</span>, <span class="hljs-number">224</span>, <span class="hljs-number">164</span>, <span class="hljs-number">174</span>, <span class="hljs-number">224</span>, <span class="hljs-number">164</span>, <span class="hljs-number">184</span>, <span class="hljs-number">224</span>, <span class="hljs-number">165</span>, <span class="hljs-number">141</span>, <span class="hljs-number">224</span>, <span class="hljs-number">164</span>, <span class="hljs-number">164</span>,<br><span class="hljs-number">224</span>, <span class="hljs-number">165</span>, <span class="hljs-number">135</span>]<br></code></pre></td></tr></table></figure><p>这里有 18 个字节，也就是计算机最终会储存的数据。如果从 Unicode 标量值的角度理解它们，也就像 Rust 的 <code>char</code> 类型那样，这些字节看起来像这样：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><br>[<span class="hljs-symbol">&#x27;न</span>&#x27;, <span class="hljs-symbol">&#x27;म</span>&#x27;, <span class="hljs-symbol">&#x27;स</span>&#x27;, <span class="hljs-symbol">&#x27;्</span>&#x27;, <span class="hljs-symbol">&#x27;त</span>&#x27;, <span class="hljs-symbol">&#x27;े</span>&#x27;]<br></code></pre></td></tr></table></figure><p>这里有六个 <code>char</code>，不过第四个和第六个都不是字母，它们是发音符号本身并没有任何意义。最后，如果以字形簇的角度理解，就会得到人们所说的构成这个单词的四个字母：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><br>[<span class="hljs-string">&quot;न&quot;</span>, <span class="hljs-string">&quot;म&quot;</span>, <span class="hljs-string">&quot;स्&quot;</span>, <span class="hljs-string">&quot;ते&quot;</span>]<br></code></pre></td></tr></table></figure><p>字符串 slice</p><p>索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串  slice。因此，如果你真的希望使用索引创建字符串 slice 时 Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串  slice，相比使用 <code>[]</code> 和单个值的索引，可以使用 <code>[]</code> 和一个 range 来创建含特定字节的字符串 slice：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix"><br><span class="hljs-keyword">let</span> <span class="hljs-attr">hello</span> = <span class="hljs-string">&quot;Здравствуйте&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">s</span> = &amp;hello[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p><p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：在运行时会 panic，就跟访问 vector 中的无效索引时一样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><br>thread <span class="hljs-symbol">&#x27;main</span>&#x27; panicked <span class="hljs-keyword">at</span> <span class="hljs-symbol">&#x27;byte</span> index <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a char boundary; it <span class="hljs-keyword">is</span> inside <span class="hljs-string">&#x27;З&#x27;</span> (bytes <span class="hljs-number">0</span>..<span class="hljs-number">2</span>) <span class="hljs-keyword">of</span> `Здравствуйте`&#x27;, src/libcore/str/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">2188</span>:<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>你应该小心谨慎的使用这个操作，因为这么做可能会使你的程序崩溃。</p><h3 id="遍历字符串的方法"><a href="#遍历字符串的方法" class="headerlink" title="遍历字符串的方法"></a>遍历字符串的方法</h3><p>幸运的是，这里还有其他获取字符串元素的方式。</p><p>如果你需要操作单独的 Unicode 标量值，最好的选择是使用 <code>chars</code> 方法。对 “नमस्ते” 调用 <code>chars</code> 方法会将其分开并返回六个 <code>char</code> 类型的值，接着就可以遍历其结果来访问每一个元素了：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><br>for <span class="hljs-keyword">c</span> in <span class="hljs-string">&quot;नमस्ते&quot;</span>.chars() &#123;<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这些代码会打印出如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>न<br>म<br>स<br>्<br>त<br>े<br></code></pre></td></tr></table></figure><p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>for <span class="hljs-keyword">b </span>in <span class="hljs-string">&quot;नमस्ते&quot;</span>.<span class="hljs-keyword">bytes() </span>&#123;<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">b);</span><br><span class="hljs-keyword">&#125;</span><br></code></pre></td></tr></table></figure><p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-number">224</span><br><span class="hljs-number">164</span><br><span class="hljs-regexp">//</span> --snip--<br><span class="hljs-number">165</span><br><span class="hljs-number">135</span><br></code></pre></td></tr></table></figure><p>不过请记住有效的 Unicode 标量值可能会由不止一个字节组成。</p><p>从字符串中获取字形簇是很复杂的，所以标准库并没有提供这个功能。<a href="https://crates.io/">crates.io</a> 上有些提供这样功能的 crate。</p><h2 id="Hash-map"><a href="#Hash-map" class="headerlink" title="Hash map"></a>Hash map</h2><h3 id="新建Hash"><a href="#新建Hash" class="headerlink" title="新建Hash"></a>新建Hash</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br><br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure><p>新建哈希 map 并插入一些键值对</p><p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> teams  = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Yellow&quot;</span>)];<br><span class="hljs-keyword">let</span> initial_scores = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">50</span>];<br><br><span class="hljs-keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();<br></code></pre></td></tr></table></figure><p>这里 <code>HashMap&lt;_, _&gt;</code> 类型注解是必要的，因为可能 <code>collect</code> 很多不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p><h3 id="哈希-map-和所有权"><a href="#哈希-map-和所有权" class="headerlink" title="哈希 map 和所有权"></a>哈希 map 和所有权</h3><p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> field_name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Favorite color&quot;</span>);<br><span class="hljs-keyword">let</span> field_value = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> map = HashMap::new();<br>map.insert(field_name, field_value);<br><span class="hljs-comment">// 这里 field_name 和 field_value 不再有效，</span><br></code></pre></td></tr></table></figure><h3 id="访问哈希-map-中的值"><a href="#访问哈希-map-中的值" class="headerlink" title="访问哈希 map 中的值"></a>访问哈希 map 中的值</h3><p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br><br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">let</span> team_name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>);<br><span class="hljs-keyword">let</span> score = scores.get(&amp;team_name);<br></code></pre></td></tr></table></figure><p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。</p><p>可以使用与 vector 类似的方式来遍历哈希 map 中的每一个键值对，也就是 <code>for</code> 循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br><br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新哈希-map"><a href="#更新哈希-map" class="headerlink" title="更新哈希 map"></a>更新哈希 map</h3><h4 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a>覆盖一个值</h4><p>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换。即便示例 8-24 中的代码调用了两次 <code>insert</code>，哈希 map 也只会包含一个键值对，因为两次都是对蓝队的键插入的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br><br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">25</span>);<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, scores);<br></code></pre></td></tr></table></figure><p>示例 8-24：替换以特定键储存的值</p><p>这会打印出 <code>&#123;&quot;Blue&quot;: 25&#125;</code>。原始的值 <code>10</code> 则被覆盖了。</p><h4 id="没有对应值时插入"><a href="#没有对应值时插入" class="headerlink" title="没有对应值时插入"></a>没有对应值时插入</h4><p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。比如说我们想要检查黄队的键是否关联了一个值。如果没有，就插入值 50，对于蓝队也是如此。使用 entry API 的代码看起来像示例 8-25 这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br><br>scores.entry(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Yellow&quot;</span>)).or_insert(<span class="hljs-number">50</span>);<br>scores.entry(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Blue&quot;</span>)).or_insert(<span class="hljs-number">50</span>);<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, scores);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Programming Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust-Learning-1</title>
    <link href="/2019/04/05/2021/Rust-Learning-1/"/>
    <url>/2019/04/05/2021/Rust-Learning-1/</url>
    
    <content type="html"><![CDATA[<p>Rust学习篇，介绍Rust的基础知识。</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量默认是不可改变的（immutable）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>可变：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>不允许对常量使用 <code>mut</code>。常量不光默认不能变，它总是不能变。声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> MAX_POINTS: <span class="hljs-built_in">u32</span> = <span class="hljs-number">100_000</span>;<br></code></pre></td></tr></table></figure><p>新变量会 <strong>隐藏</strong> 之前的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> x = x + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> x = x * <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。你可能在其他语言中见过它们。让我们深入了解它们在 Rust 中是如何工作的。</p><p>整型</p><p><strong>整数</strong> 是一个没有小数部分的数字。我们在第二章使用过 <code>u32</code> 整数类型。该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 <code>i</code> 开头而不是 <code>u</code>）。</p><p>Rust 中的整型</p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>Rust 中的整型字面值</p><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal</td><td><code>98_222</code></td></tr><tr><td>Hex</td><td><code>0xff</code></td></tr><tr><td>Octal</td><td><code>0o77</code></td></tr><tr><td>Binary</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (<code>u8</code> only)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>Rust 也有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>。默认类型是 <code>f64</code>。</p><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><p>正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。Rust 中的布尔类型使用 <code>bool</code> 表示。</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>目前为止只使用到了数字，不过 Rust 也支持字母。Rust 的 <code>char</code> 类型是语言中最原生的字母类型，如下代码展示了如何使用它。（注意 <code>char</code> 由单引号指定，不同于字符串使用双引号。）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-string">&#x27;z&#x27;</span>;<br>    <span class="hljs-keyword">let</span> z = <span class="hljs-string">&#x27;ℤ&#x27;</span>;<br>    <span class="hljs-keyword">let</span> heart_eyed_cat = &#x27;😻&#x27;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> tup: (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f64</span>, <span class="hljs-built_in">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> tup = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> (x, y, z) = tup;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>访问元组元素使用<code>.</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x: (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f64</span>, <span class="hljs-built_in">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> five_hundred = x.<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> six_point_four = x.<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> one = x.<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>[type:number]用于表示数组的类型</p><p>访问方式同C，用中括号</p><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><code>String</code> 类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>可以</strong> 修改此类字符串 ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>s.push_str(<span class="hljs-string">&quot;, world!&quot;</span>); <span class="hljs-comment">// push_str() 在字符串后追加字面值</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s); <span class="hljs-comment">// 将打印 `hello, world!`</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>fn</code> 关键字，它用来声明新函数</p><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    another_function(<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">another_function</span></span>(x: <span class="hljs-built_in">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">let</span> y = &#123;<br>        <span class="hljs-keyword">let</span> x = <span class="hljs-number">3</span>;<br>        x + <span class="hljs-number">1</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>分号视作是语句的结束，如果没有分号结尾，我们默认认为最后的语句用于作为返回值。</p><p>函数如果有返回值的话我们需要使用<code>-&gt;</code>用于表示返回值类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">five</span></span>() -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x = five();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> number = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was true&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was false&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> condition = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> number = <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-number">5</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-number">6</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是如果使用下面的赋值分支，我们每个分支内部的返回值类型都需要设置为同一类型。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;again!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>loop用于执行<strong>死循环</strong>，可以用break跳出循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">loop</span> &#123;<br>        counter += <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>break的用法不同与我们的C，有返回值</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">while</span> number != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>, number);<br><br>        number = number - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;LIFTOFF!!!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];<br><br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> a.iter() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the value is: &#123;&#125;&quot;</span>, element);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">4</span>).rev() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>, number);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;LIFTOFF!!!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><p>作为Rust独有的新概念</p><blockquote><ol><li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li><li>值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol></blockquote><h2 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a><strong>作用域</strong>（<em>scope</em>）</h2><p>这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;                      <span class="hljs-comment">// s 在这里无效, 它尚未声明</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">// 从此处起，s 是有效的</span><br><br>    <span class="hljs-comment">// 使用 s</span><br>&#125;                      <span class="hljs-comment">// 此作用域已结束，s 不再有效</span><br></code></pre></td></tr></table></figure><h3 id="变量与数据交互"><a href="#变量与数据交互" class="headerlink" title="变量与数据交互"></a>变量与数据交互</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = s1;<br></code></pre></td></tr></table></figure><p>此时s1失效，不再有用</p><p>我们称作s1被移到s2中</p><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> s2 = s1.clone();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);<br></code></pre></td></tr></table></figure><p>此时s1和s2都是有效的</p><h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> y = x;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><p>没有调用 <code>clone</code>，不过 <code>x</code> 依然有效且没有被移动到 <code>y</code> 中</p><p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章详细讲解 trait）。如果一个类型拥有 <code>Copy</code> trait，一个旧的变量在将其赋值给其他变量后仍然可用。</p><p>如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s 进入作用域</span><br><br>    takes_ownership(s);             <span class="hljs-comment">// s 的值移动到函数里 ...</span><br>                                    <span class="hljs-comment">// ... 所以到这里不再有效</span><br><br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x 进入作用域</span><br><br>    makes_copy(x);                  <span class="hljs-comment">// x 应该移动函数里，</span><br>                                    <span class="hljs-comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span><br><br>&#125; <span class="hljs-comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br>  <span class="hljs-comment">// 所以不会有特殊操作</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_ownership</span></span>(some_string: <span class="hljs-built_in">String</span>) &#123; <span class="hljs-comment">// some_string 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">makes_copy</span></span>(some_integer: <span class="hljs-built_in">i32</span>) &#123; <span class="hljs-comment">// some_integer 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// 这里，some_integer 移出作用域。不会有特殊操作</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = gives_ownership();         <span class="hljs-comment">// gives_ownership 将返回值</span><br>                                        <span class="hljs-comment">// 移给 s1</span><br><br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 进入作用域</span><br><br>    <span class="hljs-keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="hljs-comment">// s2 被移动到</span><br>                                        <span class="hljs-comment">// takes_and_gives_back 中, </span><br>                                        <span class="hljs-comment">// 它也将返回值移给 s3</span><br>&#125; <span class="hljs-comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br>  <span class="hljs-comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gives_ownership</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;             <span class="hljs-comment">// gives_ownership 将返回值移动给</span><br>                                             <span class="hljs-comment">// 调用它的函数</span><br><br>    <span class="hljs-keyword">let</span> some_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// some_string 进入作用域.</span><br><br>    some_string                              <span class="hljs-comment">// 返回 some_string 并移出给调用的函数</span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_and_gives_back</span></span>(a_string: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> &#123; <span class="hljs-comment">// a_string 进入作用域</span><br><br>    a_string  <span class="hljs-comment">// 返回 a_string 并移出给调用的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</strong></p><p>在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。我们可以使用元组来返回多个值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> (s2, len) = calculate_length(s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_length</span></span>(s: <span class="hljs-built_in">String</span>) -&gt; (<span class="hljs-built_in">String</span>, <span class="hljs-built_in">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> length = s.len(); <span class="hljs-comment">// len() 返回字符串的长度</span><br><br>    (s, length)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用和借用"><a href="#引用和借用" class="headerlink" title="引用和借用"></a>引用和借用</h2><h4 id="一般引用"><a href="#一般引用" class="headerlink" title="一般引用"></a>一般引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> len = calculate_length(&amp;s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_length</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    s.len()<br>&#125;<br></code></pre></td></tr></table></figure><p>注意我们传递 <code>&amp;s1</code> 给 <code>calculate_length</code>，同时在函数定义中，我们获取 <code>&amp;String</code> 而不是 <code>String</code>。</p><p>这些 &amp; 符号就是 <strong>引用</strong>，它们允许你使用值但不获取其所有权。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_length</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> &#123; <span class="hljs-comment">// s 是对 String 的引用</span><br>    s.len()<br>&#125; <span class="hljs-comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span><br>  <span class="hljs-comment">// 所以什么也不会发生</span><br></code></pre></td></tr></table></figure><p>我们将获取引用作为函数参数称为 <strong>借用</strong>（<em>borrowing</em>）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。<strong>我们尝试修改借用的变量是不可能的。</strong></p><h4 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    change(&amp;<span class="hljs-keyword">mut</span> s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">change</span></span>(some_string: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>) &#123;<br>    some_string.push_str(<span class="hljs-string">&quot;, world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用。</p><p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><p>一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> s;<br><span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;<span class="hljs-comment">//ERROR</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2); <br></code></pre></td></tr></table></figure><p>类似的规则也存在于同时使用可变与不可变引用中。我们<strong>不能同时有可变和不可变的引用</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> r1 = &amp;s; <span class="hljs-comment">// no problem</span><br><span class="hljs-keyword">let</span> r2 = &amp;s; <span class="hljs-comment">// no problem</span><br><span class="hljs-keyword">let</span> r3 = &amp;<span class="hljs-keyword">mut</span> s; <span class="hljs-comment">// BIG PROBLEM</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br></code></pre></td></tr></table></figure><h2 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h2><p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 <strong>悬垂指针</strong>（<em>dangling pointer</em>），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> reference_to_nothing = dangle();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dangle</span></span>() -&gt; &amp;<span class="hljs-built_in">String</span> &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    &amp;s<br>&#125;<br></code></pre></td></tr></table></figure><p>错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。</p><p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！Rust 不会允许我们这么做。</p><p>这里的解决方法是直接返回 <code>String</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">no_dangle</span></span>() -&gt; <span class="hljs-built_in">String</span> &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    s<br>&#125;<br></code></pre></td></tr></table></figure><p>引用的规则</p><p>让我们概括一下之前对引用的讨论：</p><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效。</li></ul><h2 id="Slice类型"><a href="#Slice类型" class="headerlink" title="Slice类型"></a>Slice类型</h2><p><strong>字符串 slice</strong>（<em>string slice</em>）是 <code>String</code> 中一部分值的引用，它看起来像这样：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><br><span class="hljs-keyword">let</span> <span class="hljs-attr">s</span> = String::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">hello</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">world</span> = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];<br></code></pre></td></tr></table></figure><p>这类似于引用整个 <code>String</code> 不过带有额外的 <code>[0..5]</code> 部分。它不是对整个 <code>String</code> 的引用，而是对部分 <code>String</code> 的引用。<code>start..end</code> 语法代表一个以 <code>start</code> 开头并一直持续到但不包含 <code>end</code> 的 range。如果需要包含 <code>end</code>，可以使用 <code>..=</code> 而不是 <code>..</code>：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><br><span class="hljs-keyword">let</span> <span class="hljs-attr">s</span> = String::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">hello</span> = &amp;s[<span class="hljs-number">0</span>..=<span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">world</span> = &amp;s[<span class="hljs-number">6</span>..=<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>一个真正获取 <strong>部分</strong> 字符串的办法。不过，我们可以返回单词结尾的索引。</p><p>如果想要从第一个索引（0）开始，可以不写两个点号之前的值</p><p>如果 slice 包含 <code>String</code> 的最后一个字节，也可以舍弃尾部的数字</p><p>在记住所有这些知识后，让我们重写 <code>first_word</code> 来返回一个 slice。“字符串 slice” 的类型声明写作 <code>&amp;str</code>：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>    <span class="hljs-keyword">let</span> bytes = s.as_bytes();<br><br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">0</span>..i];<br>        &#125;<br>    &#125;<br><br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;s);<br><br>    s.clear(); <span class="hljs-comment">// error!</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> my_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-comment">// first_word 中传入 `String` 的 slice</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string[..]);<br><br>    <span class="hljs-keyword">let</span> my_string_literal = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>    <span class="hljs-comment">// first_word 中传入字符串字面值的 slice</span><br>    <span class="hljs-keyword">let</span> word = first_word(&amp;my_string_literal[..]);<br><br>    <span class="hljs-comment">// 因为字符串字面值 **就是** 字符串 slice，</span><br>    <span class="hljs-comment">// 这样写也可以，即不使用 slice 语法！</span><br>    <span class="hljs-keyword">let</span> word = first_word(my_string_literal);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> slice = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>这个 slice 的类型是 <code>&amp;[i32]</code>。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Programming Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux入门资源</title>
    <link href="/2019/04/02/2021/Linux-%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90/"/>
    <url>/2019/04/02/2021/Linux-%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[  <span id="more"></span><h1 id="命令行？入门教程视频"><a href="#命令行？入门教程视频" class="headerlink" title="命令行？入门教程视频"></a>命令行？入门教程视频</h1><p><a href="https://ftp.ustclug.org/course/">USTC-Linux教程</a></p><h1 id="命令查询"><a href="#命令查询" class="headerlink" title="命令查询"></a>命令查询</h1><p><a href="man.linuxde.net">命令查询网站</a></p><p><a href="http://www.runoob.com/linux/linux-shell.html">Shell脚本教程</a></p><h1 id="鸟哥PDF下载"><a href="#鸟哥PDF下载" class="headerlink" title="鸟哥PDF下载"></a>鸟哥PDF下载</h1><p><a href="/Download/LinuxBasic.pdf">Linux-Basic</a></p><p><a href="/Download/LinuxWeb.pdf">Linux-web</a></p><p>个人觉得为了快速达到使用目的</p><p>还是实践一下来得快～</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu设置默认打开方式</title>
    <link href="/2019/03/26/2021/Ubuntu%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/03/26/2021/Ubuntu%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu使用技巧，认定默认打开方式。</p> <span id="more"></span><p>Ubuntu保存文件类型打开方式主要又两个配置文件决定：</p><ol><li><p>/etc/gnome/defaults.list 保存了全局的打开方式</p></li><li><p>/.local/share/applications/mimeapps.list 保存了个人的打开方式（局部个人设置）</p><p>也有版本是/.local/share/applications/defaults.list</p></li></ol><p>一般情况下都推荐如下操作：</p><ul><li>拷贝.desktop至/.local/share/applications</li><li>添加默认设置内容</li></ul><p>默认设置内容编写是这样的： 类型=软件</p><p>类型参见右击文件Properties中的Type中的括号中内容，软件为XXX.desktop（之前的博客中有介绍如何创建desktop）</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Create shortcut in Ubuntu</title>
    <link href="/2019/03/26/2021/Create-shortcut-in-Ubuntu/"/>
    <url>/2019/03/26/2021/Create-shortcut-in-Ubuntu/</url>
    
    <content type="html"><![CDATA[<p> 在Linux下创建快捷方式的小技巧。当然现在19.04版本之后，我们可以更简单的通过右击目标文件，点击创建连接就可以创建一个新的快捷方式了。</p><span id="more"></span><h1 id="Method-1-Copy-one"><a href="#Method-1-Copy-one" class="headerlink" title="Method 1: Copy one"></a>Method 1: Copy one</h1><p>Open <code>/usr/share/applications</code>. Look for the program you want to create the shortcut.</p><p>Copy it.</p><h1 id="Method-2-Create-desktop-file"><a href="#Method-2-Create-desktop-file" class="headerlink" title="Method 2: Create .desktop file"></a>Method 2: Create .desktop file</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim  /usr/share/applications/eclipse.desktop<br></code></pre></td></tr></table></figure><p>And then input:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Desktop Entry] <br>Encoding=UTF-8 <br>Name=eclipse<br>Comment=Eclipse IDE  <br>Exec=/opt/eclipse/eclipse  # Where your program is<br>Icon=/opt/eclipse/icon.xpm  <br>Terminal=false<br>StartupNotify=true  <br>Type=Application  <br>Categories=Application;Development;<br></code></pre></td></tr></table></figure><p>And then we can copy </p><h1 id="Method-3-ln-s"><a href="#Method-3-ln-s" class="headerlink" title="Method 3 ln -s"></a>Method 3 ln -s</h1><p>run</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s <span class="hljs-string">&#x27;Origin program&#x27;</span> <span class="hljs-string">&#x27;Your Destination&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8086 Quick Start</title>
    <link href="/2019/03/19/2021/8086-Quick-Start/"/>
    <url>/2019/03/19/2021/8086-Quick-Start/</url>
    
    <content type="html"><![CDATA[<p>安装emu8086 并在该环境下写简单的汇编程序。一个快速上手的教程。旨在实用，旨在实用。</p><span id="more"></span><h1 id="Install-emu8086"><a href="#Install-emu8086" class="headerlink" title="Install emu8086"></a>Install emu8086</h1><p>下载地址：<a href="http://staff.ustc.edu.cn/~llxx/cod/software/emu8086.zip">EMU8086 Download</a></p><p>安装自行解决～</p><p>官方教程：<a href="http://dsearls.org/courses/C391OrgSys/IntelAL/8086_instruction_set.html">8086set</a></p><h1 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul><li><strong>AX</strong> accumulator register (<strong>AH / AL</strong>)</li><li><strong>BX</strong> base address register （ <strong>BH / BL</strong>）.</li><li><strong>CX</strong> 计数寄存器 count register（分为 <strong>CH / CL</strong> ）.</li><li><strong>DX</strong> 数据寄存器 data register （分为 <strong>DH / DL</strong>）.</li><li><strong>SI</strong> 源变址寄存器 source index register.</li><li><strong>DI</strong> 目的变址寄存器 destination index register.</li><li><strong>BP</strong> 基址指针寄存器 base pointer.</li><li><strong>SP</strong> 堆栈寄存器 stack pointer.</li></ul><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><ul><li><strong>CS</strong> 代码段寄存器，用来存放当前正在运行的指令</li><li><strong>DS</strong> 数据段寄存器，用来存放当前运行程序所用的数据</li><li><strong>ES</strong> 附加段寄存器，由程序员决定用途</li><li><strong>SS</strong> 堆栈段寄存器，指出堆栈所在区域</li></ul><p>上面说了两类，接下来说寄存器使用：</p><ul><li><p>通用寄存器直接当做变量使用</p></li><li><p>段寄存器用于标志代码块</p></li></ul><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ASSUME CS:CODE,DS:DATA<br><br>DATA SEGMENT<br>        ...;标注变量<br>DATA ENDS<br><br>CODE SEGMENT<br>        ...;写代码的部分<br>CODE ENDS<br></code></pre></td></tr></table></figure><h1 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h1><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ASSUME CS:CODE,DS:DATA<br><br>DATA SEGMENT<br>        A DB 0<br>        B DB 100<br>DATA ENDS<br><br>...<br>MOV AL, A ;取变量<br>ADD AL, 1<br>MOV A, AL ;存变量<br>...<br></code></pre></td></tr></table></figure><p>这样我们可以存取变量并且完成赋值</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组简而言之，我们用一段连续的地址进行实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">DATA SEGMENT<br>        ARR DB 48h, 65h, 6Ch, 6Ch, 6Fh, 00h<br>        STRING DB &#39;Hello&#39;, 0<br>        REPEAT DB 5 DUP(9)<br>DATA ENDS<br></code></pre></td></tr></table></figure><p>这几种都是合法的数组定义初始化方法，A是一一赋值；B是字符串定义，需要注意一下我们有结尾0；C是重复定义，含义为5个9</p><p>对于数组取值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AL, ARR[3]  ;下标取值，注意，下标从0开始标记<br><br>MOV SI, 3<br>MOV AL, ARR[SI]<br></code></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>既然有了数组，为实现某些简单操作，我们也自然希望有指针这种东西</p><p>有两种主要的实现方式：</p><ul><li><p>LEA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AL, VAR1 ;AL &#x3D; VAR1<br>LEA BX, VAR1 ;BX &#x3D; &amp;VAR1<br>MOV BYTE PTR [BX], 44H ;*BX &#x3D; 44H<br></code></pre></td></tr></table></figure><p>注意一下<code>BYTE PTR</code>的必要性，表示按字节读数据，不能少</p></li><li><p>OFFSET</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AL, VAR1 ;AL &#x3D; VAR1<br>MOV BX, OFFSET VAR1 ;BX &#x3D; &amp;VAR1<br>MOV BYTE PTR [BX], 44H ;*BX &#x3D; 44H<br></code></pre></td></tr></table></figure></li></ul><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>基本定义完成之后我们进入下一步：if语句的实现</p><p>8086中比较僵硬，实现是两句配套使用</p><p>第一句是固定的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CMP OP1,OP2<br></code></pre></td></tr></table></figure><p>结果是寄存在寄存器之中的Flag的CF、ZF、OF、AF、PF这几个标志位，具体是：</p><ul><li>ZF=1，表示两个操作数相等</li><li>假如把操作数看成无符号数：     <ul><li>CF=1，有进位或借位，cmp是减操作，故可看做是借位，即说明<code>op1&lt;op2</code></li><li>CF=0，无借位，需判断ZF是否为0，若为0，说明op1和op2不相等，即<code>op1&gt;op2</code></li></ul></li><li>假如把操作数看成有符号数：     <ul><li>若SF=0，OF=0，说明此时值为正数，无溢出，直观的看出<code>op1&gt;op2</code></li><li>若SF=1，OF=0，说明此时值为负数，无溢出，直观的看出<code>op1&lt;op2</code></li><li>若SF=0，OF=1，说明此时值为正数，有溢出，即<code>op1&lt;op2</code></li><li>若SF=1，OF=1，说明此时值为负数，有溢出，即<code>op1&gt;op2</code></li></ul></li></ul><p>为什吗会说溢出是因为cmp比较实质失去计算OP1-OP2再将它和0进行比较得到</p><p>第二句为判定条件+跳转标签：</p><p><img src="http://www.xumenger.com/media/image/2018-02-05/02.png" alt="判定语句"></p><p>有了分支跳转，自然就有了循环操作，因为判定跳转标签就可以实现循环。</p><h1 id="函数（子程序）"><a href="#函数（子程序）" class="headerlink" title="函数（子程序）"></a>函数（子程序）</h1><p>关于子程序的使用，不同于C/C++等高级语言，我们必须将即将使用的寄存器进行保存。</p><p>直接上例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SUB PROC NEAR ;beginning of SUB<br>    PUSH AL    ;保护寄存器<br>    PUSH BL<br>    ...<br>    POP BL<br>    POP AL ;还原寄存器<br>SUB ENDP      ;ending of SUB<br></code></pre></td></tr></table></figure><p>我们这样可以简单的实现子程序的编写</p><p>当然也有另外一种保护寄存器的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SUB PROC NEAR ;beginning of SUB<br>    MOV STAL,AL    ;保护寄存器<br>    MOV STBL,BL<br>    ...<br>    MOV BL,STAL<br>    MOV AL,STBL ;还原寄存器<br>SUB ENDP      ;ending of SUB<br></code></pre></td></tr></table></figure><p>两种方法各有优劣，前者使用需要注意PUSH和POP的顺序，因为我们是在往栈立存取数据，所以POP顺序和PUSH顺序需要倒置；后者使用便捷随意，但是局限性是不可以进行递归，即不能二次调用，除非手动用数组进行寄存变量；总之个人推荐第一种。</p><h1 id="系统中断"><a href="#系统中断" class="headerlink" title="系统中断"></a>系统中断</h1><p>有些特殊的操作只能以来系统中断进行完成，例如：PRINT等</p><p><a href="http://www.gabrielececchetti.it/Teaching/CalcolatoriElettronici/Docs/i8086_and_DOS_interrupts.pdf">INT中断表</a></p><p>常见的是输入、输出</p><p>但是这些我们在EMU8086.INC中有简便操作</p><p>源码是在<a href="https://github.com/AhmadNaserTurnkeySolutions/emu8086/blob/master/inc/emu8086.inc">EMU8086.INC源码</a>可以自由下载浏览</p><p>这样输入输出只要一句话就可以完成，下面给一个简单的例子，源自asm_tutorial：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; demonstrate scan_num, print_num, pthis<br>;----------------------------------------<br>include &#39;emu8086.inc&#39;<br>ORG    100h<br><br>LEA    SI, msg1       ; ask for the number<br>CALL   print_string   ;<br>CALL   scan_num       ; get number in CX.<br><br>MOV    AX, CX         ; copy the number to AX.<br><br>; print the following string:<br>CALL   pthis<br>DB  13, 10, &#39;You have entered: &#39;, 0<br><br>CALL   print_num      ; print number in AX.<br><br>RET                   ; return to operating system.<br><br>; data<br>msg1   DB  &#39;Enter the number: &#39;, 0<br><br>; macros to define procs<br>DEFINE_SCAN_NUM<br>DEFINE_PRINT_STRING<br>DEFINE_PRINT_NUM<br>DEFINE_PRINT_NUM_UNS  ; required for print_num.<br>DEFINE_PTHIS<br><br>END                   ; directive to stop the compiler.<br></code></pre></td></tr></table></figure><p>关于很多人好奇的计时，可以给一套模板供大家简便使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MARKTIME PROC NEAR<br>    MOV STAH,AH<br>    MOV STBH,BH<br>    MOV STCL,CL<br>    MOV STCH,CH<br>    MOV STDL,DL<br>    MOV AH,2CH<br>    INT 21H<br>    MOV STM,CL<br>    MOV STS,DH<br>    MOV STSS,DL<br>    MOV STH,CH <br>    MOV AH,STAH<br>    MOV CL,STCL<br>    MOV CH,STCH<br>    MOV DH,STDH<br>    MOV DL,STDL<br>    RET   <br>MARKTIME ENDP<br><br>PRINTTIME PROC NEAR<br>    MOV STAH,AH<br>    MOV STBH,BH<br>    MOV STCL,CL<br>    MOV STCH,CH<br>    MOV STDL,DL<br><br><br>    MOV AH,2CH<br>    INT 21H  <br>    SUB CH,STH <br>    SUB CL,STM<br>    SUB DH,STS <br>    SUB DL,STSS<br><br>    MOV AX,60<br>    MUL CH <br>    ADD AL,CL<br>    MOV CX,AX<br>    MOV AX,60<br>    MUL CL<br>    ADD AL,DH <br>    PRINT  &quot;TIME: &quot;<br>    CALL PRINT_NUM_UNS<br>    PUTC &#39;.&#39;<br>    MOV AX,0<br>    MOV AL,DL <br>    CALL PRINT_NUM_UNS<br>    PRINT &quot; S&quot;<br><br>    MOV AH,STAH<br>    MOV CL,STCL<br>    MOV CH,STCH<br>    MOV DH,STDH<br>    MOV DL,STDL   <br>    RET<br>PRINTTIME ENDP<br></code></pre></td></tr></table></figure><p>两者配套使用。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Assembly</tag>
      
      <tag>Programming Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用速成</title>
    <link href="/2019/03/17/2021/Git%E4%BD%BF%E7%94%A8%E9%80%9F%E6%88%90/"/>
    <url>/2019/03/17/2021/Git%E4%BD%BF%E7%94%A8%E9%80%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p> 简单的Git使用，速成教程。</p><span id="more"></span><h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>命令行下使用：<code>sudo apt-get install git </code>即可</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>先创建一个空目录：</p><p>在该目录下运行 <code>git init</code></p><h2 id="添加文件和上传"><a href="#添加文件和上传" class="headerlink" title="添加文件和上传"></a>添加文件和上传</h2><p>使用<code>git add file1.txt</code>可以上传文件</p><p>但是最后需要添加<code>git commit -m &quot;add 1 file.&quot;</code>才可以完成上传</p><p><code>git status</code>用于查看状态</p><p><code>git diff</code>用于对比差异</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p><code>git rm</code>可以用于删除文件</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><code>git log</code>用于查看所有版本的信息</p><p><code>git reset --hard HEAD^</code>用于退回上一个版本，<code>HEAD</code>代表当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD~x</code>之前x个版本</p><p><code>git reflog</code>用于调查历史命令</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code></p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000">版本回退</a>一节，不过前提是没有推送到远程库</p><h2 id="设置远程仓库"><a href="#设置远程仓库" class="headerlink" title="设置远程仓库"></a>设置远程仓库</h2><p>设置远程仓库<code>git remote add origin git@github.com:michaelliao/learngit.git</code></p><p><code>git push -u origin master</code>第一次提交</p><p>之后<code>git push origin master</code>即可</p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git branch dev<br><span class="hljs-variable">$ </span>git checkout dev<br>Switched to branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><p>这样就切换到了dev分支</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash-in-Linux</title>
    <link href="/2019/02/18/2021/Bash-in-Linux/"/>
    <url>/2019/02/18/2021/Bash-in-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>bash shell 是我们在linux中常用的一个shell程序，在这里我给大家简单介绍一下。本教程以实例为主。</p><span id="more"></span><h2 id="bash的hotkey"><a href="#bash的hotkey" class="headerlink" title="bash的hotkey"></a>bash的hotkey</h2><p>这里简单说几个bash里面神奇的小玩法：</p><ul><li>Up/Down：键盘的上/下键可以访问之前你输入过的命令，比如在重新编译某一个程序的时候，你就不要重新输入一遍命令，而是直接先按上再回车就OK啦</li><li>Tab：自动补全，Tab键可以推测你即将输入的内容，并且达到自动完成的功能，大大减少我们输入命令的时间</li><li>alias：别名设置，偷懒神器，例如事前我们用过的<code>ls -al</code>我们可以利用<code>alias showprivacy=&#39;ls -al&#39;</code>从而使得我们可以用<code>showprivacy</code>代替之前的命令</li><li>Wildcard：通配符，我们可以用例如<code>ls -l /usr/bin/X*</code>的方法得到所有以X开头的文件和目录</li><li><code>Ctrl+u</code> <code>Ctrl+k</code>：方便快速删除的神器，前者为删除光标之前的所有字符（不含光标处）。后者为删除光标以及光标之后的所有字符</li><li><code>Ctrl+a</code> <code>Ctrl+e</code>：相当于<code>home</code> 和<code>end</code></li><li><code>Ctrl+Shift+C</code> <code>Ctrl+Shift+V</code>：复制和粘贴，因为<code>Ctrl+C</code>用于中断程序</li></ul><h3 id="命令查询"><a href="#命令查询" class="headerlink" title="命令查询"></a>命令查询</h3><p><code>type [-tpa] name</code>命令用于确认name是否为一条bash命令，或者是alias别名的一条命令</p><ul><li>不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令</li><li>-t ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：<br>file ：表示为外部指令<br>alias ：表示该指令为命令别名所设置的名称<br>builtin ：表示该指令为 bash 内置的指令功能</li><li>-p ：如果后面接的 name 为外部指令时，才会显示完整文件名；</li><li>-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</li></ul><h2 id="echo与变量"><a href="#echo与变量" class="headerlink" title="echo与变量"></a>echo与变量</h2><p>Linux中除了别名，为了简单的设置一些路径名或文件名，我们会设置一些变量</p><p>例如 email=’xxx@qq.com’</p><p>但是下一次使用的时候就应该加上$,<code>$email</code>才表示你的变量的内容</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他常见的命令大家可以参考很多Ubuntu的教程，这里简单介绍了几条使用的快捷键和命名。真正用好bash shell还需要时间磨炼。</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开机流程</title>
    <link href="/2019/01/09/2021/%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B-1/"/>
    <url>/2019/01/09/2021/%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B-1/</url>
    
    <content type="html"><![CDATA[<p>分析计算机开机的流程，详解附代码。</p> <span id="more"></span><h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0 环境"></a>0 环境</h2><p>不同的计算机开机的流程是有微小差异的。显然的，大型并行的计算机和小型计算机开机的流程是不同的。同事，不同操作系统开机运行什么样的程序也是有区别的。这里我选择的是 <strong>Intel 80x86</strong> CPU操作模式，和 <strong>Linux 0.11</strong> 内核。</p><h2 id="1-BIOS启动"><a href="#1-BIOS启动" class="headerlink" title="1 BIOS启动"></a>1 BIOS启动</h2><p>计算机的运行离不开程序，加电的一瞬间，计算机内存（准确的说这里是指RAM）中最初是空的。CPU中的逻辑电路设计是执行我们内存中的程序的，而不是软盘中的程序。最初我们启动BIOS显然是不可能靠软件方法的，其实是靠硬件启动的。</p><h3 id="1-1-BIOS启动原理"><a href="#1-1-BIOS启动原理" class="headerlink" title="1.1 BIOS启动原理"></a>1.1 BIOS启动原理</h3><p>硬件角度看，<strong>Intel 80x86</strong> 系列CPU可以分别可以在<strong>16位实模式</strong>和<strong>32位保护模式</strong>下运行。为保证兼容，所有<strong>Intel 80x86</strong> 系列CPU设计都是加电直接进入<strong>16位实模式</strong>的。同时，CPU<strong>硬件逻辑</strong>设计为瞬间<strong>强行</strong>将CS的值置为0xF000,IP的值置为0xFFF0。这样CS：IP就指向了0xFFFF0的位置。我们硬件设计的时候也将BIOS的入口地址设置为0xFFFF0。</p><h3 id="1-2-BIOS启动"><a href="#1-2-BIOS启动" class="headerlink" title="1.2 BIOS启动"></a>1.2 BIOS启动</h3><p>BIOS的程序被固化在计算机主机板上一块较小的ROM的芯片中。通常，不同主机板的BIOS是不同的。就我们选取的BIOS为例 <strong>Intel 80x86</strong> CPU操作模式，和 <strong>Linux 0.11</strong> 内核的环境下，我们的BIOS程序也只有8K，所占的地址在<strong>0xFE000~0xFFFFF</strong>。BIOS程序运行的时候，显示器上会显示显卡、内存的各种信息，表示BIOS程序在依次检测显卡、内存等。其中有一项boot对于系统至关重要要——BIOS在内存中建立中断向量表和中断服务程序。BIOS会在内存开始的位置0x00000用1KB的内存(0x00000~0x003FF)构建中断向量表。</p><h2 id="2-加载程序"><a href="#2-加载程序" class="headerlink" title="2 加载程序"></a>2 加载程序</h2><h3 id="2-1-加载引导程序"><a href="#2-1-加载引导程序" class="headerlink" title="2.1 加载引导程序"></a>2.1 加载引导程序</h3><p>CPU通过收到BIOS传来的int0x19的中断向量，指向0x0E6F2，这里是int0x19指向的地址，BIOS程序从这里开始进行两项工作“找到硬/软盘”以及“加载第一扇区”。BIOS将0号磁头的对应盘里面的0磁道第一扇区的内容复制到0x07C00处，这里就是Linux0.11的引导程序。</p><h3 id="2-2-加载setup"><a href="#2-2-加载setup" class="headerlink" title="2.2 加载setup"></a>2.2 加载setup</h3><p>我们的引导程序bootsec导入内存之后，第一件重要的事情是规划内存。bootsect程序中有一段分别规定了BOOTSEG、INITSEG、SETUPSEG等常量，表示setup的扇区数、加载位置，启动扇区的位置等等。这样规划好之后，bootsect会将自己复制到0x07C000到0x90000处。这一段是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">entry start<br>start:<br>movax,#BOOTSEG<br>mov ds,ax<br>movax,#INITSEG<br>mov es,ax<br>mov cx,#256<br>subsi,si<br>sub di,di<br>rep<br>movw<br></code></pre></td></tr></table></figure><p>这里ds（0x07C0）和si（0x0000）联合使用起来，组成了原地址0x7C00。es和di联合构成0x90000，<code>mov cx</code>这里正好决定了大小</p><p>本次复制之后我们进行下一阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rep<br>movw<br>jmpi go,INITSEG<br>go:mov ax,cs<br>mov ds,ax<br></code></pre></td></tr></table></figure><p>这里我们执行跳转，CS变成0x9000，IP从0x9000转到go处。从现在起我们的操作系统完成了转移，不在完全依赖BIOS了，可以根据自己的意志进行移动。</p><p>由于bootsect复制的新的位置，之前修改了CS，现在轮到DS、ES、SS、和SP了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">go:movax,cs<br>mov ds,ax<br>moved,ax<br>! put stack at 0x9ff00<br>movss,ax<br>movsp,#0xFF00<br></code></pre></td></tr></table></figure><p>这里通过ax，用CS的值去修改其他寄存器的值。数据段寄存器、附加段寄存器、栈基址寄存器全部设置为代码段寄存器的位置（CS），并且将栈顶指针设置为偏移地址0xFF00的地方。这题我们可以开始加载setup程序了。</p><p>我们首先执行的是int0x13，但我们要先指定扇区加载的内存位置等信息，即传参：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">load_setup:<br>movdx,#0x0000<br>mov cx,#0x0002<br>mov bx,#0x0200<br>mov ax,#0x0200 + SUPERLEN<br>int 0x13<br>jnc ok_load_setup<br>mov dx,#0x0000<br>mov ax,#0x0000<br>int 0x13<br>j load_setup<br></code></pre></td></tr></table></figure><p>完成传参后执行int0x13。全部完成这些之后我们已经从软盘里面加载了5个扇区的代码。</p><h3 id="2-3-加载system模块"><a href="#2-3-加载system模块" class="headerlink" title="2.3 加载system模块"></a>2.3 加载system模块</h3><p>加载完setup之后我们还是用类似之前的方法再来加载第三部分的代码，反复调用int0x13。这部分代码较长，开机的时候我们会显示**”Loading system …”**的信息，我们会在这里加载240个扇区的信息。我们最后还会在bootsect中执行一个小任务：确认根设备号。</p><p>加载完成3个部分之后，我们bootsect功德圆满，然后我们回去执行下一步的setup程序。</p><p>跳转依赖bootsect中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmpi 0, SETUPSEG<br></code></pre></td></tr></table></figure><h3 id="2-4-提取机器系统数据"><a href="#2-4-提取机器系统数据" class="headerlink" title="2.4 提取机器系统数据"></a>2.4 提取机器系统数据</h3><p>setup程序开始的第一件事情就是利用BIOS中的中断服务提取内核运行所需要的机器系统数据，其中包括贯标位置，显示页面等数据。并且还在int0x41还有int0x46上硬盘参数表。将他们存放在其他位置。</p><p>位置在<code>boot/setup.s</code>里面的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movax,#INITSEG<br>movds,as<br>movah,#0x03<br>xor bh,bh<br>int0x10<br>mov[0],dx<br><br>!get memory size (extended memory,KB)<br>mov ah,#0x88<br>int 0x15<br>mov [2],ax<br>mov cx,#0x10<br>mov ax, #0x00<br>rep<br>stosb<br>...<br></code></pre></td></tr></table></figure><p>这些步骤之后我们完成的实际上是将Linux0.11<strong>从实模式转到了保护模式</strong>。</p><h2 id="3-转向32位模式，准备main函数"><a href="#3-转向32位模式，准备main函数" class="headerlink" title="3 转向32位模式，准备main函数"></a>3 转向32位模式，准备main函数</h2><h3 id="3-1-将system移动到内存起始地址为0x00000"><a href="#3-1-将system移动到内存起始地址为0x00000" class="headerlink" title="3.1 将system移动到内存起始地址为0x00000"></a>3.1 将system移动到内存起始地址为0x00000</h3><p>在这些之前我们先要关闭中断，防止以外情况，在setup.s中有一行<code>cli</code>关闭了中断。setup再将0x10000的内核复制到0x00000的位置。DS和ES配合完成内核移位的任务。这里其实是为我们下一步破旧立新做准备。</p><h3 id="3-2-设置中断"><a href="#3-2-设置中断" class="headerlink" title="3.2 设置中断"></a>3.2 设置中断</h3><p>我们这里会建立新的中断模式，通过setup程序自己提供的数据信息去完成初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs assembly">end_move:<br>movax,#SETUPSEG<br>mov ds,ax<br>lidt idt_48<br>lgdt gdt_48<br>...<br><br>gdt:<br>.word 0,0,0,0<br><br>.word 0x07FF<br>.word 0x0000<br>.word 0x9A00<br>.word 0x00C0<br><br>.word 0x07FF<br>.word 0x0000<br>.word 0x9200<br>.word 0x00C0<br><br>idt_48:<br>.word 0<br>.word 0,0<br><br>gdt_48:<br>.word 0x800<br>.word 512 + gdt,0x9<br>...<br></code></pre></td></tr></table></figure><h3 id="3-3-打开A20，实现32位寻址"><a href="#3-3-打开A20，实现32位寻址" class="headerlink" title="3.3 打开A20，实现32位寻址"></a>3.3 打开A20，实现32位寻址</h3><p>这里将我们的寻址模式进行改动，最大地址从0xFFFFF扩展到了0xFFFFFFFF。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call empty_8042<br>mov a1,#0xD1<br>out #0x64,al<br>call empty_8042<br>mov al,#0xDF  !A20 on<br>out #0x60,al<br>call empty_8042<br>..<br></code></pre></td></tr></table></figure><h3 id="3-4-准备head-s"><a href="#3-4-准备head-s" class="headerlink" title="3.4 准备head.s"></a>3.4 准备head.s</h3><p>setup对8259A进行重编程。这里有一点很难理解，在我们设置GDT之后有一句跳转语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmpi 0,8<br></code></pre></td></tr></table></figure><p>这里需要声明，8是保护模式的选择符，这样成就可以理解了。</p><h3 id="3-5-执行head-s"><a href="#3-5-执行head-s" class="headerlink" title="3.5 执行head.s"></a>3.5 执行head.s</h3><p>head.s中，我们完成了很多很多任务，例如将SS转32为的esp，对IDT重新设置和构建，调整DS、ES，检测数学协调处理器等等。之后我们将main函数的执行入口地址压给CS：EIP。这样我们可以开始运行main了。</p><h2 id="4-设置根设备和硬盘"><a href="#4-设置根设备和硬盘" class="headerlink" title="4 设置根设备和硬盘"></a>4 设置根设备和硬盘</h2><h3 id="4-1-进行规划"><a href="#4-1-进行规划" class="headerlink" title="4.1 进行规划"></a>4.1 进行规划</h3><p>我们开始使用32字的机器的时候设置了drive_info实在<code>init/main.c</code>里面执行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DRIVE_INFO (*(struct drive_info *)0x90080)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_ROOT_DEV (*(struct short *)0x901FC)</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    ROOT_DEV = ORIG_ROOT_DEV;<br>    drive_info = DRIVE_INFO;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们会设置缓冲区、虚拟盘、主内存等各自的存储位置。</p><h3 id="4-2-设置虚拟盘空间并初始化"><a href="#4-2-设置虚拟盘空间并初始化" class="headerlink" title="4.2 设置虚拟盘空间并初始化"></a>4.2 设置虚拟盘空间并初始化</h3><h2 id="5-建立人机交互界面以及外设的中断服务挂载"><a href="#5-建立人机交互界面以及外设的中断服务挂载" class="headerlink" title="5 建立人机交互界面以及外设的中断服务挂载"></a>5 建立人机交互界面以及外设的中断服务挂载</h2><p>我们加载完操作系统并不完全算完成了开机，要真正的使用我们还要加载外设。Linux中的ttyinit函数就是为了完成字符设备的初始化工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tty</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    rs_init ();<br>    con_init ();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中我们对串口进行设置的代码是rs_init()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>rs_init (<span class="hljs-keyword">void</span>)<br>&#123;<br>set_intr_gate (<span class="hljs-number">0x24</span>, rs1_interrupt);<br>set_intr_gate (<span class="hljs-number">0x23</span>, rs2_interrupt);<br>init (tty_table[<span class="hljs-number">1</span>].read_q.data);<br>init (tty_table[<span class="hljs-number">2</span>].read_q.data);<br>outb (inb_p (<span class="hljs-number">0x21</span>) &amp; <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x21</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们依次完成显示器、键盘等设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_X (*(unsigned char *)0x90000)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_Y (*(unsigned char *)0x90001)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_VIDEO_PAGE (*(unsigned short *)0x90004)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_VIDEO_MODE ((*(unsigned short *)0x90006) &amp; 0xff)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_VIDEO_COLS (((*(unsigned short *)0x90006) &amp; 0xff00) &gt;&gt; 8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_VIDEO_LINES (25)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_VIDEO_EGA_AX (*(unsigned short *)0x90008)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_VIDEO_EGA_BX (*(unsigned short *)0x9000a)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORIG_VIDEO_EGA_CX (*(unsigned short *)0x9000c)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_TYPE_MDA 0x10 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_TYPE_CGA 0x11 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_TYPE_EGAM 0x20 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_TYPE_EGAC 0x21 </span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NPAR 16</span><br>...<br><span class="hljs-keyword">void</span><br>con_init (<span class="hljs-keyword">void</span>)<br>&#123;<br><span class="hljs-keyword">register</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a;<br><span class="hljs-keyword">char</span> *display_desc = <span class="hljs-string">&quot;????&quot;</span>;<br><span class="hljs-keyword">char</span> *display_ptr;<br><br>video_num_columns = ORIG_VIDEO_COLS;<br>video_size_row = video_num_columns * <span class="hljs-number">2</span>;<br>video_num_lines = ORIG_VIDEO_LINES;<br>video_page = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)ORIG_VIDEO_PAGE;<br>video_erase_char = <span class="hljs-number">0x0720</span>;<br><br><span class="hljs-keyword">if</span> (ORIG_VIDEO_MODE == <span class="hljs-number">7</span>)<br>&#123;<br>video_mem_start = <span class="hljs-number">0xb0000</span>;<br>video_port_reg = <span class="hljs-number">0x3b4</span>;<br>video_port_val = <span class="hljs-number">0x3b5</span>;<br>        <br><span class="hljs-keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="hljs-number">0xff</span>) != <span class="hljs-number">0x10</span>)<br>&#123;<br>video_type = VIDEO_TYPE_EGAM;<br>video_mem_end = <span class="hljs-number">0xb8000</span>;<br>display_desc = <span class="hljs-string">&quot;EGAm&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>video_type = VIDEO_TYPE_MDA;<br>video_mem_end = <span class="hljs-number">0xb2000</span>;<br>display_desc = <span class="hljs-string">&quot;*MDA&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>video_mem_start = <span class="hljs-number">0xb8000</span>;<br>video_port_reg = <span class="hljs-number">0x3d4</span>;<br>video_port_val = <span class="hljs-number">0x3d5</span>;<br>        <br><span class="hljs-keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="hljs-number">0xff</span>) != <span class="hljs-number">0x10</span>)<br>&#123;<br>video_type = VIDEO_TYPE_EGAC;<br>video_mem_end = <span class="hljs-number">0xbc000</span>;<br>display_desc = <span class="hljs-string">&quot;EGAc&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>video_type = VIDEO_TYPE_CGA;<br>video_mem_end = <span class="hljs-number">0xba000</span>;<br>display_desc = <span class="hljs-string">&quot;*CGA&quot;</span>;<br>&#125;<br>&#125;<br><br>display_ptr = ((<span class="hljs-keyword">char</span> *) video_mem_start) + video_size_row - <span class="hljs-number">8</span>;<br><span class="hljs-keyword">while</span> (*display_desc)<br>&#123;<br>*display_ptr++ = *display_desc++;<br>display_ptr++;<br>&#125;<br><br>origin = video_mem_start;<br>scr_end = video_mem_start + video_num_lines * video_size_row;<br>top = <span class="hljs-number">0</span>;<br>bottom = video_num_lines;<br><br>gotoxy (ORIG_X, ORIG_Y);<br>set_trap_gate (<span class="hljs-number">0x21</span>, &amp;keyboard_interrupt);<br>outb_p ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(inb_p (<span class="hljs-number">0x21</span>) &amp; <span class="hljs-number">0xfd</span>), <span class="hljs-number">0x21</span>);<br>a = inb_p (<span class="hljs-number">0x61</span>);<br>outb_p ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)(a | <span class="hljs-number">0x80</span>), <span class="hljs-number">0x61</span>);<br>outb (a, <span class="hljs-number">0x61</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们还有一项任务就是激活<code>Process0</code>。此时才算真正完成了开机任务！</p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux的权限</title>
    <link href="/2019/01/02/2021/Linux%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
    <url>/2019/01/02/2021/Linux%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p> 简单介绍Ubuntu下的文件权限系统。</p> <span id="more"></span><h2 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h2><p>Linux中，使用文件的对象一般为三类，[u],[g],[o]。分别为user，group和others。网上的解释很多，但是这里我声明一下～最好理解的方式还是英文原意最合适：</p><ul><li>u - user who owns the file</li><li>g - the group to which the user belongs</li><li>o - others</li><li>a - (u+g+o) anyone</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>观察文件的权限可以使用命令： <code>ls -al</code></p><p><img src="https://s2.ax1x.com/2019/03/12/APxf78.png" alt="ls -al演示"></p><p>这里的第二列使我们关心的，即文件权限。</p><p>第一个字母代表文件类型：</p><ul><li>当为[ d ]则是目录</li><li>当为[ - ]则是文件</li><li>若是[ l ]则表示为链接文件</li><li>若是[ b ]则表示可随机存取设备</li><li>若是[ c ]则表示一次性读取设备</li></ul><p>之后每三个字母一组表示权限，从前往后分别为u、g、o的权限。</p><ul><li>r = 4           </li><li>w = 2           </li><li>x = 1           </li><li>- = 0           </li></ul><p>这个在chmod命令使用的时候会用到。</p><p>对于文件，含义是：</p><ul><li>r (read) : 可读</li><li>w (write) : 可写</li><li>x (excute) : 可以执行</li></ul><p>对于目录而言，含义略有不同：</p><ul><li><p>r : 可以读目录以及其中的文件</p></li><li><p>w : 对于目录而言，写的含义略微广一点，包含下面几条</p><p>​    创建新的文件与目录；<br>​    删已经存在的文件与目录（不论该文件的权限为何！）<br>​    将已存在的文件或目录进行更名；<br>​    搬移该目录内的文件、目录位置。</p></li><li><p>x : 因为对于一个目录而言，我们不存在什么是否可以执行的问题，这里代表该目录能否“打开”</p><p>即用<code>cd</code>命令能否打开</p></li></ul><h2 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h2><p>关于权限的修改问题，我们讨论下面三个命令：</p><ul><li>chown</li><li>chgrp</li><li>chmod</li></ul><p>其中chmod用的是最多，下面一一介绍。</p><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>同样，chgrp用于修改group。</p><p>格式为</p><p><code>chgrp [-r] new_group_name dir/file_name</code></p><p>其中<code>-r</code>开关表示是否对子目录和子文件内容进行修改。</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>chown顾名思义，是我们修改user的命令。</p><p>格式为</p><p><code>chown [-r] new_user_name1[:new_user_name2:...] dir/file_name </code></p><p>其中<code>-r</code>开关表示是否对子目录和子文件内容进行修改。</p><p>与上面不同的是一个文件可以有多个owner，因此我们可以用<code>：</code>进行分割。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>chmod对权限的具体内容进行了修改。</p><p>格式为</p><p><code>chmod [-r] xyz dir/file_name</code></p><p>xyz都是0~7的数字，就是将rwx-的字符根据之前给出的权值对应，给出我们希望的权限目标。</p><p>有一些简单的方式用于微调：</p><table><thead><tr><th>命令</th><th>对象</th><th>操作</th><th>操作内容</th><th>文件</th></tr></thead><tbody><tr><td>chomod</td><td>u/g/o/a</td><td>+/-/=</td><td>rwx-</td><td>w文件名</td></tr></tbody></table><p>直接给出几个具体的例子：</p><p><code>chmod u=rwx,go=rx .bashrc</code></p><p><code> chmod a+w .bashrc</code></p><p>一些常用的权限：</p><table><thead><tr><th>Setting</th><th>Numerical</th><th>Meaning</th></tr></thead><tbody><tr><td><code>-rw-------</code></td><td>(600)</td><td>Only the owner has read and write permissions.</td></tr><tr><td><code>-rw-r--r--</code></td><td>(644)</td><td>Only the owner has read and write permissions; the group and others have read only.</td></tr><tr><td><code>-rwx------</code></td><td>(700)</td><td>Only the owner has read, write, and execute permissions.</td></tr><tr><td><code>-rwxr-xr-x</code></td><td>(755)</td><td>The owner has read, write, and execute permissions; the group and others have only read and execute.</td></tr><tr><td><code>-rwx--x--x</code></td><td>(711)</td><td>The owner has read, write, and execute permissions; the group and others have only  execute.</td></tr><tr><td><code>-rw-rw-rw-</code></td><td>(666)</td><td>Everyone can read and write to the file.  (Becareful with these permissions.)</td></tr><tr><td><code>-rwxrwxrwx</code></td><td>(777)</td><td>Everyone can read, write, and execute. (Again, this permissions setting can be hazardous.)</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/12/01/2021/hello-world/"/>
    <url>/2018/12/01/2021/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hexo default file</p><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
